{"version":3,"file":"fullStackWithKtor.js","mappings":";CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAA2B,kBAAID,IAE/BD,EAAwB,kBAAIC,GAC7B,CATD,CASGK,MAAM,cCRLC,EADAC,kDCqDJ,IAAIC,EAA0B,WAE5B,SAASA,EAAWC,GAClB,IAAIC,EAAQL,KAEZA,KAAKM,WAAa,SAAUC,GAC1B,IAAIC,EAIAA,EAFsB,IAAtBH,EAAMI,KAAKC,OACTL,EAAMM,eACCN,EAAMM,eAAeC,YACrBP,EAAMQ,QACNR,EAAMS,UAAUC,WAEhBV,EAAMG,OAGRH,EAAMI,KAAKJ,EAAMI,KAAKC,OAAS,GAAGE,YAG7CP,EAAMS,UAAUE,aAAaT,EAAKC,GAElCH,EAAMI,KAAKQ,KAAKV,EAClB,EAEAP,KAAKkB,cAA8BC,IAAnBf,EAAQgB,QAA+DhB,EAAQgB,OAC/FpB,KAAKS,KAAO,GACZT,KAAKqB,IAAM,EACXrB,KAAKsB,MAAQlB,EAAQkB,MAErBtB,KAAKuB,IAAMnB,EAAQmB,IACnBvB,KAAKc,UAAYV,EAAQU,UACzBd,KAAKa,QAAUT,EAAQS,QACvBb,KAAKW,eAAiBP,EAAQO,eAC9BX,KAAKQ,OAAS,IAChB,CAEA,IAAIgB,EAASrB,EAAWsB,UA4DxB,OA1DAD,EAAOE,QAAU,SAAiBC,GAChCA,EAAMC,QAAQ5B,KAAKM,WACrB,EAEAkB,EAAOK,OAAS,SAAgBC,GAI1B9B,KAAKqB,KAAOrB,KAAKkB,SAAW,KAAQ,IAAO,GAC7ClB,KAAKM,WA7DX,SAA4BF,GAC1B,IAAIG,EAAMwB,SAASC,cAAc,SASjC,OARAzB,EAAI0B,aAAa,eAAgB7B,EAAQmB,UAEnBJ,IAAlBf,EAAQkB,OACVf,EAAI0B,aAAa,QAAS7B,EAAQkB,OAGpCf,EAAI2B,YAAYH,SAASI,eAAe,KACxC5B,EAAI0B,aAAa,SAAU,IACpB1B,CACT,CAkDsB6B,CAAmBpC,OAGrC,IAAIO,EAAMP,KAAKS,KAAKT,KAAKS,KAAKC,OAAS,GAcvC,GAAIV,KAAKkB,SAAU,CACjB,IAAImB,EAhGV,SAAqB9B,GACnB,GAAIA,EAAI8B,MAEN,OAAO9B,EAAI8B,MAMb,IAAK,IAAIC,EAAI,EAAGA,EAAIP,SAASQ,YAAY7B,OAAQ4B,IAC/C,GAAIP,SAASQ,YAAYD,GAAGE,YAAcjC,EAExC,OAAOwB,SAASQ,YAAYD,EAGlC,CAiFkBG,CAAYlC,GAExB,IAGE8B,EAAMK,WAAWZ,EAAMO,EAAMM,SAASjC,OAKxC,CAJE,MAAOkC,GAIT,CACF,MACErC,EAAI2B,YAAYH,SAASI,eAAeL,IAG1C9B,KAAKqB,KACP,EAEAG,EAAOqB,MAAQ,WAEb7C,KAAKS,KAAKmB,SAAQ,SAAUrB,GAC1B,OAAOA,EAAIuC,YAAcvC,EAAIuC,WAAWC,YAAYxC,EACtD,IACAP,KAAKS,KAAO,GACZT,KAAKqB,IAAM,CAKb,EAEOlB,CACT,CAlG8B,GCjDnB6C,EAAMC,KAAKD,IAMX,EAAOE,OAAOC,aAMd,EAASC,OAAOC,OAepB,SAASC,EAAMC,GACrB,OAAOA,EAAMD,MACd,CAiBO,SAAS,EAASC,EAAOC,EAASC,GACxC,OAAOF,EAAMG,QAAQF,EAASC,EAC/B,CAOO,SAASE,EAASJ,EAAOK,GAC/B,OAAOL,EAAMM,QAAQD,EACtB,CAOO,SAAS,EAAQL,EAAOO,GAC9B,OAAiC,EAA1BP,EAAMQ,WAAWD,EACzB,CAQO,SAAS,EAAQP,EAAOS,EAAOC,GACrC,OAAOV,EAAMW,MAAMF,EAAOC,EAC3B,CAMO,SAAS,EAAQV,GACvB,OAAOA,EAAM7C,MACd,CAMO,SAAS,EAAQ6C,GACvB,OAAOA,EAAM7C,MACd,CAOO,SAAS,EAAQ6C,EAAOY,GAC9B,OAAOA,EAAMlD,KAAKsC,GAAQA,CAC3B,CCvGO,IAAIa,EAAO,EACPC,EAAS,EACT,EAAS,EACTC,EAAW,EACXC,EAAY,EACZC,EAAa,GAWjB,SAASC,EAAMlB,EAAO7D,EAAMgF,EAAQC,EAAMC,EAAOC,EAAUnE,GACjE,MAAO,CAAC6C,MAAOA,EAAO7D,KAAMA,EAAMgF,OAAQA,EAAQC,KAAMA,EAAMC,MAAOA,EAAOC,SAAUA,EAAUT,KAAMA,EAAMC,OAAQA,EAAQ3D,OAAQA,EAAQoE,OAAQ,GACrJ,CAOO,SAAS,EAAMpF,EAAMkF,GAC3B,OAAO,EAAOH,EAAK,GAAI,KAAM,KAAM,GAAI,KAAM,KAAM,GAAI/E,EAAM,CAACgB,QAAShB,EAAKgB,QAASkE,EACtF,CAYO,SAASG,IAMf,OALAR,EAAYD,EAAW,EAAI,EAAOE,IAAcF,GAAY,EAExDD,IAAwB,KAAdE,IACbF,EAAS,EAAGD,KAENG,CACR,CAKO,SAASS,IAMf,OALAT,EAAYD,EAAW,EAAS,EAAOE,EAAYF,KAAc,EAE7DD,IAAwB,KAAdE,IACbF,EAAS,EAAGD,KAENG,CACR,CAKO,SAASU,IACf,OAAO,EAAOT,EAAYF,EAC3B,CAKO,SAASY,IACf,OAAOZ,CACR,CAOO,SAASJ,EAAOF,EAAOC,GAC7B,OAAO,EAAOO,EAAYR,EAAOC,EAClC,CAMO,SAASkB,EAAOR,GACtB,OAAQA,GAEP,KAAK,EAAG,KAAK,EAAG,KAAK,GAAI,KAAK,GAAI,KAAK,GACtC,OAAO,EAER,KAAK,GAAI,KAAK,GAAI,KAAK,GAAI,KAAK,GAAI,KAAK,GAAI,KAAK,GAAI,KAAK,IAE3D,KAAK,GAAI,KAAK,IAAK,KAAK,IACvB,OAAO,EAER,KAAK,GACJ,OAAO,EAER,KAAK,GAAI,KAAK,GAAI,KAAK,GAAI,KAAK,GAC/B,OAAO,EAER,KAAK,GAAI,KAAK,GACb,OAAO,EAGT,OAAO,CACR,CAMO,SAASS,EAAO7B,GACtB,OAAOa,EAAOC,EAAS,EAAG,EAAS,EAAOG,EAAajB,GAAQe,EAAW,EAAG,EAC9E,CAMO,SAASe,EAAS9B,GACxB,OAAOiB,EAAa,GAAIjB,CACzB,CAMO,SAAS+B,EAASX,GACxB,OAAOrB,EAAKY,EAAMI,EAAW,EAAGiB,EAAmB,KAATZ,EAAcA,EAAO,EAAa,KAATA,EAAcA,EAAO,EAAIA,IAC7F,CAcO,SAASa,EAAYb,GAC3B,MAAOJ,EAAYU,MACdV,EAAY,IACfS,IAIF,OAAOG,EAAMR,GAAQ,GAAKQ,EAAMZ,GAAa,EAAI,GAAK,GACvD,CAwBO,SAASkB,EAAU3B,EAAO4B,GAChC,OAASA,GAASV,OAEbT,EAAY,IAAMA,EAAY,KAAQA,EAAY,IAAMA,EAAY,IAAQA,EAAY,IAAMA,EAAY,MAG/G,OAAOL,EAAMJ,EAAOoB,KAAWQ,EAAQ,GAAe,IAAVT,KAA0B,IAAVD,KAC7D,CAMO,SAASO,EAAWZ,GAC1B,KAAOK,YACET,GAEP,KAAKI,EACJ,OAAOL,EAER,KAAK,GAAI,KAAK,GACA,KAATK,GAAwB,KAATA,GAClBY,EAAUhB,GACX,MAED,KAAK,GACS,KAATI,GACHY,EAAUZ,GACX,MAED,KAAK,GACJK,IAIH,OAAOV,CACR,CAOO,SAASqB,EAAWhB,EAAMb,GAChC,KAAOkB,KAEFL,EAAOJ,IAAc,KAGhBI,EAAOJ,IAAc,IAAsB,KAAXU,OAG1C,MAAO,KAAOf,EAAMJ,EAAOQ,EAAW,GAAK,IAAM,EAAc,KAATK,EAAcA,EAAOK,IAC5E,CAMO,SAASY,EAAY9B,GAC3B,MAAQqB,EAAMF,MACbD,IAED,OAAOd,EAAMJ,EAAOQ,EACrB,CCrPO,IAAI,EAAK,OAEL,EAAS,WAETuB,EAAU,OACV,EAAU,OACV,EAAc,OAUd,EAAY,aCRhB,SAAS,EAAWhB,EAAUiB,GAIpC,IAHA,IAAIC,EAAS,GACTrF,EAAS,EAAOmE,GAEXvC,EAAI,EAAGA,EAAI5B,EAAQ4B,IAC3ByD,GAAUD,EAASjB,EAASvC,GAAIA,EAAGuC,EAAUiB,IAAa,GAE3D,OAAOC,CACR,CASO,SAASC,EAAWC,EAASnC,EAAOe,EAAUiB,GACpD,OAAQG,EAAQtB,MACf,IDjBkB,UCiBL,KAAK,EAAa,OAAOsB,EAAQnB,OAASmB,EAAQnB,QAAUmB,EAAQ1C,MACjF,KAAKsC,EAAS,MAAO,GACrB,KAAK,EAAW,OAAOI,EAAQnB,OAASmB,EAAQ1C,MAAQ,IAAM,EAAU0C,EAAQpB,SAAUiB,GAAY,IACtG,KAAK,EAASG,EAAQ1C,MAAQ0C,EAAQrB,MAAMsB,KAAK,KAGlD,OAAO,EAAOrB,EAAW,EAAUoB,EAAQpB,SAAUiB,IAAaG,EAAQnB,OAASmB,EAAQ1C,MAAQ,IAAMsB,EAAW,IAAM,EAC3H,CC1BO,SAASsB,EAAS5C,GACxB,OAAO8B,EAAQe,EAAM,GAAI,KAAM,KAAM,KAAM,CAAC,IAAK7C,EAAQ6B,EAAM7B,GAAQ,EAAG,CAAC,GAAIA,GAChF,CAcO,SAAS6C,EAAO7C,EAAO7D,EAAMgF,EAAQ5C,EAAMuE,EAAOC,EAAUC,EAAQC,EAAQC,GAiBlF,IAhBA,IAAI3C,EAAQ,EACR4C,EAAS,EACThG,EAAS6F,EACTI,EAAS,EACTC,EAAW,EACXC,EAAW,EACXC,EAAW,EACXC,EAAW,EACXC,EAAY,EACZzC,EAAY,EACZI,EAAO,GACPC,EAAQyB,EACRxB,EAAWyB,EACXW,EAAYnF,EACZ0C,EAAaG,EAEVoC,UACEF,EAAWtC,EAAWA,EAAYS,KAEzC,KAAK,GACJ,GAAgB,KAAZ6B,GAAqD,IAAlC,EAAOrC,EAAY9D,EAAS,GAAU,EACkB,GAA1EiD,EAAQa,GAAc,EAAQc,EAAQf,GAAY,IAAK,OAAQ,SAClEyC,GAAa,GACd,KACD,CAED,KAAK,GAAI,KAAK,GAAI,KAAK,GACtBxC,GAAcc,EAAQf,GACtB,MAED,KAAK,EAAG,KAAK,GAAI,KAAK,GAAI,KAAK,GAC9BC,GAAcgB,EAAWqB,GACzB,MAED,KAAK,GACJrC,GAAciB,EAASP,IAAU,EAAG,GACpC,SAED,KAAK,GACJ,OAAQD,KACP,KAAK,GAAI,KAAK,GACb,EAAOiC,EAAQvB,EAAUX,IAAQE,KAAUxF,EAAMgF,GAAS+B,GAC1D,MACD,QACCjC,GAAc,IAEhB,MAED,KAAK,IAAMsC,EACVN,EAAO1C,KAAW,EAAOU,GAAcwC,EAExC,KAAK,IAAMF,EAAU,KAAK,GAAI,KAAK,EAClC,OAAQvC,GAEP,KAAK,EAAG,KAAK,IAAKwC,EAAW,EAE7B,KAAK,GAAKL,EACLE,EAAW,GAAM,EAAOpC,GAAc9D,GACzC,EAAOkG,EAAW,GAAKO,EAAY3C,EAAa,IAAK1C,EAAM4C,EAAQhE,EAAS,GAAKyG,EAAY,EAAQ3C,EAAY,IAAK,IAAM,IAAK1C,EAAM4C,EAAQhE,EAAS,GAAI+F,GAC7J,MAED,KAAK,GAAIjC,GAAc,IAEvB,QAGC,GAFA,EAAOyC,EAAYG,EAAQ5C,EAAY9E,EAAMgF,EAAQZ,EAAO4C,EAAQL,EAAOG,EAAQ7B,EAAMC,EAAQ,GAAIC,EAAW,GAAInE,GAAS4F,GAE3G,MAAd/B,EACH,GAAe,IAAXmC,EACHN,EAAM5B,EAAY9E,EAAMuH,EAAWA,EAAWrC,EAAO0B,EAAU5F,EAAQ8F,EAAQ3B,QAE/E,OAAmB,KAAX8B,GAA2C,MAA1B,EAAOnC,EAAY,GAAa,IAAMmC,GAE9D,KAAK,IAAK,KAAK,IAAK,KAAK,IACxBP,EAAM7C,EAAO0D,EAAWA,EAAWnF,GAAQ,EAAOsF,EAAQ7D,EAAO0D,EAAWA,EAAW,EAAG,EAAGZ,EAAOG,EAAQ7B,EAAM0B,EAAOzB,EAAQ,GAAIlE,GAASmE,GAAWwB,EAAOxB,EAAUnE,EAAQ8F,EAAQ1E,EAAO8C,EAAQC,GACzM,MACD,QACCuB,EAAM5B,EAAYyC,EAAWA,EAAWA,EAAW,CAAC,IAAKpC,EAAU,EAAG2B,EAAQ3B,IAIpFf,EAAQ4C,EAASE,EAAW,EAAGE,EAAWE,EAAY,EAAGrC,EAAOH,EAAa,GAAI9D,EAAS6F,EAC1F,MAED,KAAK,GACJ7F,EAAS,EAAI,EAAO8D,GAAaoC,EAAWC,EAC7C,QACC,GAAIC,EAAW,EACd,GAAiB,KAAbvC,IACDuC,OACE,GAAiB,KAAbvC,GAAkC,GAAduC,KAA6B,KAAV/B,IAC/C,SAEF,OAAQP,GAAc,EAAKD,GAAYA,EAAYuC,GAElD,KAAK,GACJE,EAAYN,EAAS,EAAI,GAAKlC,GAAc,MAAO,GACnD,MAED,KAAK,GACJgC,EAAO1C,MAAY,EAAOU,GAAc,GAAKwC,EAAWA,EAAY,EACpE,MAED,KAAK,GAEW,KAAX/B,MACHT,GAAcc,EAAQN,MAEvB2B,EAAS1B,IAAQyB,EAAShG,EAAS,EAAOiE,EAAOH,GAAcoB,EAAWV,MAAWX,IACrF,MAED,KAAK,GACa,KAAbsC,GAAyC,GAAtB,EAAOrC,KAC7BsC,EAAW,IAIjB,OAAOR,CACR,CAgBO,SAASc,EAAS7D,EAAO7D,EAAMgF,EAAQZ,EAAO4C,EAAQL,EAAOG,EAAQ7B,EAAMC,EAAOC,EAAUnE,GAKlG,IAJA,IAAI2G,EAAOX,EAAS,EAChB5E,EAAkB,IAAX4E,EAAeL,EAAQ,CAAC,IAC/BiB,EAAO,EAAOxF,GAETQ,EAAI,EAAGiF,EAAI,EAAGC,EAAI,EAAGlF,EAAIwB,IAASxB,EAC1C,IAAK,IAAImF,EAAI,EAAGC,EAAI,EAAOnE,EAAO8D,EAAO,EAAGA,EAAOrE,EAAIuE,EAAIf,EAAOlE,KAAMqF,EAAIpE,EAAOkE,EAAIH,IAAQG,GAC1FE,EAAIrE,EAAKiE,EAAI,EAAIzF,EAAK2F,GAAK,IAAMC,EAAI,EAAQA,EAAG,OAAQ5F,EAAK2F,QAChE7C,EAAM4C,KAAOG,GAEhB,OAAOlD,EAAKlB,EAAO7D,EAAMgF,EAAmB,IAAXgC,EAAe,EAAU/B,EAAMC,EAAOC,EAAUnE,EAClF,CAQO,SAASwG,EAAS3D,EAAO7D,EAAMgF,GACrC,OAAOD,EAAKlB,EAAO7D,EAAMgF,EAAQmB,EAAS,EH/InCtB,GG+IiD,EAAOhB,EAAO,GAAI,GAAI,EAC/E,CASO,SAAS4D,EAAa5D,EAAO7D,EAAMgF,EAAQhE,GACjD,OAAO+D,EAAKlB,EAAO7D,EAAMgF,EAAQ,EAAa,EAAOnB,EAAO,EAAG7C,GAAS,EAAO6C,EAAO7C,EAAS,GAAI,GAAIA,EACxG,CCzLA,IAAIkH,EAA8B,SAAqC5D,EAAOwC,EAAQ1C,GAIpF,IAHA,IAAI+C,EAAW,EACXtC,EAAY,EAGdsC,EAAWtC,EACXA,EAAYU,IAEK,KAAb4B,GAAiC,KAAdtC,IACrBiC,EAAO1C,GAAS,IAGdqB,EAAMZ,IAIVS,IAGF,OAAOd,EAAMF,EAAOM,EACtB,EAkDIuD,EAA+B,IAAIC,QACnCC,EAAS,SAAgB9B,GAC3B,GAAqB,SAAjBA,EAAQtB,MAAoBsB,EAAQvB,UAExCuB,EAAQvF,OAAS,GAFjB,CAUA,IAJA,IAAI6C,EAAQ0C,EAAQ1C,MAChBmB,EAASuB,EAAQvB,OACjBsD,EAAiB/B,EAAQ5B,SAAWK,EAAOL,QAAU4B,EAAQ7B,OAASM,EAAON,KAE1D,SAAhBM,EAAOC,MAEZ,KADAD,EAASA,EAAOA,QACH,OAIf,IAA6B,IAAzBuB,EAAQrB,MAAMlE,QAAwC,KAAxB6C,EAAMQ,WAAW,IAE/C8D,EAAcI,IAAIvD,MAMlBsD,EAAJ,CAIAH,EAAcK,IAAIjC,GAAS,GAK3B,IAJA,IAAIO,EAAS,GACTH,EArCS,SAAkB9C,EAAOiD,GACtC,OAAOnB,EA5CK,SAAiB8C,EAAQ3B,GAErC,IAAI1C,GAAS,EACTS,EAAY,GAEhB,GACE,OAAQY,EAAMZ,IACZ,KAAK,EAEe,KAAdA,GAA+B,KAAXU,MAKtBuB,EAAO1C,GAAS,GAGlBqE,EAAOrE,IAAU8D,EAA4BtD,EAAW,EAAGkC,EAAQ1C,GACnE,MAEF,KAAK,EACHqE,EAAOrE,IAAUwB,EAAQf,GACzB,MAEF,KAAK,EAEH,GAAkB,KAAdA,EAAkB,CAEpB4D,IAASrE,GAAoB,KAAXmB,IAAgB,MAAQ,GAC1CuB,EAAO1C,GAASqE,EAAOrE,GAAOpD,OAC9B,KACF,CAIF,QACEyH,EAAOrE,IAAU,EAAKS,UAEnBA,EAAYS,KAErB,OAAOmD,CACT,CAGiBC,CAAQhD,EAAM7B,GAAQiD,GACvC,CAmCc6B,CAAS9E,EAAOiD,GACxB8B,EAAc5D,EAAOE,MAEhBtC,EAAI,EAAGkF,EAAI,EAAGlF,EAAI+D,EAAM3F,OAAQ4B,IACvC,IAAK,IAAIiF,EAAI,EAAGA,EAAIe,EAAY5H,OAAQ6G,IAAKC,IAC3CvB,EAAQrB,MAAM4C,GAAKhB,EAAOlE,GAAK+D,EAAM/D,GAAGoB,QAAQ,OAAQ4E,EAAYf,IAAMe,EAAYf,GAAK,IAAMlB,EAAM/D,EAT3G,CAtBA,CAkCF,EACIiG,EAAc,SAAqBtC,GACrC,GAAqB,SAAjBA,EAAQtB,KAAiB,CAC3B,IAAIpB,EAAQ0C,EAAQ1C,MAGI,MAAxBA,EAAMQ,WAAW,IACO,KAAxBR,EAAMQ,WAAW,KAEfkC,EAAgB,OAAI,GACpBA,EAAQ1C,MAAQ,GAEpB,CACF,EAgHA,SAAS,GAAOA,EAAO7C,GACrB,OL1NK,SAAe6C,EAAO7C,GAC5B,OAA0B,GAAnB,EAAO6C,EAAO,MAAiB7C,GAAU,EAAK,EAAO6C,EAAO,KAAO,EAAK,EAAOA,EAAO,KAAO,EAAK,EAAOA,EAAO,KAAO,EAAK,EAAOA,EAAO,GAAK,CACvJ,CKwNUiF,CAAKjF,EAAO7C,IAElB,KAAK,KACH,MAAO,iBAAoB6C,EAAQA,EAGrC,KAAK,KACL,KAAK,KACL,KAAK,KACL,KAAK,KACL,KAAK,KACL,KAAK,KACL,KAAK,KAEL,KAAK,KACL,KAAK,KACL,KAAK,KACL,KAAK,KACL,KAAK,KACL,KAAK,KAEL,KAAK,KACL,KAAK,KACL,KAAK,KACL,KAAK,KACL,KAAK,KACL,KAAK,KAEL,KAAK,KACL,KAAK,KACL,KAAK,KACL,KAAK,KACL,KAAK,KACL,KAAK,KACH,OAAO,EAASA,EAAQA,EAG1B,KAAK,KACL,KAAK,KACL,KAAK,KACL,KAAK,KACL,KAAK,KACH,OAAO,EAASA,EH1RL,QG0RmBA,EAAQ,EAAKA,EAAQA,EAGrD,KAAK,KACL,KAAK,KACH,OAAO,EAASA,EAAQ,EAAKA,EAAQA,EAGvC,KAAK,KACH,OAAO,EAASA,EAAQ,EAAK,QAAUA,EAAQA,EAGjD,KAAK,KACH,OAAO,EAASA,EAAQ,EAAQA,EAAO,iBAAkB,iCAA0CA,EAGrG,KAAK,KACH,OAAO,EAASA,EAAQ,EAAK,aAAe,EAAQA,EAAO,cAAe,IAAMA,EAGlF,KAAK,KACH,OAAO,EAASA,EAAQ,EAAK,iBAAmB,EAAQA,EAAO,4BAA6B,IAAMA,EAGpG,KAAK,KACH,OAAO,EAASA,EAAQ,EAAK,EAAQA,EAAO,SAAU,YAAcA,EAGtE,KAAK,KACH,OAAO,EAASA,EAAQ,EAAK,EAAQA,EAAO,QAAS,kBAAoBA,EAG3E,KAAK,KACH,MAAO,eAAkB,EAAQA,EAAO,QAAS,IAAM,EAASA,EAAQ,EAAK,EAAQA,EAAO,OAAQ,YAAcA,EAGpH,KAAK,KACH,OAAO,EAAS,EAAQA,EAAO,qBAAsB,gBAAwBA,EAG/E,KAAK,KACH,OAAO,EAAQ,EAAQ,EAAQA,EAAO,eAAgB,cAAgB,cAAe,cAAgBA,EAAO,IAAMA,EAGpH,KAAK,KACL,KAAK,KACH,OAAO,EAAQA,EAAO,oBAAqB,kBAG7C,KAAK,KACH,OAAO,EAAQ,EAAQA,EAAO,oBAAqB,uCAA+C,aAAc,WAAa,EAASA,EAAQA,EAGhJ,KAAK,KACL,KAAK,KACL,KAAK,KACL,KAAK,KACH,OAAO,EAAQA,EAAO,kBAAmB,gBAAmBA,EAG9D,KAAK,KACL,KAAK,KACL,KAAK,KACL,KAAK,KACL,KAAK,KACL,KAAK,KACL,KAAK,KACL,KAAK,KACL,KAAK,KACL,KAAK,KACL,KAAK,KACL,KAAK,KAEH,GAAI,EAAOA,GAAS,EAAI7C,EAAS,EAAG,OAAQ,EAAO6C,EAAO7C,EAAS,IAEjE,KAAK,IAEH,GAAkC,KAA9B,EAAO6C,EAAO7C,EAAS,GAAW,MAGxC,KAAK,IACH,OAAO,EAAQ6C,EAAO,mBAAoB,0BAAqE,KAA7B,EAAOA,EAAO7C,EAAS,GAAY,KAAO,UAAY6C,EAG1I,KAAK,IACH,OAAQI,EAAQJ,EAAO,WAAa,GAAO,EAAQA,EAAO,UAAW,kBAAmB7C,GAAU6C,EAAQA,EAE9G,MAGF,KAAK,KAEH,GAAkC,MAA9B,EAAOA,EAAO7C,EAAS,GAAY,MAGzC,KAAK,KACH,OAAQ,EAAO6C,EAAO,EAAOA,GAAS,IAAMI,EAAQJ,EAAO,eAAiB,MAE1E,KAAK,IACH,OAAO,EAAQA,EAAO,IAAK,aAAgBA,EAG7C,KAAK,IACH,OAAO,EAAQA,EAAO,wBAAyB,cAAuC,KAAtB,EAAOA,EAAO,IAAa,UAAY,IAAxD,oCAA0HA,EAG7K,MAGF,KAAK,KACH,OAAQ,EAAOA,EAAO7C,EAAS,KAE7B,KAAK,IACH,OAAO,EAAS6C,EAAQ,EAAK,EAAQA,EAAO,qBAAsB,MAAQA,EAG5E,KAAK,IACH,OAAO,EAASA,EAAQ,EAAK,EAAQA,EAAO,qBAAsB,SAAWA,EAG/E,KAAK,GACH,OAAO,EAASA,EAAQ,EAAK,EAAQA,EAAO,qBAAsB,MAAQA,EAG9E,OAAO,EAASA,EAAQ,EAAKA,EAAQA,EAGzC,OAAOA,CACT,CAEA,IAqCIkF,GAAuB,CArCZ,SAAkBxC,EAASnC,EAAOe,EAAUiB,GACzD,GAAIG,EAAQvF,QAAU,IAAQuF,EAAgB,OAAG,OAAQA,EAAQtB,MAC/D,KAAK,EACHsB,EAAgB,OAAI,GAAOA,EAAQ1C,MAAO0C,EAAQvF,QAClD,MAEF,KAAK,EACH,OAAO,EAAU,CAAC,EAAKuF,EAAS,CAC9B1C,MAAO,EAAQ0C,EAAQ1C,MAAO,IAAK,gBAChCuC,GAEP,KAAK,EACH,GAAIG,EAAQvF,OAAQ,OLzTnB,SAAkByD,EAAO2B,GAC/B,OAAO3B,EAAMuE,IAAI5C,GAAUI,KAAK,GACjC,CKuTiC,CAAQD,EAAQrB,OAAO,SAAUrB,GAC1D,OLlYD,SAAgBA,EAAOC,GAC7B,OAAQD,EKiYoB,wBLjYJoF,KAAKpF,IAAUA,EAAM,GAAKA,CACnD,CKgYgB,CAAMA,IAEZ,IAAK,aACL,IAAK,cACH,OAAO,EAAU,CAAC,EAAK0C,EAAS,CAC9BrB,MAAO,CAAC,EAAQrB,EAAO,cAAe,gBACnCuC,GAGP,IAAK,gBACH,OAAO,EAAU,CAAC,EAAKG,EAAS,CAC9BrB,MAAO,CAAC,EAAQrB,EAAO,aAAc,wBACnC,EAAK0C,EAAS,CAChBrB,MAAO,CAAC,EAAQrB,EAAO,aAAc,eACnC,EAAK0C,EAAS,CAChBrB,MAAO,CAAC,EAAQrB,EAAO,aAAc,oBAClCuC,GAGT,MAAO,EACT,IAEN,GAsIA,SAlIkB,SAAqB1F,GACrC,IAAImB,EAAMnB,EAAQmB,IAMlB,GAAa,QAARA,EAAe,CAClB,IAAIqH,EAAY7G,SAAS8G,iBAAiB,qCAK1CC,MAAMrH,UAAUG,QAAQmH,KAAKH,GAAW,SAAUnE,IASL,IAFhBA,EAAKuE,aAAa,gBAEpBnF,QAAQ,OAGjC9B,SAASkH,KAAK/G,YAAYuC,GAC1BA,EAAKxC,aAAa,SAAU,IAC9B,GACF,CAEA,IAUInB,EAkBAoI,EA5BAC,EAAgB/I,EAAQ+I,eAAiBV,GASzCW,EAAW,CAAC,EAEZC,EAAiB,GAGnBvI,EAAYV,EAAQU,WAAaiB,SAASkH,KAC1CH,MAAMrH,UAAUG,QAAQmH,KAExBhH,SAAS8G,iBAAiB,wBAA2BtH,EAAM,QAAS,SAAUkD,GAG5E,IAFA,IAAI6E,EAAS7E,EAAKuE,aAAa,gBAAgBO,MAAM,KAE5CjH,EAAI,EAAGA,EAAIgH,EAAO5I,OAAQ4B,IACjC8G,EAASE,EAAOhH,KAAM,EAGxB+G,EAAepI,KAAKwD,EACtB,IAiBA,IAAI+E,EClgBoBC,EACvB/I,EAgBsBoF,EDkfnB4D,EAAoB,CAAC1D,GClfFF,ED4fT,SAAUhE,GACtB0H,EAAa3H,OAAOC,EACtB,EC7fI,SAAUmE,GACXA,EAAQvG,OACRuG,EAAUA,EAAQnB,SACrBgB,EAASG,EACZ,ID0fO0D,GChhBoBF,EDsfD,CAAC1B,EAAQQ,GA0BeqB,OAAOT,EAAeO,GC/gBpEhJ,EAAS,EAAO+I,GAEb,SAAUxD,EAASnC,EAAOe,EAAUiB,GAG1C,IAFA,IAAIC,EAAS,GAEJzD,EAAI,EAAGA,EAAI5B,EAAQ4B,IAC3ByD,GAAU0D,EAAWnH,GAAG2D,EAASnC,EAAOe,EAAUiB,IAAa,GAEhE,OAAOC,CACR,GD4gBGmD,EAAU,SAAgBW,EAAUC,EAAYzH,EAAO0H,GACrDP,EAAenH,EAJR,EAAU8D,EAcV0D,EAAWA,EAAW,IAAMC,EAAWE,OAAS,IAAMF,EAAWE,QAdtCL,GAgB9BI,IACFE,EAAMb,SAASU,EAAWI,OAAQ,EAEtC,EAGF,IAAID,EAAQ,CACV1I,IAAKA,EACLc,MAAO,IAAIlC,EAAW,CACpBoB,IAAKA,EACLT,UAAWA,EACXQ,MAAOlB,EAAQkB,MACfF,OAAQhB,EAAQgB,OAChBP,QAAST,EAAQS,QACjBF,eAAgBP,EAAQO,iBAE1BW,MAAOlB,EAAQkB,MACf8H,SAAUA,EACVe,WAAY,CAAC,EACbtI,OAAQqH,GAGV,OADAe,EAAM5H,MAAMX,QAAQ2H,GACbY,CACT,0NEhkBA,SAASG,EAAqBH,EAAOH,GACnC,QAAwC3I,IAApC8I,EAAMb,SAASU,EAAWI,MAC5B,OAAOD,EAAMpI,OAAO,GAAIiI,EAAYG,EAAM5H,OAAO,EAErD,CAEA,SAASgI,EAAMF,EAAYG,EAAKC,GAC9B,IAAIC,EAAmB,GACnBC,GAAe,QAAoBN,EAAYK,EAAkBD,GAErE,OAAIC,EAAiB9J,OAAS,EACrB6J,EAGFE,EAAeH,EAAIE,EAC5B,CAEA,IA6EIE,EAAa,SAASA,EAAWC,GAGnC,IAFA,IAAIC,EAAM,GAEDtI,EAAI,EAAGA,EAAIqI,EAAKjK,OAAQ4B,IAAK,CACpC,IAAIuI,EAAMF,EAAKrI,GACf,GAAW,MAAPuI,EAAJ,CACA,IAAIC,OAAQ,EAEZ,cAAeD,GACb,IAAK,UACH,MAEF,IAAK,SAED,GAAI/B,MAAMiC,QAAQF,GAChBC,EAAQJ,EAAWG,QAInB,IAAK,IAAIrD,KAFTsD,EAAQ,GAEMD,EACRA,EAAIrD,IAAMA,IACZsD,IAAUA,GAAS,KACnBA,GAAStD,GAKf,MAGJ,QAEIsD,EAAQD,EAIVC,IACFF,IAAQA,GAAO,KACfA,GAAOE,EAjCgB,CAmC3B,CAEA,OAAOF,CACT,ECxIA,IAAII,EDgBgB,SAAuB5K,GACzC,IAAI6J,GAAQ,OAAY7J,GAExB6J,EAAM5H,MAAMjB,OAAS,SAAUmC,GAK7BvD,KAAKkB,SAAWqC,CAClB,EAEA0G,EAAMlC,QAAS,EAEf,IAAIuC,EAAM,WACR,IAAK,IAAIW,EAAOC,UAAUxK,OAAQiK,EAAO,IAAI7B,MAAMmC,GAAOE,EAAO,EAAGA,EAAOF,EAAME,IAC/ER,EAAKQ,GAAQD,UAAUC,GAGzB,IAAIrB,GAAa,OAAgBa,EAAMV,EAAME,gBAAYhJ,GAEzD,OADA,QAAa8I,EAAOH,GAAY,GACzBG,EAAM1I,IAAM,IAAMuI,EAAWI,IACtC,EAiCA,MAAO,CACLI,IAAKA,EACLc,GAVO,WACP,IAAK,IAAIC,EAAQH,UAAUxK,OAAQiK,EAAO,IAAI7B,MAAMuC,GAAQC,EAAQ,EAAGA,EAAQD,EAAOC,IACpFX,EAAKW,GAASJ,UAAUI,GAG1B,OAAOjB,EAAMJ,EAAME,WAAYG,EAAKI,EAAWC,GACjD,EAKEY,aApBiB,WACjB,IAAK,IAAIC,EAAQN,UAAUxK,OAAQiK,EAAO,IAAI7B,MAAM0C,GAAQC,EAAQ,EAAGA,EAAQD,EAAOC,IACpFd,EAAKc,GAASP,UAAUO,GAG1B,IAAI3B,GAAa,OAAgBa,EAAMV,EAAME,YAC7CC,EAAqBH,EAAOH,EAC9B,EAcE4B,UAnCc,WACd,IAAK,IAAIC,EAAQT,UAAUxK,OAAQiK,EAAO,IAAI7B,MAAM6C,GAAQC,EAAQ,EAAGA,EAAQD,EAAOC,IACpFjB,EAAKiB,GAASV,UAAUU,GAG1B,IAAI9B,GAAa,OAAgBa,EAAMV,EAAME,YACzC0B,EAAY,aAAe/B,EAAWI,KAK1C,OAJAE,EAAqBH,EAAO,CAC1BC,KAAMJ,EAAWI,KACjBF,OAAQ,cAAgB6B,EAAY,IAAM/B,EAAWE,OAAS,MAEzD6B,CACT,EAwBEnK,QAAS,SAAiBoK,GACxBA,EAAIlK,SAAQ,SAAUL,GACpB0I,EAAMb,SAAS7H,IAAO,CACxB,GACF,EACAsB,MAAO,WACLoH,EAAME,WAAa,CAAC,EACpBF,EAAMb,SAAW,CAAC,EAClBa,EAAM5H,MAAMQ,OACd,EAEAR,MAAO4H,EAAM5H,MACb4H,MAAOA,EACP8B,oBAAqB,UAAyB,KAAM9B,EAAME,YAC1DE,MAAOA,EAAM2B,KAAK,KAAM/B,EAAME,WAAYG,GAE9C,CC3FqB,CAAc,CACjC/I,IAAK,QAEHsB,EAAQmI,EAAenI,MACvBnB,EAAUsJ,EAAetJ,QACzB0J,EAAKJ,EAAeI,GACpB,EAAQJ,EAAeX,MACvB0B,EAAsBf,EAAee,oBACrCR,EAAeP,EAAeO,aAC9BG,EAAYV,EAAeU,UAC3BpB,EAAMU,EAAeV,IACrBjI,EAAQ2I,EAAe3I,MACvB4H,EAAQe,EAAef,mDCT3B,QARA,SAAiBgC,GACf,IAAIhC,EAAQ7G,OAAO8I,OAAO,MAC1B,OAAO,SAAUrB,GAEf,YADmB1J,IAAf8I,EAAMY,KAAoBZ,EAAMY,GAAOoB,EAAGpB,IACvCZ,EAAMY,EACf,CACF,8CCgDA,QAnDA,SAAiBsB,GAYf,IANA,IAEI3E,EAFA4E,EAAI,EAGJ9J,EAAI,EACJ+J,EAAMF,EAAIzL,OAEP2L,GAAO,IAAK/J,EAAG+J,GAAO,EAE3B7E,EAEe,YAAV,OAHLA,EAAwB,IAApB2E,EAAIpI,WAAWzB,IAAmC,IAAtB6J,EAAIpI,aAAazB,KAAc,GAA2B,IAAtB6J,EAAIpI,aAAazB,KAAc,IAA4B,IAAtB6J,EAAIpI,aAAazB,KAAc,MAG9F,OAAZkF,IAAM,KAAgB,IAIpD4E,EAEe,YAAV,OALL5E,GAEAA,IAAM,MAGoC,OAAZA,IAAM,KAAgB,IAErC,YAAV,MAAJ4E,IAAyC,OAAZA,IAAM,KAAgB,IAItD,OAAQC,GACN,KAAK,EACHD,IAA8B,IAAxBD,EAAIpI,WAAWzB,EAAI,KAAc,GAEzC,KAAK,EACH8J,IAA8B,IAAxBD,EAAIpI,WAAWzB,EAAI,KAAc,EAEzC,KAAK,EAEH8J,EAEe,YAAV,OAHLA,GAAyB,IAApBD,EAAIpI,WAAWzB,MAGsB,OAAZ8J,IAAM,KAAgB,IASxD,SAHAA,EAEe,YAAV,OAHLA,GAAKA,IAAM,MAG+B,OAAZA,IAAM,KAAgB,KACvCA,IAAM,MAAQ,GAAGE,SAAS,GACzC,ECHA,EAjDmB,CACjBC,wBAAyB,EACzBC,kBAAmB,EACnBC,iBAAkB,EAClBC,iBAAkB,EAClBC,QAAS,EACTC,aAAc,EACdC,gBAAiB,EACjBC,YAAa,EACbC,QAAS,EACTC,KAAM,EACNC,SAAU,EACVC,aAAc,EACdC,WAAY,EACZC,aAAc,EACdC,UAAW,EACXC,QAAS,EACTC,WAAY,EACZC,YAAa,EACbC,aAAc,EACdC,WAAY,EACZC,cAAe,EACfC,eAAgB,EAChBC,gBAAiB,EACjBC,UAAW,EACXC,cAAe,EACfC,aAAc,EACdC,iBAAkB,EAClBC,WAAY,EACZC,WAAY,EACZC,QAAS,EACTC,MAAO,EACPC,QAAS,EACTC,QAAS,EACTC,OAAQ,EACRC,OAAQ,EACRC,KAAM,EACNC,gBAAiB,EAEjBC,YAAa,EACbC,aAAc,EACdC,YAAa,EACbC,gBAAiB,EACjBC,iBAAkB,EAClBC,iBAAkB,EAClBC,cAAe,EACfC,YAAa,gBCxCXC,EAAiB,aACjBC,EAAiB,8BAEjBC,EAAmB,SAA0B1I,GAC/C,OAAkC,KAA3BA,EAAS7C,WAAW,EAC7B,EAEIwL,EAAqB,SAA4BhM,GACnD,OAAgB,MAATA,GAAkC,kBAAVA,CACjC,EAEIiM,GAAkC,QAAQ,SAAUC,GACtD,OAAOH,EAAiBG,GAAaA,EAAYA,EAAU/L,QAAQ0L,EAAgB,OAAOM,aAC5F,IAEIC,EAAoB,SAA2BpO,EAAKgC,GACtD,OAAQhC,GACN,IAAK,YACL,IAAK,gBAED,GAAqB,iBAAVgC,EACT,OAAOA,EAAMG,QAAQ2L,GAAgB,SAAUO,EAAOC,EAAIC,GAMxD,OALAC,EAAS,CACP7F,KAAM2F,EACN7F,OAAQ8F,EACR9K,KAAM+K,GAEDF,CACT,IAKR,OAAsB,IAAlB,EAAStO,IAAe+N,EAAiB/N,IAAyB,iBAAVgC,GAAgC,IAAVA,EAI3EA,EAHEA,EAAQ,IAInB,EAgCA,SAASyM,EAAoBC,EAAa9F,EAAY+F,GACpD,GAAqB,MAAjBA,EACF,MAAO,GAGT,QAAuC/O,IAAnC+O,EAAcC,iBAKhB,OAAOD,EAGT,cAAeA,GACb,IAAK,UAED,MAAO,GAGX,IAAK,SAED,GAA2B,IAAvBA,EAAcE,KAMhB,OALAL,EAAS,CACP7F,KAAMgG,EAAchG,KACpBF,OAAQkG,EAAclG,OACtBhF,KAAM+K,GAEDG,EAAchG,KAGvB,QAA6B/I,IAAzB+O,EAAclG,OAAsB,CACtC,IAAIhF,EAAOkL,EAAclL,KAEzB,QAAa7D,IAAT6D,EAGF,UAAgB7D,IAAT6D,GACL+K,EAAS,CACP7F,KAAMlF,EAAKkF,KACXF,OAAQhF,EAAKgF,OACbhF,KAAM+K,GAER/K,EAAOA,EAAKA,KAUhB,OANakL,EAAclG,OAAS,GAOtC,CAEA,OA2CR,SAAgCiG,EAAa9F,EAAYkG,GACvD,IAAIC,EAAS,GAEb,GAAIxH,MAAMiC,QAAQsF,GAChB,IAAK,IAAI/N,EAAI,EAAGA,EAAI+N,EAAI3P,OAAQ4B,IAC9BgO,GAAUN,EAAoBC,EAAa9F,EAAYkG,EAAI/N,IAAM,SAGnE,IAAK,IAAI6I,KAAQkF,EAAK,CACpB,IAAI9M,EAAQ8M,EAAIlF,GAEhB,GAAqB,iBAAV5H,EACS,MAAd4G,QAA4ChJ,IAAtBgJ,EAAW5G,GACnC+M,GAAUnF,EAAO,IAAMhB,EAAW5G,GAAS,IAClCgM,EAAmBhM,KAC5B+M,GAAUd,EAAiBrE,GAAQ,IAAMwE,EAAkBxE,EAAM5H,GAAS,UAO5E,IAAIuF,MAAMiC,QAAQxH,IAA8B,iBAAbA,EAAM,IAAkC,MAAd4G,QAA+ChJ,IAAzBgJ,EAAW5G,EAAM,IAM7F,CACL,IAAIgN,EAAeP,EAAoBC,EAAa9F,EAAY5G,GAEhE,OAAQ4H,GACN,IAAK,YACL,IAAK,gBAEDmF,GAAUd,EAAiBrE,GAAQ,IAAMoF,EAAe,IACxD,MAGJ,QAMID,GAAUnF,EAAO,IAAMoF,EAAe,IAG9C,MAzBE,IAAK,IAAIC,EAAK,EAAGA,EAAKjN,EAAM7C,OAAQ8P,IAC9BjB,EAAmBhM,EAAMiN,MAC3BF,GAAUd,EAAiBrE,GAAQ,IAAMwE,EAAkBxE,EAAM5H,EAAMiN,IAAO,IAyBxF,CAGF,OAAOF,CACT,CAjGeG,CAAuBR,EAAa9F,EAAY+F,GAG3D,IAAK,WAED,QAAoB/O,IAAhB8O,EAA2B,CAC7B,IAAIS,EAAiBX,EACjBY,EAAST,EAAcD,GAE3B,OADAF,EAASW,EACFV,EAAoBC,EAAa9F,EAAYwG,EACtD,EAyBN,GAAkB,MAAdxG,EACF,OAAO+F,EAGT,IAAIU,EAASzG,EAAW+F,GACxB,YAAkB/O,IAAXyP,EAAuBA,EAASV,CACzC,CA0DA,IASIH,EATAc,EAAe,iCAUfC,EAAkB,SAAyBnG,EAAMR,EAAY8F,GAC/D,GAAoB,IAAhBtF,EAAKjK,QAAmC,iBAAZiK,EAAK,IAA+B,OAAZA,EAAK,SAAkCxJ,IAAnBwJ,EAAK,GAAGX,OAClF,OAAOW,EAAK,GAGd,IAAIoG,GAAa,EACb/G,EAAS,GACb+F,OAAS5O,EACT,IAAI6P,EAAUrG,EAAK,GAEJ,MAAXqG,QAAmC7P,IAAhB6P,EAAQC,KAC7BF,GAAa,EACb/G,GAAUgG,EAAoBC,EAAa9F,EAAY6G,IAMvDhH,GAAUgH,EAAQ,GAIpB,IAAK,IAAI1O,EAAI,EAAGA,EAAIqI,EAAKjK,OAAQ4B,IAC/B0H,GAAUgG,EAAoBC,EAAa9F,EAAYQ,EAAKrI,IAExDyO,IAKF/G,GAAUgH,EAAQ1O,IActBuO,EAAaK,UAAY,EAIzB,IAHA,IACItB,EADAuB,EAAiB,GAG0B,QAAvCvB,EAAQiB,EAAalI,KAAKqB,KAChCmH,GAAkB,IAClBvB,EAAM,GAkBR,MAAO,CACL1F,KAhBS,EAAWF,GAAUmH,EAiB9BnH,OAAQA,EACRhF,KAAM+K,EAEV,oFCzTe,SAAS,IAYtB,OAXA,EAAW3M,OAAOC,OAASD,OAAOC,OAAO2I,OAAS,SAAUoF,GAC1D,IAAK,IAAI9O,EAAI,EAAGA,EAAI4I,UAAUxK,OAAQ4B,IAAK,CACzC,IAAI+O,EAASnG,UAAU5I,GACvB,IAAK,IAAIf,KAAO8P,EACVjO,OAAO3B,UAAU6P,eAAevI,KAAKsI,EAAQ9P,KAC/C6P,EAAO7P,GAAO8P,EAAO9P,GAG3B,CACA,OAAO6P,CACT,EACO,EAASG,MAAMvR,KAAMkL,UAC9B,cCXIsG,EAAkB,o9HAYtB,SAViC,QAAQ,SAAUC,GACjD,OAAOD,EAAgBE,KAAKD,IAAgC,MAAvBA,EAAK1N,WAAW,IAE3B,MAAvB0N,EAAK1N,WAAW,IAEhB0N,EAAK1N,WAAW,GAAK,EAC1B,yBCHI4N,IAAqB,EAA+B,oBAAI,EAA+B,mBACvF,EAA4CA,GAL7B,SAAsBzF,GACvC,OAAOA,GACT,ECMI0F,GDFuCD,GAAsB,EAAAE,iBCExB,IAAAC,eAMlB,oBAAhBC,aAA6C,OAAY,CAC9DxQ,IAAK,QACF,OAMeqQ,EAAoBI,SAAxC,IAKIC,EAAmB,SAA0BC,GAE/C,OAAoB,IAAAC,aAAW,SAAUvN,EAAOwN,GAE9C,IAAInI,GAAQ,IAAAoI,YAAWT,GACvB,OAAOM,EAAKtN,EAAOqF,EAAOmI,EAC5B,GACF,EAEIE,GAA8B,IAAAR,eAAc,CAAC,YC/B7CS,EAA2B,EAE3BC,EAA2B,SAAkCjR,GAC/D,MAAe,UAARA,CACT,EAEIkR,EAA8B,SAAqClS,GACrE,MAAsB,iBAARA,GAGdA,EAAIwD,WAAW,GAAK,GAAKwO,EAA2BC,CACtD,EACIE,EAA4B,SAAmCnS,EAAKH,EAASuS,GAC/E,IAAIC,EAEJ,GAAIxS,EAAS,CACX,IAAIyS,EAA2BzS,EAAQwS,kBACvCA,EAAoBrS,EAAIuS,uBAAyBD,EAA2B,SAAUE,GACpF,OAAOxS,EAAIuS,sBAAsBC,IAAaF,EAAyBE,EACzE,EAAIF,CACN,CAMA,MAJiC,mBAAtBD,GAAoCD,IAC7CC,EAAoBrS,EAAIuS,uBAGnBF,CACT,EAII,EAAY,SAAmBI,GACjC,IAAI/I,EAAQ+I,EAAK/I,MACbH,EAAakJ,EAAKlJ,WAClBmJ,EAAcD,EAAKC,YAMvB,OALA,QAAehJ,EAAOH,EAAYmJ,GACtB,GAAyC,WACnD,OAAO,QAAahJ,EAAOH,EAAYmJ,EACzC,IAEO,IACT,ECxCA,IAGIC,EDuCe,SAASC,EAAa5S,EAAKH,GAO5C,IAEI+Q,EACAiC,EAHAT,EAASpS,EAAI8S,iBAAmB9S,EAChC+S,EAAUX,GAAUpS,EAAIgT,gBAAkBhT,OAI9BY,IAAZf,IACF+Q,EAAiB/Q,EAAQoT,MACzBJ,EAAkBhT,EAAQgR,QAG5B,IAAIwB,EAAoBF,EAA0BnS,EAAKH,EAASuS,GAC5Dc,EAA2Bb,GAAqBH,EAA4Ba,GAC5EI,GAAeD,EAAyB,MAC5C,OAAO,WACL,IAAI9I,EAAOO,UACPlB,EAAS2I,QAAmCxR,IAAzBZ,EAAI4P,iBAAiC5P,EAAI4P,iBAAiBjM,MAAM,GAAK,GAM5F,QAJuB/C,IAAnBgQ,GACFnH,EAAO/I,KAAK,SAAWkQ,EAAiB,KAG3B,MAAXxG,EAAK,SAA8BxJ,IAAhBwJ,EAAK,GAAGsG,IAC7BjH,EAAO/I,KAAKsQ,MAAMvH,EAAQW,OACrB,CAKLX,EAAO/I,KAAK0J,EAAK,GAAG,IAIpB,IAHA,IAAI0B,EAAM1B,EAAKjK,OACX4B,EAAI,EAEDA,EAAI+J,EAAK/J,IAKd0H,EAAO/I,KAAK0J,EAAKrI,GAAIqI,EAAK,GAAGrI,GAEjC,CAGA,IAAIqR,EAAS1B,GAAiB,SAAUrN,EAAOqF,EAAOmI,GACpD,IAAIwB,EAAWF,GAAe9O,EAAMiP,IAAMP,EACtC/I,EAAY,GACZuJ,EAAsB,GACtB7D,EAAcrL,EAElB,GAAmB,MAAfA,EAAMmP,MAAe,CAGvB,IAAK,IAAIxS,KAFT0O,EAAc,CAAC,EAECrL,EACdqL,EAAY1O,GAAOqD,EAAMrD,GAG3B0O,EAAY8D,OAAQ,IAAA1B,YAAWC,EACjC,CAE+B,iBAApB1N,EAAM2F,UACfA,GAAY,QAAoBN,EAAME,WAAY2J,EAAqBlP,EAAM2F,WACjD,MAAnB3F,EAAM2F,YACfA,EAAY3F,EAAM2F,UAAY,KAGhC,IAAIT,GAAa,OAAgBE,EAAOJ,OAAOkK,GAAsB7J,EAAME,WAAY8F,GACvF1F,GAAaN,EAAM1I,IAAM,IAAMuI,EAAWI,UAElB/I,IAApBiS,IACF7I,GAAa,IAAM6I,GAGrB,IAAIY,EAAyBN,QAAqCvS,IAAtByR,EAAkCH,EAA4BmB,GAAYH,EAClHQ,EAAW,CAAC,EAEhB,IAAK,IAAI9I,KAAQvG,EACX8O,GAAwB,OAATvI,GAGnB6I,EAAuB7I,KACrB8I,EAAS9I,GAAQvG,EAAMuG,IAM3B,OAFA8I,EAAS1J,UAAYA,EACrB0J,EAAS7B,IAAMA,GACK,IAAApQ,eAAc,EAAAkS,SAAU,MAAmB,IAAAlS,eAAc,EAAW,CACtFiI,MAAOA,EACPH,WAAYA,EACZmJ,YAAiC,iBAAbW,KACL,IAAA5R,eAAc4R,EAAUK,GAC3C,IAwBA,OAvBAN,EAAOQ,iBAAiChT,IAAnBgQ,EAA+BA,EAAiB,WAAgC,iBAAZmC,EAAuBA,EAAUA,EAAQa,aAAeb,EAAQpJ,MAAQ,aAAe,IAChLyJ,EAAOS,aAAe7T,EAAI6T,aAC1BT,EAAON,eAAiBM,EACxBA,EAAOJ,eAAiBD,EACxBK,EAAOxD,iBAAmBnG,EAC1B2J,EAAOb,sBAAwBF,EAC/BxP,OAAOiR,eAAeV,EAAQ,WAAY,CACxCpQ,MAAO,WAML,MAAO,IAAM6P,CACf,IAGFO,EAAOW,cAAgB,SAAUC,EAASC,GACxC,OAAOrB,EAAaoB,EAAS,EAAS,CAAC,EAAGnU,EAASoU,EAAa,CAC9D5B,kBAAmBF,EAA0BiB,EAAQa,GAAa,MAChEjD,WAAM,EAAQvH,EACpB,EAEO2J,CACT,CACF,EClKgB,OAHL,CAAC,IAAK,OAAQ,UAAW,OAAQ,UAAW,QAAS,QAAS,IAAK,OAAQ,MAAO,MAAO,MAAO,aAAc,OAAQ,KAAM,SAAU,SAAU,UAAW,OAAQ,OAAQ,MAAO,WAAY,OAAQ,WAAY,KAAM,MAAO,UAAW,MAAO,SAAU,MAAO,KAAM,KAAM,KAAM,QAAS,WAAY,aAAc,SAAU,SAAU,OAAQ,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,OAAQ,SAAU,SAAU,KAAM,OAAQ,IAAK,SAAU,MAAO,QAAS,MAAO,MAAO,SAAU,QAAS,SAAU,KAAM,OAAQ,OAAQ,MAAO,OAAQ,UAAW,OAAQ,WAAY,OAAQ,QAAS,MAAO,WAAY,SAAU,KAAM,WAAY,SAAU,SAAU,IAAK,QAAS,UAAW,MAAO,WAAY,IAAK,KAAM,KAAM,OAAQ,IAAK,OAAQ,SAAU,UAAW,SAAU,QAAS,SAAU,OAAQ,SAAU,QAAS,MAAO,UAAW,MAAO,QAAS,QAAS,KAAM,WAAY,QAAS,KAAM,QAAS,OAAQ,QAAS,KAAM,QAAS,IAAK,KAAM,MAAO,QAAS,MAC77B,SAAU,WAAY,OAAQ,UAAW,gBAAiB,IAAK,QAAS,OAAQ,iBAAkB,OAAQ,OAAQ,UAAW,UAAW,WAAY,iBAAkB,OAAQ,OAAQ,MAAO,OAAQ,SAGhM/R,SAAQ,SAAU6S,GAErBvB,EAAUuB,GAAWvB,EAAUuB,EACjC,IAEA,sCCjBA,SAAS1I,EAAoB5B,EAAYK,EAAkBkK,GACzD,IAAIjK,EAAe,GAQnB,OAPAiK,EAAWnL,MAAM,KAAK3H,SAAQ,SAAU2I,QACRpJ,IAA1BgJ,EAAWI,GACbC,EAAiBvJ,KAAKkJ,EAAWI,GAAa,KAE9CE,GAAgBF,EAAY,GAEhC,IACOE,CACT,qCACA,IAAIkK,EAAiB,SAAwB1K,EAAOH,EAAYmJ,GAC9D,IAAI1I,EAAYN,EAAM1I,IAAM,IAAMuI,EAAWI,MAO5B,IAAhB+I,QAIwD9R,IAAhC8I,EAAME,WAAWI,KACxCN,EAAME,WAAWI,GAAaT,EAAWE,OAE7C,EACI4K,EAAe,SAAsB3K,EAAOH,EAAYmJ,GAC1D0B,EAAe1K,EAAOH,EAAYmJ,GAClC,IAAI1I,EAAYN,EAAM1I,IAAM,IAAMuI,EAAWI,KAE7C,QAAwC/I,IAApC8I,EAAMb,SAASU,EAAWI,MAAqB,CACjD,IAAI2K,EAAU/K,EAEd,GACoBG,EAAMpI,OAAOiI,IAAe+K,EAAU,IAAMtK,EAAY,GAAIsK,EAAS5K,EAAM5H,OAAO,GAEpGwS,EAAUA,EAAQ7P,gBACC7D,IAAZ0T,EACX,CACF,4BChCa,IAAIC,EAAEC,OAAOC,IAAI,iBAAiBC,EAAEF,OAAOC,IAAI,gBAAgBE,EAAEH,OAAOC,IAAI,kBAAkBG,EAAEJ,OAAOC,IAAI,qBAAqBI,EAAEL,OAAOC,IAAI,kBAAkBK,EAAEN,OAAOC,IAAI,kBAAkBM,EAAEP,OAAOC,IAAI,iBAAiBO,EAAER,OAAOC,IAAI,qBAAqBQ,EAAET,OAAOC,IAAI,kBAAkBvN,EAAEsN,OAAOC,IAAI,cAActN,EAAEqN,OAAOC,IAAI,cAAcrN,EAAEoN,OAAOU,SACrWC,EAAE,CAACC,UAAU,WAAW,OAAM,CAAE,EAAEC,mBAAmB,WAAW,EAAEC,oBAAoB,WAAW,EAAEC,gBAAgB,WAAW,GAAGC,EAAE3S,OAAOC,OAAO2S,EAAE,CAAC,EAAE,SAASC,EAAEC,EAAEC,EAAEvT,GAAG5C,KAAK4E,MAAMsR,EAAElW,KAAKoW,QAAQD,EAAEnW,KAAKqW,KAAKL,EAAEhW,KAAKsW,QAAQ1T,GAAG8S,CAAC,CACwI,SAASa,IAAI,CAAyB,SAASC,EAAEN,EAAEC,EAAEvT,GAAG5C,KAAK4E,MAAMsR,EAAElW,KAAKoW,QAAQD,EAAEnW,KAAKqW,KAAKL,EAAEhW,KAAKsW,QAAQ1T,GAAG8S,CAAC,CADxPO,EAAExU,UAAUgV,iBAAiB,CAAC,EACpQR,EAAExU,UAAUiV,SAAS,SAASR,EAAEC,GAAG,GAAG,iBAAkBD,GAAG,mBAAoBA,GAAG,MAAMA,EAAE,MAAMS,MAAM,yHAAyH3W,KAAKsW,QAAQR,gBAAgB9V,KAAKkW,EAAEC,EAAE,WAAW,EAAEF,EAAExU,UAAUmV,YAAY,SAASV,GAAGlW,KAAKsW,QAAQV,mBAAmB5V,KAAKkW,EAAE,cAAc,EAAgBK,EAAE9U,UAAUwU,EAAExU,UAAsF,IAAIoV,EAAEL,EAAE/U,UAAU,IAAI8U,EACrfM,EAAEC,YAAYN,EAAET,EAAEc,EAAEZ,EAAExU,WAAWoV,EAAEE,sBAAqB,EAAG,IAAIC,EAAElO,MAAMiC,QAAQkM,EAAE7T,OAAO3B,UAAU6P,eAAe4F,EAAE,CAACrC,QAAQ,MAAMsC,EAAE,CAAC5V,KAAI,EAAG6Q,KAAI,EAAGgF,QAAO,EAAGC,UAAS,GACtK,SAASC,EAAEpB,EAAEC,EAAEvT,GAAG,IAAI2U,EAAEC,EAAE,CAAC,EAAEhQ,EAAE,KAAK4E,EAAE,KAAK,GAAG,MAAM+J,EAAE,IAAIoB,UAAK,IAASpB,EAAE/D,MAAMhG,EAAE+J,EAAE/D,UAAK,IAAS+D,EAAE5U,MAAMiG,EAAE,GAAG2O,EAAE5U,KAAK4U,EAAEc,EAAElO,KAAKoN,EAAEoB,KAAKJ,EAAE7F,eAAeiG,KAAKC,EAAED,GAAGpB,EAAEoB,IAAI,IAAIE,EAAEvM,UAAUxK,OAAO,EAAE,GAAG,IAAI+W,EAAED,EAAE3S,SAASjC,OAAO,GAAG,EAAE6U,EAAE,CAAC,IAAI,IAAIC,EAAE5O,MAAM2O,GAAGE,EAAE,EAAEA,EAAEF,EAAEE,IAAID,EAAEC,GAAGzM,UAAUyM,EAAE,GAAGH,EAAE3S,SAAS6S,CAAC,CAAC,GAAGxB,GAAGA,EAAE9B,aAAa,IAAImD,KAAKE,EAAEvB,EAAE9B,kBAAe,IAASoD,EAAED,KAAKC,EAAED,GAAGE,EAAEF,IAAI,MAAM,CAACK,SAAS9C,EAAEnQ,KAAKuR,EAAE3U,IAAIiG,EAAE4K,IAAIhG,EAAExH,MAAM4S,EAAEK,OAAOX,EAAErC,QAAQ,CAChV,SAASiD,EAAE5B,GAAG,MAAM,iBAAkBA,GAAG,OAAOA,GAAGA,EAAE0B,WAAW9C,CAAC,CAAoG,IAAIiD,EAAE,OAAO,SAASC,EAAE9B,EAAEC,GAAG,MAAM,iBAAkBD,GAAG,OAAOA,GAAG,MAAMA,EAAE3U,IAA7K,SAAgB2U,GAAG,IAAIC,EAAE,CAAC,IAAI,KAAK,IAAI,MAAM,MAAM,IAAID,EAAExS,QAAQ,SAAQ,SAASwS,GAAG,OAAOC,EAAED,EAAE,GAAE,CAA+E+B,CAAO,GAAG/B,EAAE3U,KAAK4U,EAAE7J,SAAS,GAAG,CAC/W,SAAS4L,EAAEhC,EAAEC,EAAEvT,EAAE2U,EAAEC,GAAG,IAAIhQ,SAAS0O,EAAK,cAAc1O,GAAG,YAAYA,IAAE0O,EAAE,MAAK,IAAI9J,GAAE,EAAG,GAAG,OAAO8J,EAAE9J,GAAE,OAAQ,OAAO5E,GAAG,IAAK,SAAS,IAAK,SAAS4E,GAAE,EAAG,MAAM,IAAK,SAAS,OAAO8J,EAAE0B,UAAU,KAAK9C,EAAE,KAAKG,EAAE7I,GAAE,GAAI,GAAGA,EAAE,OAAWoL,EAAEA,EAANpL,EAAE8J,GAASA,EAAE,KAAKqB,EAAE,IAAIS,EAAE5L,EAAE,GAAGmL,EAAEP,EAAEQ,IAAI5U,EAAE,GAAG,MAAMsT,IAAItT,EAAEsT,EAAExS,QAAQqU,EAAE,OAAO,KAAKG,EAAEV,EAAErB,EAAEvT,EAAE,IAAG,SAASsT,GAAG,OAAOA,CAAC,KAAI,MAAMsB,IAAIM,EAAEN,KAAKA,EADnW,SAAWtB,EAAEC,GAAG,MAAM,CAACyB,SAAS9C,EAAEnQ,KAAKuR,EAAEvR,KAAKpD,IAAI4U,EAAE/D,IAAI8D,EAAE9D,IAAIxN,MAAMsR,EAAEtR,MAAMiT,OAAO3B,EAAE2B,OAAO,CACyQM,CAAEX,EAAE5U,IAAI4U,EAAEjW,KAAK6K,GAAGA,EAAE7K,MAAMiW,EAAEjW,IAAI,IAAI,GAAGiW,EAAEjW,KAAKmC,QAAQqU,EAAE,OAAO,KAAK7B,IAAIC,EAAElV,KAAKuW,IAAI,EAAyB,GAAvBpL,EAAE,EAAEmL,EAAE,KAAKA,EAAE,IAAIA,EAAE,IAAOP,EAAEd,GAAG,IAAI,IAAIuB,EAAE,EAAEA,EAAEvB,EAAExV,OAAO+W,IAAI,CAC/e,IAAIC,EAAEH,EAAES,EADwexQ,EACrf0O,EAAEuB,GAAeA,GAAGrL,GAAG8L,EAAE1Q,EAAE2O,EAAEvT,EAAE8U,EAAEF,EAAE,MAAM,GAAGE,EAPsU,SAAWxB,GAAG,OAAG,OAAOA,GAAG,iBAAkBA,EAAS,KAAsC,mBAAjCA,EAAEvO,GAAGuO,EAAEvO,IAAIuO,EAAE,eAA0CA,EAAE,IAAI,CAO5bkC,CAAElC,GAAG,mBAAoBwB,EAAE,IAAIxB,EAAEwB,EAAE3O,KAAKmN,GAAGuB,EAAE,IAAIjQ,EAAE0O,EAAElR,QAAQqT,MAA6BjM,GAAG8L,EAA1B1Q,EAAEA,EAAEjE,MAA0B4S,EAAEvT,EAAtB8U,EAAEH,EAAES,EAAExQ,EAAEiQ,KAAkBD,QAAQ,GAAG,WAAWhQ,EAAE,MAAM2O,EAAEjT,OAAOgT,GAAGS,MAAM,mDAAmD,oBAAoBR,EAAE,qBAAqB/S,OAAOkV,KAAKpC,GAAGhQ,KAAK,MAAM,IAAIiQ,GAAG,6EAA6E,OAAO/J,CAAC,CACzZ,SAASmM,EAAErC,EAAEC,EAAEvT,GAAG,GAAG,MAAMsT,EAAE,OAAOA,EAAE,IAAIqB,EAAE,GAAGC,EAAE,EAAmD,OAAjDU,EAAEhC,EAAEqB,EAAE,GAAG,IAAG,SAASrB,GAAG,OAAOC,EAAEpN,KAAKnG,EAAEsT,EAAEsB,IAAI,IAAUD,CAAC,CAAC,SAASiB,EAAEtC,GAAG,IAAI,IAAIA,EAAEuC,QAAQ,CAAC,IAAItC,EAAED,EAAEwC,SAAQvC,EAAEA,KAAMwC,MAAK,SAASxC,GAAM,IAAID,EAAEuC,UAAU,IAAIvC,EAAEuC,UAAQvC,EAAEuC,QAAQ,EAAEvC,EAAEwC,QAAQvC,EAAC,IAAE,SAASA,GAAM,IAAID,EAAEuC,UAAU,IAAIvC,EAAEuC,UAAQvC,EAAEuC,QAAQ,EAAEvC,EAAEwC,QAAQvC,EAAC,KAAI,IAAID,EAAEuC,UAAUvC,EAAEuC,QAAQ,EAAEvC,EAAEwC,QAAQvC,EAAE,CAAC,GAAG,IAAID,EAAEuC,QAAQ,OAAOvC,EAAEwC,QAAQE,QAAQ,MAAM1C,EAAEwC,OAAQ,CAC5Z,IAAIG,EAAE,CAAChE,QAAQ,MAAMiE,EAAE,CAACC,WAAW,MAAMC,EAAE,CAACC,uBAAuBJ,EAAEK,wBAAwBJ,EAAEK,kBAAkBjC,GAAGtX,EAAQwZ,SAAS,CAAC1Q,IAAI6P,EAAE3W,QAAQ,SAASsU,EAAEC,EAAEvT,GAAG2V,EAAErC,GAAE,WAAWC,EAAE5E,MAAMvR,KAAKkL,UAAU,GAAEtI,EAAE,EAAE8C,MAAM,SAASwQ,GAAG,IAAIC,EAAE,EAAuB,OAArBoC,EAAErC,GAAE,WAAWC,GAAG,IAAUA,CAAC,EAAEkD,QAAQ,SAASnD,GAAG,OAAOqC,EAAErC,GAAE,SAASA,GAAG,OAAOA,CAAC,KAAI,EAAE,EAAEoD,KAAK,SAASpD,GAAG,IAAI4B,EAAE5B,GAAG,MAAMS,MAAM,yEAAyE,OAAOT,CAAC,GAAGtW,EAAQ2Z,UAAUtD,EAAErW,EAAQsU,SAASgB,EACnetV,EAAQ4Z,SAASpE,EAAExV,EAAQ6Z,cAAcjD,EAAE5W,EAAQ8Z,WAAWvE,EAAEvV,EAAQ+Z,SAASnE,EAAE5V,EAAQga,mDAAmDZ,EAC9IpZ,EAAQia,aAAa,SAAS3D,EAAEC,EAAEvT,GAAG,GAAG,MAAOsT,EAAc,MAAMS,MAAM,iFAAiFT,EAAE,KAAK,IAAIqB,EAAExB,EAAE,CAAC,EAAEG,EAAEtR,OAAO4S,EAAEtB,EAAE3U,IAAIiG,EAAE0O,EAAE9D,IAAIhG,EAAE8J,EAAE2B,OAAO,GAAG,MAAM1B,EAAE,CAAoE,QAAnE,IAASA,EAAE/D,MAAM5K,EAAE2O,EAAE/D,IAAIhG,EAAE8K,EAAErC,cAAS,IAASsB,EAAE5U,MAAMiW,EAAE,GAAGrB,EAAE5U,KAAQ2U,EAAEvR,MAAMuR,EAAEvR,KAAKyP,aAAa,IAAIqD,EAAEvB,EAAEvR,KAAKyP,aAAa,IAAIsD,KAAKvB,EAAEc,EAAElO,KAAKoN,EAAEuB,KAAKP,EAAE7F,eAAeoG,KAAKH,EAAEG,QAAG,IAASvB,EAAEuB,SAAI,IAASD,EAAEA,EAAEC,GAAGvB,EAAEuB,GAAG,CAAC,IAAIA,EAAExM,UAAUxK,OAAO,EAAE,GAAG,IAAIgX,EAAEH,EAAE1S,SAASjC,OAAO,GAAG,EAAE8U,EAAE,CAACD,EAAE3O,MAAM4O,GACrf,IAAI,IAAIC,EAAE,EAAEA,EAAED,EAAEC,IAAIF,EAAEE,GAAGzM,UAAUyM,EAAE,GAAGJ,EAAE1S,SAAS4S,CAAC,CAAC,MAAM,CAACG,SAAS9C,EAAEnQ,KAAKuR,EAAEvR,KAAKpD,IAAIiW,EAAEpF,IAAI5K,EAAE5C,MAAM2S,EAAEM,OAAOzL,EAAE,EAAExM,EAAQkS,cAAc,SAASoE,GAAqK,OAAlKA,EAAE,CAAC0B,SAAStC,EAAEwE,cAAc5D,EAAE6D,eAAe7D,EAAE8D,aAAa,EAAEhI,SAAS,KAAKiI,SAAS,KAAKC,cAAc,KAAKC,YAAY,OAAQnI,SAAS,CAAC4F,SAASvC,EAAE+E,SAASlE,GAAUA,EAAE+D,SAAS/D,CAAC,EAAEtW,EAAQoC,cAAcsV,EAAE1X,EAAQya,cAAc,SAASnE,GAAG,IAAIC,EAAEmB,EAAEtL,KAAK,KAAKkK,GAAY,OAATC,EAAExR,KAAKuR,EAASC,CAAC,EAAEvW,EAAQ0a,UAAU,WAAW,MAAM,CAACzF,QAAQ,KAAK,EAC9djV,EAAQuS,WAAW,SAAS+D,GAAG,MAAM,CAAC0B,SAASrC,EAAEgF,OAAOrE,EAAE,EAAEtW,EAAQ4a,eAAe1C,EAAElY,EAAQ6a,KAAK,SAASvE,GAAG,MAAM,CAAC0B,SAASlQ,EAAEgT,SAAS,CAACjC,SAAS,EAAEC,QAAQxC,GAAGyE,MAAMnC,EAAE,EAAE5Y,EAAQgb,KAAK,SAAS1E,EAAEC,GAAG,MAAM,CAACyB,SAASnQ,EAAE9C,KAAKuR,EAAE2E,aAAQ,IAAS1E,EAAE,KAAKA,EAAE,EAAEvW,EAAQkb,gBAAgB,SAAS5E,GAAG,IAAIC,EAAE2C,EAAEC,WAAWD,EAAEC,WAAW,CAAC,EAAE,IAAI7C,GAA0B,CAAtB,QAAQ4C,EAAEC,WAAW5C,CAAC,CAAC,EAAEvW,EAAQmb,aAAa,WAAW,MAAMpE,MAAM,2DAA4D,EAC1c/W,EAAQob,YAAY,SAAS9E,EAAEC,GAAG,OAAO0C,EAAEhE,QAAQmG,YAAY9E,EAAEC,EAAE,EAAEvW,EAAQyS,WAAW,SAAS6D,GAAG,OAAO2C,EAAEhE,QAAQxC,WAAW6D,EAAE,EAAEtW,EAAQqb,cAAc,WAAW,EAAErb,EAAQsb,iBAAiB,SAAShF,GAAG,OAAO2C,EAAEhE,QAAQqG,iBAAiBhF,EAAE,EAAEtW,EAAQub,UAAU,SAASjF,EAAEC,GAAG,OAAO0C,EAAEhE,QAAQsG,UAAUjF,EAAEC,EAAE,EAAEvW,EAAQwb,MAAM,WAAW,OAAOvC,EAAEhE,QAAQuG,OAAO,EAAExb,EAAQyb,oBAAoB,SAASnF,EAAEC,EAAEvT,GAAG,OAAOiW,EAAEhE,QAAQwG,oBAAoBnF,EAAEC,EAAEvT,EAAE,EAC7bhD,EAAQ+R,mBAAmB,SAASuE,EAAEC,GAAG,OAAO0C,EAAEhE,QAAQlD,mBAAmBuE,EAAEC,EAAE,EAAEvW,EAAQiS,gBAAgB,SAASqE,EAAEC,GAAG,OAAO0C,EAAEhE,QAAQhD,gBAAgBqE,EAAEC,EAAE,EAAEvW,EAAQ0b,QAAQ,SAASpF,EAAEC,GAAG,OAAO0C,EAAEhE,QAAQyG,QAAQpF,EAAEC,EAAE,EAAEvW,EAAQ2b,WAAW,SAASrF,EAAEC,EAAEvT,GAAG,OAAOiW,EAAEhE,QAAQ0G,WAAWrF,EAAEC,EAAEvT,EAAE,EAAEhD,EAAQ4b,OAAO,SAAStF,GAAG,OAAO2C,EAAEhE,QAAQ2G,OAAOtF,EAAE,EAAEtW,EAAQ6b,SAAS,SAASvF,GAAG,OAAO2C,EAAEhE,QAAQ4G,SAASvF,EAAE,EAAEtW,EAAQ8b,qBAAqB,SAASxF,EAAEC,EAAEvT,GAAG,OAAOiW,EAAEhE,QAAQ6G,qBAAqBxF,EAAEC,EAAEvT,EAAE,EAC/ehD,EAAQ+b,cAAc,WAAW,OAAO9C,EAAEhE,QAAQ8G,eAAe,EAAE/b,EAAQgc,QAAQ,qCCtBjF/b,EAAOD,QAAU,EAAjB,gWCsFa,uBAAsB,gBAAe,ICpEnC,cAGT,OAFIic,EAAQ,aACRA,EAAQ9Z,SAAS+Z,KACrB,EACY,cACqB,IAAG,EACb,EAEuB,EAH1CD,EAAQ,sBAAqB,iBAAG,EAAHE,EAAGC,MAAH,QAC7B,MAAU,SAAS,EAATja,SAASka,eAAe,WAAxB,sBAKd,OAHIC,EAAIC,UAAeD,EAAIC,UAAP,QAAuB,iBAAG,EAAHJ,EAAGC,MAAH,OAG3C,EAxBR,aA2BK,IAAS,EAQA,EAzBV,EAAmB,EAAAja,SAASqa,qBAAqB,MAAU,IAAKD,UAAU7P,WAEb,EAApD,IAAA+P,UAAU,kCAAkCnS,GC8DrD,ED7DIoS,OAAS,EC6Db,EDzDIC,UAAY,EALhB,IAgBc,EAhBd,EC+DO,GDhDN,SAAS,EAATxa,SAASka,eAAe,QAAxB,yBACGO,SAAU,gBACS,IAAS,EAAxB,GAAe,SAAS,EAATza,SAASka,eAAe,WAAxB,yBAAwD1Y,MAG3E,OADI,EAAGkZ,KAAKC,GACZ,IAGoD,MAAvD,SAAS,EAAT3a,SAASka,eAAe,SAAxB,yBCuCD,EDtCG1Y,MAAQ,QCsCX,EDrCIiZ,QAAU,+BAEV,OADI,EAAGC,KAAK,YACZ,GAFU,IErBR,iCHmEJ,IAAI,EAAc,GGxDpB,OHyDQ,EGlEAE,UCmYQ,cAAc,KJjUtB,EGjEAC,aCkYQ,cAAc,KJjUtB,EGhEAC,SCiYQ,eAAc,KJhUnB,YAAa,EAAI,GG/DxB,EAAAlY,YACA,EAAApB,MEiLO,EAAC,GFhLR,EAAAuZ,SAAW,+BACP,UAAOC,EAAM3L,OAAO7N,MACxB,OEiLA,EAAC,GAAG,GFjLJ,GAFW,IAGf,kEArBUyZ,GAAiB,cAC3B,IACI,EADA9S,EAAQuR,EAAS7W,EAAMsF,MAqB/B,OApBI,6BAAAgS,KAAI,gBH2EF,IAAI,EAAc,GGpEpB,OHqEQ,EG1EAe,QC2YQ,cAAc,KJjUtB,EGzEAC,gBC0PD,eJjLC,EGxEAC,MCyPD,kBJhLI,YAAa,EAAI,GGvExB,oBAAC,UE0LM,EAAC,IFzLZ,KACA,6BAAAC,MAAM,MAYV,iEGpCA,UAEI,EAAO,CAAC,EAAW,OAAU,YAA6B,0BAAP,EAY/C,SAAUC,EAAGC,EAAQC,GAC3B,aAIA,OAH2BD,EAAOE,qBACbF,EAAOG,KAAKC,UAChBJ,EAAOG,KAAKE,MACtBN,CACT,GAlB8D,oDCF9D,UAEI,EAAO,CAAC,EAAW,OAAU,MAAqB,OAAgB,OAAkB,aAA2B,0BAAP,EAqBpG,SAAUA,EAAGC,EAAQC,EAA2BK,EAAsBC,EAAwBC,GACpG,aACA,IAAIC,EAAuBV,EAAEU,uBAAyBV,EAAEU,qBAAuB,CAAC,GAWhF,OAV2BT,EAAOE,qBACfF,EAAOU,aACTV,EAAOG,KAAKE,MAI7BI,EAAqB,gBAAkBH,GACrB,GAAItR,WACN,KAAMA,WAEf+Q,CACT,GAnCmH,mDCFnH,UAEI,EAAO,CAAC,EAAW,aAAkB,0BAAP,EAS1B,SAAUA,EAAGC,GACnB,aAOA,OAN2BA,EAAOE,qBACfF,EAAOU,aACTV,EAAOG,KAAKE,MACdL,EAAOW,OAAOC,YAAYC,SACRb,EAAOW,OAAOG,mCAC1Bd,EAAOG,KAAKC,UAC1BL,CACT,GAlByC,oDCFzC,UAEI,EAAO,CAAC,EAAW,OAAU,aAAiB,0BAAP,EAYnC,SAAUA,EAAGC,EAAQe,GAC3B,aACA,IAAIN,EAAuBV,EAAEU,uBAAyBV,EAAEU,qBAAuB,CAAC,GAQhF,OAPiBT,EAAOG,KAAKE,MACFL,EAAOE,qBACvBF,EAAOW,OAAOK,KACNhB,EAAOU,aACLK,EAAc7D,eACC8C,EAAOW,OAAOM,sCAClDR,EAAqBS,MAAQH,EACtBhB,CACT,GAvBkD,oDCFlD,UAEI,EAAO,CAAC,EAAW,aAAkB,0BAAP,EAS1B,SAAUA,EAAGC,GACnB,aACA,IAAIE,EAAuBF,EAAOE,qBAC9BiB,EAAcnB,EAAOG,KAAKiB,OAC9B,SAASC,IACPC,EAAqB5e,IACvB,CACAoD,OAAOiR,eAAesK,EAAUld,UAAW,IAAK,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,mDAAmD,WAChJ,MAAO,GACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,OAAQ,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,sDAAsD,WACtJ,MAAO,MACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,UAAW,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,yDAAyD,WAC5J,MAAO,SACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,OAAQ,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,sDAAsD,WACtJ,MAAO,MACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,UAAW,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,yDAAyD,WAC5J,MAAO,SACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,QAAS,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,uDAAuD,WACxJ,MAAO,OACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,QAAS,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,uDAAuD,WACxJ,MAAO,OACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,IAAK,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,mDAAmD,WAChJ,MAAO,GACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,OAAQ,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,sDAAsD,WACtJ,MAAO,MACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,MAAO,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,qDAAqD,WACpJ,MAAO,KACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,MAAO,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,qDAAqD,WACpJ,MAAO,KACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,MAAO,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,qDAAqD,WACpJ,MAAO,KACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,aAAc,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,4DAA4D,WAClK,MAAO,YACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,OAAQ,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,sDAAsD,WACtJ,MAAO,MACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,KAAM,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,oDAAoD,WAClJ,MAAO,IACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,SAAU,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,wDAAwD,WAC1J,MAAO,QACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,SAAU,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,wDAAwD,WAC1J,MAAO,QACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,UAAW,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,yDAAyD,WAC5J,MAAO,SACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,OAAQ,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,sDAAsD,WACtJ,MAAO,MACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,OAAQ,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,sDAAsD,WACtJ,MAAO,MACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,MAAO,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,qDAAqD,WACpJ,MAAO,KACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,WAAY,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,0DAA0D,WAC9J,MAAO,UACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,OAAQ,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,sDAAsD,WACtJ,MAAO,MACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,WAAY,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,0DAA0D,WAC9J,MAAO,UACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,KAAM,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,oDAAoD,WAClJ,MAAO,IACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,MAAO,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,qDAAqD,WACpJ,MAAO,KACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,UAAW,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,yDAAyD,WAC5J,MAAO,SACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,MAAO,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,qDAAqD,WACpJ,MAAO,KACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,SAAU,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,wDAAwD,WAC1J,MAAO,QACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,MAAO,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,qDAAqD,WACpJ,MAAO,KACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,KAAM,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,oDAAoD,WAClJ,MAAO,IACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,KAAM,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,oDAAoD,WAClJ,MAAO,IACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,KAAM,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,oDAAoD,WAClJ,MAAO,IACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,QAAS,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,uDAAuD,WACxJ,MAAO,OACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,WAAY,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,0DAA0D,WAC9J,MAAO,UACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,aAAc,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,4DAA4D,WAClK,MAAO,YACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,SAAU,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,wDAAwD,WAC1J,MAAO,QACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,SAAU,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,wDAAwD,WAC1J,MAAO,QACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,OAAQ,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,sDAAsD,WACtJ,MAAO,MACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,KAAM,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,oDAAoD,WAClJ,MAAO,IACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,KAAM,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,oDAAoD,WAClJ,MAAO,IACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,KAAM,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,oDAAoD,WAClJ,MAAO,IACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,KAAM,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,oDAAoD,WAClJ,MAAO,IACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,KAAM,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,oDAAoD,WAClJ,MAAO,IACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,KAAM,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,oDAAoD,WAClJ,MAAO,IACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,OAAQ,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,sDAAsD,WACtJ,MAAO,MACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,SAAU,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,wDAAwD,WAC1J,MAAO,QACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,SAAU,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,wDAAwD,WAC1J,MAAO,QACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,KAAM,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,oDAAoD,WAClJ,MAAO,IACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,OAAQ,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,sDAAsD,WACtJ,MAAO,MACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,IAAK,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,mDAAmD,WAChJ,MAAO,GACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,SAAU,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,wDAAwD,WAC1J,MAAO,QACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,MAAO,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,qDAAqD,WACpJ,MAAO,KACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,QAAS,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,uDAAuD,WACxJ,MAAO,OACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,MAAO,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,qDAAqD,WACpJ,MAAO,KACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,MAAO,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,qDAAqD,WACpJ,MAAO,KACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,SAAU,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,wDAAwD,WAC1J,MAAO,QACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,QAAS,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,uDAAuD,WACxJ,MAAO,OACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,SAAU,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,wDAAwD,WAC1J,MAAO,QACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,KAAM,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,oDAAoD,WAClJ,MAAO,IACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,OAAQ,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,sDAAsD,WACtJ,MAAO,MACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,OAAQ,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,sDAAsD,WACtJ,MAAO,MACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,MAAO,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,qDAAqD,WACpJ,MAAO,KACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,OAAQ,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,sDAAsD,WACtJ,MAAO,MACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,OAAQ,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,sDAAsD,WACtJ,MAAO,MACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,WAAY,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,0DAA0D,WAC9J,MAAO,UACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,OAAQ,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,sDAAsD,WACtJ,MAAO,MACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,QAAS,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,uDAAuD,WACxJ,MAAO,OACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,MAAO,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,qDAAqD,WACpJ,MAAO,KACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,WAAY,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,0DAA0D,WAC9J,MAAO,UACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,SAAU,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,wDAAwD,WAC1J,MAAO,QACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,KAAM,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,oDAAoD,WAClJ,MAAO,IACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,WAAY,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,0DAA0D,WAC9J,MAAO,UACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,SAAU,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,wDAAwD,WAC1J,MAAO,QACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,SAAU,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,wDAAwD,WAC1J,MAAO,QACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,IAAK,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,mDAAmD,WAChJ,MAAO,GACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,QAAS,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,uDAAuD,WACxJ,MAAO,OACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,UAAW,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,yDAAyD,WAC5J,MAAO,SACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,MAAO,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,qDAAqD,WACpJ,MAAO,KACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,WAAY,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,0DAA0D,WAC9J,MAAO,UACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,IAAK,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,mDAAmD,WAChJ,MAAO,GACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,KAAM,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,oDAAoD,WAClJ,MAAO,IACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,KAAM,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,oDAAoD,WAClJ,MAAO,IACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,OAAQ,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,sDAAsD,WACtJ,MAAO,MACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,IAAK,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,mDAAmD,WAChJ,MAAO,GACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,OAAQ,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,sDAAsD,WACtJ,MAAO,MACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,OAAQ,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,sDAAsD,WACtJ,MAAO,MACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,SAAU,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,wDAAwD,WAC1J,MAAO,QACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,UAAW,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,yDAAyD,WAC5J,MAAO,SACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,SAAU,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,wDAAwD,WAC1J,MAAO,QACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,QAAS,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,uDAAuD,WACxJ,MAAO,OACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,SAAU,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,wDAAwD,WAC1J,MAAO,QACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,OAAQ,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,sDAAsD,WACtJ,MAAO,MACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,SAAU,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,wDAAwD,WAC1J,MAAO,QACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,QAAS,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,uDAAuD,WACxJ,MAAO,OACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,MAAO,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,qDAAqD,WACpJ,MAAO,KACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,UAAW,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,yDAAyD,WAC5J,MAAO,SACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,MAAO,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,qDAAqD,WACpJ,MAAO,KACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,QAAS,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,uDAAuD,WACxJ,MAAO,OACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,WAAY,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,0DAA0D,WAC9J,MAAO,UACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,QAAS,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,uDAAuD,WACxJ,MAAO,OACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,KAAM,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,oDAAoD,WAClJ,MAAO,IACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,WAAY,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,0DAA0D,WAC9J,MAAO,UACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,QAAS,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,uDAAuD,WACxJ,MAAO,OACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,KAAM,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,oDAAoD,WAClJ,MAAO,IACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,QAAS,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,uDAAuD,WACxJ,MAAO,OACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,OAAQ,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,sDAAsD,WACtJ,MAAO,MACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,QAAS,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,uDAAuD,WACxJ,MAAO,OACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,KAAM,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,oDAAoD,WAClJ,MAAO,IACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,QAAS,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,uDAAuD,WACxJ,MAAO,OACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,IAAK,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,mDAAmD,WAChJ,MAAO,GACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,KAAM,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,oDAAoD,WAClJ,MAAO,IACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,MAAO,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,qDAAqD,WACpJ,MAAO,KACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,QAAS,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,uDAAuD,WACxJ,MAAO,OACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,MAAO,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,qDAAqD,WACpJ,MAAO,KACT,MACApa,OAAOiR,eAAesK,EAAUld,UAAW,UAAW,CAACod,cAAc,EAAM5W,IAAKuV,EAAqB,yDAAyD,WAC5J,MAAO,SACT,MACAmB,EAAUG,WAAa,CAACC,KAAMN,EAAaO,WAAY,YAAaC,WAAY,IAChF,IAAIL,EAAqB,KAOzB,IAGIM,EAAgB7B,EAAEmB,QAAUnB,EAAEmB,MAAQ,CAAC,GACvCW,EAAcD,EAAcE,MAAQF,EAAcE,IAAM,CAAC,GACzDC,EAAeF,EAAYG,OAASH,EAAYG,KAAO,CAAC,GAE5D,OADAlc,OAAOiR,eAAegL,EAAc,YAAa,CAACpX,IAZlD,WAIE,OAH2B,OAAvB2W,GACF,IAAID,EAECC,CACT,IAQOvB,CACT,GA5XyC,mDCFzC,UAEI,EAAO,CAAC,EAAW,OAAU,OAAqB,aAAiB,0BAAP,EAexD,SAAUA,EAAGC,EAAQiC,EAA2BlB,GACtD,aACA,IAQImB,EARAzB,EAAuBV,EAAEU,uBAAyBV,EAAEU,qBAAuB,CAAC,GAE5E/b,GADuBsb,EAAOE,qBACda,EAAcrc,eAC9Bsc,EAAOhB,EAAOW,OAAOK,KACrBmB,EAAiBnC,EAAOG,KAAKC,UAC7BgC,EAAapC,EAAOG,KAAKE,MACzBgC,EAASrC,EAAOW,OAAOC,YAAY0B,eACnCpF,EAAiB6D,EAAc7D,eAEnC,SAASqF,IACT,CA+CA,SAASC,IACP,OAAO,IAAIC,CACb,CACA,SAASA,IACT,CAQA,SAASC,EAAUC,GACjB,OAAO,SAAUrb,GACf,OAAOsb,EARX,SAA0BD,EAAeE,GACvC,OAAO,SAAUC,GAEf,OADAH,EAAcG,EAAWD,GAClB7B,CACT,CACF,CAG+B+B,CAAiBJ,EAAerb,GAC7D,CACF,CAKA,SAAS0b,EAASF,EAAWG,GAC3B,IAAIC,EACAC,EAAUX,IACdS,EAAME,GACN,IAAI7b,EAAQ6b,EACR5b,EAAyC,OAA7B2b,EAAOC,EAAQjB,IAAqBgB,EAAO,GAC3D,OAAOxe,EAAcuP,MAAM,KAAM,CAAC6O,EAAWxb,GAAOgF,OAAO/E,GAC7D,CACA,SAASqb,EAAoBK,GAC3B,IAAIC,EAAME,EACNN,EAAYN,IAGhB,GAFAS,EAAMH,GAEM,OADZI,EAAOJ,EAAUZ,IAEf,OAAO,KAET,IAAI3a,EAAW2b,EACf,GAAwB,IAApB3b,EAASnE,OACX,OAAO,KACT,GAAwB,IAApBmE,EAASnE,OAAc,CAEzB,GAAc,OADdggB,EAASf,EAAO9a,IAEd,OAAO,KAET,IAAI8b,EAAQD,EACZ,GAAIlG,EAAemG,GACjB,OAAOA,CAEX,CACA,OAAO3e,EAAcuP,MAAM,KAAM,CAAC8M,EAAcnK,cAAU,GAAQtK,OAAO/E,GAC3E,CAjGAgb,EAAgBpe,UAAUmf,kBAAoB,SAAUR,GACtDhd,OAAOC,OAAOrD,KAAMogB,EACtB,EACAP,EAAgBpe,UAAUof,cAAgB,SAAU5a,GAC5B,MAAlBjG,KAAKwf,GACPxf,KAAKwf,GAAUve,KAAKgF,GAEpBjG,KAAKwf,GAAY,CAACvZ,EAEtB,EACA4Z,EAAgBpe,UAAUqf,kBAAoB,SAAUV,GACtDpgB,KAAK6gB,cAAcT,EACrB,EACAP,EAAgBpe,UAAUsf,kBAAoB,SAAUX,GACtDpgB,KAAK8gB,kBAAkBV,EACzB,EACAP,EAAgBpe,UAAUuf,cAAgB,SAAUrc,EAAMC,GACxD5E,KAAK8gB,kBAAkB9e,EAAc2C,EAAMC,GAC7C,EACAib,EAAgBpe,UAAUwf,eAAiB,SAAUb,GACnDpgB,KAAK8gB,kBAAkB9e,EAAcoe,GACvC,EACAP,EAAgBpe,UAAUyf,eAAiB,SAAUd,EAAWG,GAC9DvgB,KAAK8gB,kBAAkBR,EAASF,EAAWG,GAC7C,EAQAV,EAAgBpe,UAAU0f,eAAiB,SAAUf,EAAW7c,EAAOgd,GAPvE,IAAuCa,EAAenB,EAQpDjgB,KAAKkhB,eAAed,EAAUpO,UAROoP,EAQiC7d,EARlB0c,EAQyBM,EAPtE,SAAUH,GAGf,OAFAA,EAAU7c,MAAQ6d,EAClBnB,EAAcG,GACP9B,CACT,GAIF,EAQAuB,EAAgBpe,UAAU4f,eAAiB,SAAUjB,EAAW7c,EAAOgd,GAPvE,IAAyCa,EAAenB,EAQtDjgB,KAAKkhB,eAAed,GARmBgB,EAQwB7d,EART0c,EAQgBM,EAP/D,SAAUH,GAGf,OAFAA,EAAU7c,MAAQ6d,EAClBnB,EAAcG,GACP9B,CACT,GAIF,EACAuB,EAAgBf,WAAa,CAACC,KAAMU,EAAgBT,WAAY,kBAAmBC,WAAY,IAM/Fc,EAAoBjB,WAAa,CAACC,KAAMW,EAAYV,WAAY,sBAAuBC,WAAY,CAACY,IA+CpG,IAAIX,EAAgB7B,EAAEmB,QAAUnB,EAAEmB,MAAQ,CAAC,GAiB3C,OAhBAT,EAAqB,qBAAuBwB,EAC5CL,EAAcW,gBAAkBA,EAChCX,EAAcoC,sBAAwBxB,EACtCZ,EAAcqC,WAvCd,SAAYhB,GAEV,OADgBP,EAAUO,EAE5B,EAqCArB,EAAcsC,eAAiBlB,EAC/BpB,EAAcuC,2BAA6BvB,EAC3CH,EAAoBte,UAAUmf,kBAAoBf,EAAgBpe,UAAUmf,kBAC5Eb,EAAoBte,UAAUqf,kBAAoBjB,EAAgBpe,UAAUqf,kBAC5Ef,EAAoBte,UAAUsf,kBAAoBlB,EAAgBpe,UAAUsf,kBAC5EhB,EAAoBte,UAAUof,cAAgBhB,EAAgBpe,UAAUof,cACxEd,EAAoBte,UAAUuf,cAAgBnB,EAAgBpe,UAAUuf,cACxEjB,EAAoBte,UAAUwf,eAAiBpB,EAAgBpe,UAAUwf,eACzElB,EAAoBte,UAAUyf,eAAiBrB,EAAgBpe,UAAUyf,eACzEnB,EAAoBte,UAAU0f,eAAiBtB,EAAgBpe,UAAU0f,eACzEpB,EAAoBte,UAAU4f,eAAiBxB,EAAgBpe,UAAU4f,eACzE7B,EAAWzK,OAAO,cACXsI,CACT,GAhJuE,kDCStE,QATa,EASN,SAAUC,GACd,IAAID,EAAIC,ECyBZA,EAAOvS,QAAU,SAAUmL,GACvB,OAAOpN,MAAMiC,QAAQmL,KAAOA,EAAEwL,QAGlCpE,EAAOqE,WAAa,SAAUzL,GAC1B,OAAOpN,MAAMiC,QAAQmL,IAAM0L,YAAYC,OAAO3L,ICjClDoH,EAAOwE,OAAS,SAAU5L,GACtB,OAAY,IAAJA,IAAa,IAAM,ICL/BoH,EAAOyE,OAAS,SAAUC,EAAMC,GAC5B,OAAY,MAARD,EACe,MAARC,EAGC,MAARA,IAIAD,GAASA,EACFC,GAASA,EAGA,iBAATD,GAA4C,mBAAhBA,EAAKD,OACjCC,EAAKD,OAAOE,GAGH,iBAATD,GAAqC,iBAATC,EAC5BD,IAASC,IAAkB,IAATD,GAAc,EAAIA,GAAS,EAAIC,GAGrDD,IAASC,IAGpB3E,EAAO4E,SAAW,SAAU7R,GACxB,GAAW,MAAPA,EACA,OAAO,EAEX,IAAI8R,SAAiB9R,EACrB,MAAI,WAAa8R,EACN,mBAAsB9R,EAAI6R,SAAW7R,EAAI6R,WAAaE,EAAkB/R,GAE/E,aAAe8R,EACRC,EAAkB/R,GAEzB,WAAa8R,EACN7E,EAAO+E,eAAehS,GAE7B,YAAc8R,EACPG,OAAOjS,GAkCtB,SAA2BlE,GAEvB,IADA,IAAI3D,EAAO,EACFlG,EAAI,EAAGA,EAAI6J,EAAIzL,OAAQ4B,IAE5BkG,EAAgB,GAAPA,EADG2D,EAAIpI,WAAWzB,GACE,EAEjC,OAAOkG,EApCA+Z,CADGrf,OAAOmN,KAKrBiN,EAAOhR,SAAW,SAAUkW,GACxB,OAAS,MAALA,EACO,OAEFlF,EAAOqE,WAAWa,GAChB,QAGAA,EAAElW,YAKjB,ICXQmW,EACAC,EAEAC,EACAC,EACAC,ECkLU,IFzKdC,EAAiC,uBAErC,SAASV,EAAkB/R,GACvB,KAAMyS,KAAkCzS,GAAxC,CACI,IAAI7H,EAPG,WAOKvF,KAAK8f,SAAuB,EACxC3f,OAAOiR,eAAehE,EAAKyS,EAAgC,CAAEvf,MAAQiF,EAAMwa,YAAY,IAE3F,OAAO3S,EAAG,qBGEd,SAAS4S,IACL,MAAM,IAAItM,MACN,2JF9BR,SAASuM,EAAKhN,EAAGC,GACb,OAAa,WAAJD,IAAuB,MAAJC,IAAmB,MAAJD,IAAmB,EAAJC,GAAU,EGTxE,SAASgN,EAA2BC,EAAMC,GACtC,GAAID,IAASC,EAAO,OAAO,EAE3B,IAAIC,EAAWF,EAAKtE,WACpB,GAAgB,MAAZwE,EAEA,IADA,IAAIrE,EAAaqE,EAASrE,WACjB3c,EAAI,EAAGA,EAAI2c,EAAWve,OAAQ4B,IACnC,GAAI6gB,EAA2BlE,EAAW3c,GAAI+gB,GAC1C,OAAO,EAKnB,IAAIE,EAAmC,MAAlBH,EAAK3hB,UAAoB2B,OAAOogB,eAAeJ,EAAK3hB,WAAa,KAClFgiB,EAAqC,MAAlBF,EAAyBA,EAAezM,YAAc,KAC7E,OAA2B,MAApB2M,GAA4BN,EAA2BM,EAAkBJ,GJ+BpF/F,EAAOoG,iBAAmBtB,EK9C1B9E,EAAOqG,KAAO,cAKZ3jB,KAAK4jB,KAAa,EAANC,EAMZ7jB,KAAK8jB,MAAe,EAAPC,GAGfzG,EAAOqG,KAAK7E,WAAa,CACrBC,KAAM,QACNC,WAAY,OACZC,WAAW,IAaf3B,EAAOqG,KAAKK,UAAY,CAAC,EAQzB1G,EAAOqG,KAAKM,QAAU,YACpB,IAAK,KAAO1gB,GAASA,EAAQ,IAA7B,CACE,IAAI2gB,EAAY5G,EAAOqG,KAAKK,UAAUzgB,GACtC,GAAI2gB,EACF,OAAOA,EAIX,IAAI7T,EAAM,IAAIiN,EAAOqG,KAAa,EAARpgB,EAAWA,EAAQ,GAAK,EAAI,GAItD,OAHK,KAAOA,GAASA,EAAQ,MAC3B+Z,EAAOqG,KAAKK,UAAUzgB,GAAS8M,GAE1BA,GAYTiN,EAAOqG,KAAKQ,WAAa,YACvB,OAAIC,MAAM7gB,GACD+Z,EAAOqG,KAAKU,KACV9gB,IAAU+Z,EAAOqG,KAAKW,gBACxBhH,EAAOqG,KAAKY,UACVhhB,EAAQ,GAAK+Z,EAAOqG,KAAKW,gBAC3BhH,EAAOqG,KAAKa,UACVjhB,EAAQ,EACV+Z,EAAOqG,KAAKQ,YAAY5gB,GAAOkhB,SAE/B,IAAInH,EAAOqG,KACbpgB,EAAQ+Z,EAAOqG,KAAKe,gBAAmB,EACvCnhB,EAAQ+Z,EAAOqG,KAAKe,gBAAmB,IAYhDpH,EAAOqG,KAAKgB,SAAW,cACrB,OAAO,IAAIrH,EAAOqG,KAAKiB,EAASC,IAWlCvH,EAAOqG,KAAKmB,WAAa,cACvB,GAAkB,GAAd3Y,EAAIzL,OACN,MAAMiW,MAAM,qCAGd,IAAIoO,EAAQC,GAAa,GACzB,GAAID,EAAQ,GAAK,GAAKA,EACpB,MAAMpO,MAAM,uBAAyBoO,GAGvC,GAAqB,KAAjB5Y,EAAI8Y,OAAO,GACb,OAAO3H,EAAOqG,KAAKmB,WAAW3Y,EAAI+Y,UAAU,GAAIH,GAAON,SAClD,GAAItY,EAAItI,QAAQ,MAAQ,EAC7B,MAAM8S,MAAM,gDAAkDxK,GAQhE,IAHA,IAAIgZ,EAAe7H,EAAOqG,KAAKQ,WAAWlhB,KAAKmiB,IAAIL,EAAO,IAEtDpU,EAAS2M,EAAOqG,KAAKU,KAChB/hB,EAAI,EAAGA,EAAI6J,EAAIzL,OAAQ4B,GAAK,EAArC,CACE,IAAIgF,EAAOrE,KAAKoiB,IAAI,EAAGlZ,EAAIzL,OAAS4B,GAChCiB,EAAQ+hB,SAASnZ,EAAI+Y,UAAU5iB,EAAGA,EAAIgF,GAAOyd,GACjD,GAAIzd,EAAO,EAAX,CACE,IAAIie,EAAQjI,EAAOqG,KAAKQ,WAAWlhB,KAAKmiB,IAAIL,EAAOzd,IACnDqJ,EAASA,EAAO6U,SAASD,GAAOE,IAAInI,EAAOqG,KAAKQ,WAAW5gB,SAG3DoN,GADAA,EAASA,EAAO6U,SAASL,IACTM,IAAInI,EAAOqG,KAAKQ,WAAW5gB,IAG/C,OAAOoN,GAcT2M,EAAOqG,KAAK+B,gBAAkB,MAO9BpI,EAAOqG,KAAKgC,gBAAkB,GAAK,GAOnCrI,EAAOqG,KAAKe,gBACRpH,EAAOqG,KAAK+B,gBAAkBpI,EAAOqG,KAAK+B,gBAO9CpI,EAAOqG,KAAKiC,gBACRtI,EAAOqG,KAAKe,gBAAkB,EAOlCpH,EAAOqG,KAAKkC,gBACRvI,EAAOqG,KAAKe,gBAAkBpH,EAAOqG,KAAK+B,gBAO9CpI,EAAOqG,KAAKmC,gBACRxI,EAAOqG,KAAKe,gBAAkBpH,EAAOqG,KAAKe,gBAO9CpH,EAAOqG,KAAKW,gBACRhH,EAAOqG,KAAKmC,gBAAkB,EAIlCxI,EAAOqG,KAAKU,KAAO/G,EAAOqG,KAAKM,QAAQ,GAIvC3G,EAAOqG,KAAKoC,IAAMzI,EAAOqG,KAAKM,QAAQ,GAItC3G,EAAOqG,KAAKqC,QAAU1I,EAAOqG,KAAKM,SAAS,GAI3C3G,EAAOqG,KAAKa,UACRlH,EAAOqG,KAAKgB,UAAS,EAAgB,YAIzCrH,EAAOqG,KAAKY,UAAYjH,EAAOqG,KAAKgB,SAAS,GAAG,YAOhDrH,EAAOqG,KAAKsC,YAAc3I,EAAOqG,KAAKM,QAAQ,GAAK,IAInD3G,EAAOqG,KAAKliB,UAAUykB,MAAQ,WAC5B,OAAOlmB,KAAK4jB,MAKdtG,EAAOqG,KAAKliB,UAAU0kB,SAAW,WAC/B,OAAOnmB,KAAK8jB,MAAQxG,EAAOqG,KAAKe,gBACzB1kB,KAAKomB,sBAId9I,EAAOqG,KAAKliB,UAAUygB,SAAW,WAC/B,OAAOliB,KAAK8jB,MAAQ9jB,KAAK4jB,MAQ3BtG,EAAOqG,KAAKliB,UAAU6K,SAAW,YAC/B,IAAIyY,EAAQC,GAAa,GACzB,GAAID,EAAQ,GAAK,GAAKA,EACpB,MAAMpO,MAAM,uBAAyBoO,GAGvC,GAAI/kB,KAAKqmB,SACP,MAAO,IAGT,GAAIrmB,KAAKsmB,aAAT,CACE,GAAItmB,KAAKumB,WAAWjJ,EAAOqG,KAAKY,WAAhC,KAGMiC,EAAYlJ,EAAOqG,KAAKQ,WAAWY,GACnC7I,EAAMlc,KAAKkc,IAAIsK,GACfC,EAAMvK,EAAIsJ,SAASgB,GAAWE,SAAS1mB,MAC3C,OAAOkc,EAAI5P,SAASyY,GAAS0B,EAAIP,QAAQ5Z,SAASyY,GAElD,MAAO,IAAM/kB,KAAKykB,SAASnY,SAASyY,GAUxC,IAJA,IAAII,EAAe7H,EAAOqG,KAAKQ,WAAWlhB,KAAKmiB,IAAIL,EAAO,IAGtDpU,GADA8V,EAAMzmB,KACG,MACb,CACE,IAAI2mB,EAASF,EAAIvK,IAAIiJ,GAEjByB,EADSH,EAAIC,SAASC,EAAOnB,SAASL,IAAee,QACrC5Z,SAASyY,GAG7B,IADA0B,EAAME,GACEN,SACN,OAAOO,EAASjW,EAEhB,KAAOiW,EAAOlmB,OAAS,GACrBkmB,EAAS,IAAMA,EAEjBjW,EAAS,GAAKiW,EAASjW,IAO7B2M,EAAOqG,KAAKliB,UAAUolB,YAAc,WAClC,OAAO7mB,KAAK8jB,OAKdxG,EAAOqG,KAAKliB,UAAUqlB,WAAa,WACjC,OAAO9mB,KAAK4jB,MAKdtG,EAAOqG,KAAKliB,UAAU2kB,mBAAqB,WACzC,OAAQpmB,KAAK4jB,MAAQ,EACjB5jB,KAAK4jB,KAAOtG,EAAOqG,KAAKe,gBAAkB1kB,KAAK4jB,MAQrDtG,EAAOqG,KAAKliB,UAAUslB,cAAgB,WACpC,GAAI/mB,KAAKsmB,aACP,OAAItmB,KAAKumB,WAAWjJ,EAAOqG,KAAKY,WACvB,GAEAvkB,KAAKykB,SAASsC,gBAIvB,IADA,IAAIC,EAAoB,GAAdhnB,KAAK8jB,MAAa9jB,KAAK8jB,MAAQ9jB,KAAK4jB,KACrCqD,EAAM,GAAIA,EAAM,GACG,IAArBD,EAAO,GAAKC,GADSA,KAK5B,OAAqB,GAAdjnB,KAAK8jB,MAAamD,EAAM,GAAKA,EAAM,GAM9C3J,EAAOqG,KAAKliB,UAAU4kB,OAAS,WAC7B,OAAqB,GAAdrmB,KAAK8jB,OAA2B,GAAb9jB,KAAK4jB,MAKjCtG,EAAOqG,KAAKliB,UAAU6kB,WAAa,WACjC,OAAOtmB,KAAK8jB,MAAQ,GAKtBxG,EAAOqG,KAAKliB,UAAUylB,MAAQ,WAC5B,OAA0B,IAAN,EAAZlnB,KAAK4jB,OAQftG,EAAOqG,KAAKliB,UAAU8kB,WAAa,YACjC,OAAQvmB,KAAK8jB,OAASqD,EAAMrD,OAAW9jB,KAAK4jB,MAAQuD,EAAMvD,MAQ5DtG,EAAOqG,KAAKliB,UAAU2lB,cAAgB,YACpC,OAAQpnB,KAAK8jB,OAASqD,EAAMrD,OAAW9jB,KAAK4jB,MAAQuD,EAAMvD,MAQ5DtG,EAAOqG,KAAKliB,UAAU4lB,SAAW,YAC/B,OAAOrnB,KAAK6a,QAAQsM,GAAS,GAQ/B7J,EAAOqG,KAAKliB,UAAU6lB,gBAAkB,YACtC,OAAOtnB,KAAK6a,QAAQsM,IAAU,GAQhC7J,EAAOqG,KAAKliB,UAAU8lB,YAAc,YAClC,OAAOvnB,KAAK6a,QAAQsM,GAAS,GAQ/B7J,EAAOqG,KAAKliB,UAAU+lB,mBAAqB,YACzC,OAAOxnB,KAAK6a,QAAQsM,IAAU,GAUhC7J,EAAOqG,KAAKliB,UAAUoZ,QAAU,YAC9B,GAAI7a,KAAKumB,WAAWY,GAClB,OAAO,EAGT,IAAIM,EAAUznB,KAAKsmB,aACfoB,EAAWP,EAAMb,aACrB,OAAImB,IAAYC,GACN,GAELD,GAAWC,EACP,EAIL1nB,KAAK0mB,SAASS,GAAOb,cACf,EAED,GAMXhJ,EAAOqG,KAAKliB,UAAUgjB,OAAS,WAC7B,OAAIzkB,KAAKumB,WAAWjJ,EAAOqG,KAAKY,WACvBjH,EAAOqG,KAAKY,UAEZvkB,KAAK2nB,MAAMlC,IAAInI,EAAOqG,KAAKoC,MAUtCzI,EAAOqG,KAAKliB,UAAUgkB,IAAM,gBAGtBmC,EAAM5nB,KAAK8jB,QAAU,GACrB+D,EAAmB,MAAb7nB,KAAK8jB,MACXgE,EAAM9nB,KAAK4jB,OAAS,GACpBmE,EAAkB,MAAZ/nB,KAAK4jB,KAEXoE,EAAMb,EAAMrD,QAAU,GACtBmE,EAAoB,MAAdd,EAAMrD,MACZoE,EAAMf,EAAMvD,OAAS,GAGrBuE,EAAM,EAAGC,EAAM,EAAGC,EAAM,EAAGC,EAAM,EAYrC,OAVAD,IADAC,GAAOP,GAHgB,MAAbZ,EAAMvD,SAID,GACf0E,GAAO,MAEPF,IADAC,GAAOP,EAAMI,KACE,GACfG,GAAO,MAEPF,IADAC,GAAOP,EAAMI,KACE,GACfG,GAAO,MACPD,GAAOP,EAAMI,EACbG,GAAO,MACA7K,EAAOqG,KAAKgB,SAAU0D,GAAO,GAAMC,EAAMH,GAAO,GAAMC,IAS/D9K,EAAOqG,KAAKliB,UAAUilB,SAAW,YAC/B,OAAO1mB,KAAKylB,IAAI0B,EAAM1C,WASxBnH,EAAOqG,KAAKliB,UAAU+jB,SAAW,YAC/B,GAAIxlB,KAAKqmB,SACP,OAAO/I,EAAOqG,KAAKU,KACd,GAAI8C,EAAMd,SACf,OAAO/I,EAAOqG,KAAKU,KAGrB,GAAIrkB,KAAKumB,WAAWjJ,EAAOqG,KAAKY,WAC9B,OAAO4C,EAAMD,QAAU5J,EAAOqG,KAAKY,UAAYjH,EAAOqG,KAAKU,KACtD,GAAI8C,EAAMZ,WAAWjJ,EAAOqG,KAAKY,WACtC,OAAOvkB,KAAKknB,QAAU5J,EAAOqG,KAAKY,UAAYjH,EAAOqG,KAAKU,KAG5D,GAAIrkB,KAAKsmB,aACP,OAAIa,EAAMb,aACDtmB,KAAKykB,SAASe,SAAS2B,EAAM1C,UAE7BzkB,KAAKykB,SAASe,SAAS2B,GAAO1C,SAElC,GAAI0C,EAAMb,aACf,OAAOtmB,KAAKwlB,SAAS2B,EAAM1C,UAAUA,SAIvC,GAAIzkB,KAAKqnB,SAAS/J,EAAOqG,KAAKsC,cAC1BkB,EAAME,SAAS/J,EAAOqG,KAAKsC,aAC7B,OAAO3I,EAAOqG,KAAKQ,WAAWnkB,KAAKmmB,WAAagB,EAAMhB,YAMxD,IAAIyB,EAAM5nB,KAAK8jB,QAAU,GACrB+D,EAAmB,MAAb7nB,KAAK8jB,MACXgE,EAAM9nB,KAAK4jB,OAAS,GACpBmE,EAAkB,MAAZ/nB,KAAK4jB,KAEXoE,EAAMb,EAAMrD,QAAU,GACtBmE,EAAoB,MAAdd,EAAMrD,MACZoE,EAAMf,EAAMvD,OAAS,GACrB2E,EAAmB,MAAbpB,EAAMvD,KAEZuE,EAAM,EAAGC,EAAM,EAAGC,EAAM,EAAGC,EAAM,EAqBrC,OAnBAD,IADAC,GAAOP,EAAMQ,KACE,GACfD,GAAO,MAEPF,IADAC,GAAOP,EAAMS,KACE,GACfF,GAAO,MAEPD,IADAC,GAAON,EAAMG,KACE,GACfG,GAAO,MAEPF,IADAC,GAAOP,EAAMU,KACE,GACfH,GAAO,MAEPD,IADAC,GAAON,EAAMI,KACE,GACfE,GAAO,MAEPD,IADAC,GAAOL,EAAME,KACE,GACfG,GAAO,MACPD,GAAOP,EAAMW,EAAMV,EAAMK,EAAMJ,EAAMG,EAAMF,EAAMC,EACjDG,GAAO,MACA7K,EAAOqG,KAAKgB,SAAU0D,GAAO,GAAMC,EAAMH,GAAO,GAAMC,IAS/D9K,EAAOqG,KAAKliB,UAAUya,IAAM,YAC1B,GAAIiL,EAAMd,SACR,MAAM1P,MAAM,oBACP,GAAI3W,KAAKqmB,SACd,OAAO/I,EAAOqG,KAAKU,KAGrB,GAAIrkB,KAAKumB,WAAWjJ,EAAOqG,KAAKY,WAAhC,CACE,GAAI4C,EAAMZ,WAAWjJ,EAAOqG,KAAKoC,MAC7BoB,EAAMZ,WAAWjJ,EAAOqG,KAAKqC,SAC/B,OAAO1I,EAAOqG,KAAKY,UACd,GAAI4C,EAAMZ,WAAWjJ,EAAOqG,KAAKY,WACtC,OAAOjH,EAAOqG,KAAKoC,IAKnB,IADIyC,EADWxoB,KAAKyoB,WAAW,GACTvM,IAAIiL,GAAOuB,UAAU,IAChCnC,WAAWjJ,EAAOqG,KAAKU,MAChC,OAAO8C,EAAMb,aAAehJ,EAAOqG,KAAKoC,IAAMzI,EAAOqG,KAAKqC,QAE1D,IAAIS,EAAMzmB,KAAK0mB,SAASS,EAAM3B,SAASgD,IAEvC,OADaA,EAAO/C,IAAIgB,EAAIvK,IAAIiL,IAI/B,GAAIA,EAAMZ,WAAWjJ,EAAOqG,KAAKY,WACtC,OAAOjH,EAAOqG,KAAKU,KAGrB,GAAIrkB,KAAKsmB,aACP,OAAIa,EAAMb,aACDtmB,KAAKykB,SAASvI,IAAIiL,EAAM1C,UAExBzkB,KAAKykB,SAASvI,IAAIiL,GAAO1C,SAE7B,GAAI0C,EAAMb,aACf,OAAOtmB,KAAKkc,IAAIiL,EAAM1C,UAAUA,SAQlC,IAAIkE,EAAMrL,EAAOqG,KAAKU,KAEtB,IADIoC,EAAMzmB,KACHymB,EAAIe,mBAAmBL,IAA9B,CAcE,QAXIqB,EAASvlB,KAAK2lB,IAAI,EAAG3lB,KAAK4lB,MAAMpC,EAAIN,WAAagB,EAAMhB,aAIvD2C,EAAO7lB,KAAK8lB,KAAK9lB,KAAK+lB,IAAIR,GAAUvlB,KAAKgmB,KACzCC,EAASJ,GAAQ,GAAM,EAAI7lB,KAAKmiB,IAAI,EAAG0D,EAAO,IAI9CK,EAAY7L,EAAOqG,KAAKQ,WAAWqE,GACnCY,EAAYD,EAAU3D,SAAS2B,GAC5BiC,EAAU9C,cAAgB8C,EAAU7B,YAAYd,IACrD+B,GAAUU,EAEVE,GADAD,EAAY7L,EAAOqG,KAAKQ,WAAWqE,IACbhD,SAAS2B,GAK7BgC,EAAU9C,WACZ8C,EAAY7L,EAAOqG,KAAKoC,KAG1B4C,EAAMA,EAAIlD,IAAI0D,GACd1C,EAAMA,EAAIC,SAAS0C,GAErB,OAAOT,GASTrL,EAAOqG,KAAKliB,UAAU4nB,OAAS,YAC7B,OAAOrpB,KAAK0mB,SAAS1mB,KAAKkc,IAAIiL,GAAO3B,SAAS2B,KAKhD7J,EAAOqG,KAAKliB,UAAUkmB,IAAM,WAC1B,OAAOrK,EAAOqG,KAAKgB,UAAU3kB,KAAK4jB,MAAO5jB,KAAK8jB,QAShDxG,EAAOqG,KAAKliB,UAAU6nB,IAAM,YAC1B,OAAOhM,EAAOqG,KAAKgB,SAAS3kB,KAAK4jB,KAAOuD,EAAMvD,KACf5jB,KAAK8jB,MAAQqD,EAAMrD,QASpDxG,EAAOqG,KAAKliB,UAAU8nB,GAAK,YACzB,OAAOjM,EAAOqG,KAAKgB,SAAS3kB,KAAK4jB,KAAOuD,EAAMvD,KACf5jB,KAAK8jB,MAAQqD,EAAMrD,QASpDxG,EAAOqG,KAAKliB,UAAU+nB,IAAM,YAC1B,OAAOlM,EAAOqG,KAAKgB,SAAS3kB,KAAK4jB,KAAOuD,EAAMvD,KACf5jB,KAAK8jB,MAAQqD,EAAMrD,QASpDxG,EAAOqG,KAAKliB,UAAUinB,UAAY,YAEhC,GAAe,IADfe,GAAW,IAET,OAAOzpB,KAEP,IAAI6jB,EAAM7jB,KAAK4jB,KACf,GAAI6F,EAAU,GAAd,CACE,IAAI1F,EAAO/jB,KAAK8jB,MAChB,OAAOxG,EAAOqG,KAAKgB,SACfd,GAAO4F,EACN1F,GAAQ0F,EAAY5F,IAAS,GAAK4F,GAEvC,OAAOnM,EAAOqG,KAAKgB,SAAS,EAAGd,GAAQ4F,EAAU,KAWvDnM,EAAOqG,KAAKliB,UAAUgnB,WAAa,YAEjC,GAAe,IADfgB,GAAW,IAET,OAAOzpB,KAEP,IAAI+jB,EAAO/jB,KAAK8jB,MAChB,GAAI2F,EAAU,GAAd,CACE,IAAI5F,EAAM7jB,KAAK4jB,KACf,OAAOtG,EAAOqG,KAAKgB,SACdd,IAAQ4F,EAAY1F,GAAS,GAAK0F,EACnC1F,GAAQ0F,GAEZ,OAAOnM,EAAOqG,KAAKgB,SACfZ,GAAS0F,EAAU,GACnB1F,GAAQ,EAAI,GAAK,IAa3BzG,EAAOqG,KAAKliB,UAAUioB,mBAAqB,YAEzC,GAAe,IADfD,GAAW,IAET,OAAOzpB,KAEP,IAAI+jB,EAAO/jB,KAAK8jB,MAChB,GAAI2F,EAAU,GAAd,CACE,IAAI5F,EAAM7jB,KAAK4jB,KACf,OAAOtG,EAAOqG,KAAKgB,SACdd,IAAQ4F,EAAY1F,GAAS,GAAK0F,EACnC1F,IAAS0F,GACR,OAAe,IAAXA,EACFnM,EAAOqG,KAAKgB,SAASZ,EAAM,GAE3BzG,EAAOqG,KAAKgB,SAASZ,IAAU0F,EAAU,GAAK,IAM3DnM,EAAOqG,KAAKliB,UAAUsgB,OAAS,SAAUoF,GACrC,OAAOA,aAAiB7J,EAAOqG,MAAQ3jB,KAAKumB,WAAWY,IAG3D7J,EAAOqG,KAAKliB,UAAUkoB,gBAAkBrM,EAAOqG,KAAKliB,UAAUoZ,QAE9DyC,EAAOqG,KAAKliB,UAAUmoB,IAAM,WACxB,OAAO5pB,KAAKylB,IAAInI,EAAOqG,KAAKoC,MAGhCzI,EAAOqG,KAAKliB,UAAUooB,IAAM,WACxB,OAAO7pB,KAAKylB,IAAInI,EAAOqG,KAAKqC,UAGhC1I,EAAOqG,KAAKliB,UAAUqoB,QAAU,WAC5B,OAAO9pB,KAAKmmB,YAGhB7I,EAAOqG,KAAKliB,UAAUsoB,UAAY,WAC9B,OAAO/pB,MAGXsd,EAAOqG,KAAKliB,UAAUuoB,WAAa1M,EAAOqG,KAAKliB,UAAUgjB,OACzDnH,EAAOqG,KAAKliB,UAAUwoB,IAAM3M,EAAOqG,KAAKliB,UAAUkmB,IAElDrK,EAAOqG,KAAKliB,UAAUyoB,QAAU,SAAU/C,GACtC,OAAO,IAAI7J,EAAOW,OAAOkM,OAAOC,UAAUpqB,KAAMmnB,IFvzBpD7J,EAAOE,qBAAuB,WAAA6M,GAC1B,OAAOA,GAGX/M,EAAOU,aAAe,SAAAqM,GAClB,IAAI3S,EAAI,WAEJ,OADAA,EAAI2S,KACK9Y,MAAMvR,KAAMkL,YAEzB,OAAO,WACH,OAAOwM,EAAEnG,MAAMvR,KAAMkL,aA+B7BoS,EAAOgN,YAAc,YACjB,OAAO/mB,GAGX+Z,EAAOiN,gBAAkB,YACrBtH,KAOJ3F,EAAOkN,kBAAoB,YACvBvH,KF7DJ3F,EAAOmN,UAAY,SAAUvU,EAAGC,GAC5B,IAAIuU,SAAexU,EACnB,MAAc,WAAVwU,EACiB,iBAANvU,EACAmH,EAAOqN,gBAAgBzU,EAAGC,GAE9BmH,EAAOsN,mBAAmB1U,EAAGC,GAE1B,WAAVuU,GAAgC,YAAVA,EACfpN,EAAOsN,mBAAmB1U,EAAGC,GAEjCD,EAAEyT,gBAAgBxT,IAG7BmH,EAAOsN,mBAAqB,SAAU1U,EAAGC,GACrC,OAAOD,EAAIC,GAAK,EAAID,EAAIC,EAAI,EAAI,GAGpCmH,EAAOqN,gBAAkB,SAAUzU,EAAGC,GAClC,GAAID,EAAIC,EAAG,OAAQ,EACnB,GAAID,EAAIC,EAAG,OAAO,EAElB,GAAID,IAAMC,EAAV,CACI,GAAU,IAAND,EAAS,OAAO,EAEpB,IAAI2U,EAAK,EAAI3U,EACb,OAAO2U,IAAO,EAAI1U,EAAI,EAAK0U,EAAK,GAAK,EAAI,EAG7C,OAAO3U,GAAMA,EAAKC,GAAMA,EAAI,EAAI,GAAM,GAW1CmH,EAAO4F,KAAOjgB,KAAKigB,MAAQA,EAE3B5F,EAAOwN,aAAe5H,EAOdT,EAAM,IAAIb,YAAY,GACtBc,EAAa,IAAIqI,aAAatI,GACjB,IAAIuI,aAAavI,GAC9BE,EAAW,IAAIsI,WAAWxI,GAC1BG,EAAW,EACXC,EAAY,EAEhBH,EAAW,IAAM,EACU,IAAvBC,EAASC,KACTA,EAAW,EACXC,EAAY,GAsChBvF,EAAO+E,eAAiB,YACpB,OAAW,EAANhS,KAAaA,EACD,EAANA,GAGPqS,EAAW,GAAKrS,GACc,GAAtBsS,EAASE,GAAkB,GAAKF,EAASC,GAAY,IAKzEtF,EAAO4N,cAAgB,YACnB,OAAY,MAALzjB,EAAYA,EAAI6V,EAAO6N,iBC7GS,IAAhCjoB,OAAOzB,UAAU2pB,YACxBhoB,OAAOiR,eAAenR,OAAOzB,UAAW,aAAc,CAClD8B,MAAO,SAAU8nB,EAAc/mB,GAE3B,OADAA,EAAWA,GAAY,EAChBtE,KAAKsrB,YAAYD,EAAc/mB,KAAcA,UAIvB,IAA9BpB,OAAOzB,UAAU8pB,UACxBnoB,OAAOiR,eAAenR,OAAOzB,UAAW,WAAY,CAChD8B,MAAO,SAAU8nB,EAAc/mB,GAC3B,IAAIknB,EAAgBxrB,KAAKsM,iBACRnL,IAAbmD,GAA0BA,EAAWknB,EAAc9qB,UACnD4D,EAAWknB,EAAc9qB,QAE7B4D,GAAY+mB,EAAa3qB,OACzB,IAAIwQ,EAAYsa,EAAc3nB,QAAQwnB,EAAc/mB,GACpD,OAAsB,IAAf4M,GAAoBA,IAAc5M,UAK5B,IAAdrB,KAAKwoB,OACZxoB,KAAKwoB,KAAO,YAER,OAAU,IADVhkB,GAAKA,IACU2c,MAAM3c,GACV6a,OAAO7a,GAEXA,EAAI,EAAI,GAAK,SAGF,IAAfxE,KAAKyoB,QACZzoB,KAAKyoB,MAAQ,YACT,OAAItH,MAAM3c,GACCkkB,IAEPlkB,EAAI,EACGxE,KAAK4lB,MAAMphB,GAEfxE,KAAK8lB,KAAKthB,KAIxB,WACG,IACImkB,EAAiB3oB,KAAK4oB,KADZ,sBAEVC,EAAiB7oB,KAAK4oB,KAAKD,GAC3BG,EAAuB,EAAEH,EACzBI,EAAuB,EAAEF,EA+C7B,QA7CyB,IAAd7oB,KAAKgpB,OACZhpB,KAAKgpB,KAAO,YACR,GAAIhpB,KAAKD,IAAIyE,GAAKqkB,EAAlB,CACI,IAAInb,EAASlJ,EAIb,OAHIxE,KAAKD,IAAIyE,GAAKmkB,IACdjb,GAAWlJ,EAAIA,EAAIA,EAAK,GAErBkJ,EAEP,IAAIjJ,EAAIzE,KAAKipB,IAAIzkB,GACb0kB,EAAK,EAAIzkB,EACb,OAAK0kB,SAAS1kB,GACT0kB,SAASD,IACNzkB,EAAIykB,GAAM,GADSlpB,KAAKipB,KAAKzkB,EAAIxE,KAAKgmB,KADrBhmB,KAAKipB,IAAIzkB,EAAIxE,KAAKgmB,YAM9B,IAAdhmB,KAAKopB,OACZppB,KAAKopB,KAAO,YACR,IAAI3kB,EAAIzE,KAAKipB,IAAIzkB,GACb0kB,EAAK,EAAIzkB,EACb,OAAK0kB,SAAS1kB,IAAO0kB,SAASD,IACtBzkB,EAAIykB,GAAM,EADwBlpB,KAAKipB,IAAIjpB,KAAKD,IAAIyE,GAAKxE,KAAKgmB,YAKrD,IAAdhmB,KAAKqpB,OACZrpB,KAAKqpB,KAAO,YACR,GAAIrpB,KAAKD,IAAIyE,GAAKqkB,EAAlB,CACI,IAAInb,EAASlJ,EAIb,OAHIxE,KAAKD,IAAIyE,GAAKmkB,IACdjb,GAAWlJ,EAAIA,EAAIA,EAAK,GAErBkJ,EAGP,IAAIuF,EAAIjT,KAAKipB,KAAKzkB,GAAI0O,EAAIlT,KAAKipB,KAAKzkB,GACpC,OAAOyO,IAAMqW,IAAW,EAAIpW,IAAMoW,KAAY,GAAKrW,EAAIC,IAAMD,EAAIC,UAQnD,IAAflT,KAAKupB,MAAhB,CACI,IAAIA,EAAQ,YACR,GAAI/kB,IAAMqkB,EAEN,OAAIrkB,EAAIukB,EAEAvkB,EAAIskB,EAGG9oB,KAAK+lB,IAAIvhB,GAAKxE,KAAKgmB,IAKnBhmB,KAAK+lB,IAAQ,EAAJvhB,EAAS,GAAS,EAAJA,IAK3BxE,KAAK+lB,IAAIvhB,EAAIxE,KAAK4oB,KAAKpkB,EAAIA,EAAI,IAGzC,GAAIA,IAAMqkB,EAEX,OAAQU,GAAO/kB,OAKXkJ,EAASlJ,EAOb,OANIxE,KAAKD,IAAIyE,IAAMmkB,IAIfjb,GAFSlJ,EAAIA,EAAIA,EAEF,GAEZkJ,GAGf1N,KAAKupB,MAAQA,OAES,IAAfvpB,KAAKwpB,QACZxpB,KAAKwpB,MAAQ,YACT,GAAIhlB,EAAI,EAEJ,OAAOkkB,IAEN,GAAIlkB,EAAI,GAAKqkB,EAEd,OAAIrkB,EAAIskB,EAGG9oB,KAAK+lB,IAAIvhB,GAAKxE,KAAKgmB,IAInBhmB,KAAK+lB,IAAIvhB,EAAIxE,KAAK4oB,KAAKpkB,EAAIA,EAAI,IAK1C,IAAIC,EAAIzE,KAAK4oB,KAAKpkB,EAAI,GAElBkJ,EAASjJ,EAQb,OAPIA,GAAKkkB,IAILjb,GAFSjJ,EAAIA,EAAIA,EAEF,IAGZzE,KAAK4oB,KAAK,GAAKlb,SAIR,IAAf1N,KAAKypB,QACZzpB,KAAKypB,MAAQ,YACT,GAAIzpB,KAAKD,IAAIyE,GAAKqkB,EAAlB,CACI,IAAInb,EAASlJ,EAIb,OAHIxE,KAAKD,IAAIyE,GAAKmkB,IACdjb,GAAWlJ,EAAIA,EAAIA,EAAK,GAErBkJ,EAEX,OAAO1N,KAAK+lB,KAAK,EAAIvhB,IAAM,EAAIA,IAAM,SAGnB,IAAfxE,KAAK0pB,QACZ1pB,KAAK0pB,MAAQ,YACT,GAAI1pB,KAAKD,IAAIyE,GAAKqkB,EAAlB,CACI,IAAIc,EAAKnlB,EAAIA,EACTolB,EAAKD,EAAKnlB,EAGd,OAFSolB,EAAKplB,EAEA,EAAIolB,EAAK,EAAID,EAAK,EAAInlB,EAExC,OAAOxE,KAAK+lB,IAAIvhB,EAAI,UAGF,IAAfxE,KAAK6pB,QACZ7pB,KAAK6pB,MAAQ,YACT,GAAI7pB,KAAKD,IAAIyE,GAAKqkB,EAAlB,CACI,IAAIc,EAAKnlB,EAAIA,EACTolB,EAAKD,EAAKnlB,EAGd,OAFSolB,EAAKplB,EAED,GAAKolB,EAAK,EAAID,EAAK,EAAInlB,EAExC,OAAOxE,KAAKipB,IAAIzkB,GAAK,IAG/B,QACwB,IAAfxE,KAAK8pB,QACZ9pB,KAAK8pB,MAAQ,WAIT,IAHA,IAAIrlB,EAAI,EACJhH,EAASwK,UAAUxK,OAEd4B,EAAI,EAAGA,EAAI5B,EAAQ4B,IAA5B,CACI,GAAI4I,UAAU5I,KAAOiqB,KAAYrhB,UAAU5I,MAAO,IAC9C,OAAOiqB,IAEX7kB,GAAKwD,UAAU5I,GAAK4I,UAAU5I,GAElC,OAAOW,KAAK4oB,KAAKnkB,UAGC,IAAfzE,KAAK+pB,QACZ/pB,KAAK+pB,MAAQ,YACT,OAAO/pB,KAAK+lB,IAAIvhB,GAAKxE,KAAKgqB,cAGT,IAAdhqB,KAAK6lB,OACZ7lB,KAAK6lB,KAAO,YACR,OAAO7lB,KAAK+lB,IAAIvhB,GAAKxE,KAAKiqB,aAGR,IAAfjqB,KAAKkqB,QACZlqB,KAAKkqB,OAAS,EAQXlqB,KAAK+lB,IARM,EAQD/lB,KAAKgmB,IAPP,YACH,IAAImE,EAAS3lB,IAAM,EACnB,OAAe,IAAX2lB,EACO,GAEJ,IAAMpE,EAAIoE,GAAUnE,EAAM,GAAK,UAMhB,IAAvBrH,YAAYC,SACnBD,YAAYC,OAAS,YACjB,OAAY,MAAL3L,GAA4B,MAAfA,EAAEmX,WAAqBnX,EAAEmX,UAAUA,YAAcC,UAAU7rB,UAAU4rB,iBAI7D,IAAzBvkB,MAAMrH,UAAU8rB,MAEvBnqB,OAAOiR,eAAevL,MAAMrH,UAAW,OAAQ,CAC3C8B,MAAO,SAAUA,MAGD,MAARvD,KACA,MAAM,IAAIwtB,UAAU,+BA4BxB,IAzBA,IAAI1V,EAAI1U,OAAOpD,MAGXqM,EAAMyL,EAAEpX,SAAW,EAInB+sB,EADQviB,UAAU,IACO,EAGzB1D,EAAIimB,EAAgB,EAChBxqB,KAAK2lB,IAAIvc,EAAMohB,EAAe,GAC9BxqB,KAAKoiB,IAAIoI,EAAephB,GAG5BpI,EAAMiH,UAAU,GAChBwiB,OAAsBvsB,IAAR8C,EACAoI,EAAMpI,GAAO,EAG3B0pB,EAAaD,EAAc,EACdzqB,KAAK2lB,IAAIvc,EAAMqhB,EAAa,GAC5BzqB,KAAKoiB,IAAIqI,EAAarhB,GAGhC7E,EAAImmB,GACP7V,EAAEtQ,GAAKjE,EACPiE,IAIJ,OAAOsQ,KAKlB,WACG,SAAS8V,EAAgBlnB,EAAQhG,GAC7B,OAAIgG,EAAS,EAAUzD,KAAK2lB,IAAI,EAAGliB,EAAShG,GACrCuC,KAAKoiB,IAAI3e,EAAQhG,GAE5B,SAASmtB,EAAgB7pB,EAAOC,GAM5B,YALmB,IAARA,IACPA,EAAMjE,KAAKU,QAEfsD,EAAQ4pB,EAAgB5pB,GAAS,EAAGhE,KAAKU,QACzCuD,EAAMhB,KAAK2lB,IAAI5kB,EAAO4pB,EAAgB3pB,EAAKjE,KAAKU,SACzC,IAAIV,KAAK8W,YAAY9W,KAAK8tB,SAAS9pB,EAAOC,IAIrD,IADA,IAAI8pB,EAAS,CAACT,UAAWU,WAAYC,YAAahD,WAAYD,aAAcD,cACnEzoB,EAAI,EAAGA,EAAIyrB,EAAOrtB,SAAU4B,OAEQ,KADrC4rB,EAAaH,EAAOzrB,IACFb,UAAU8rB,MAC5BnqB,OAAOiR,eAAe6Z,EAAWzsB,UAAW,OAAQ,CAChD8B,MAAOuF,MAAMrH,UAAU8rB,YAGW,IAA/BW,EAAWzsB,UAAUyC,OAC5Bd,OAAOiR,eAAe6Z,EAAWzsB,UAAW,QAAS,CACjD8B,MAAOsqB,SAOd,cAAetc,MAAM,KAAM,IAAI0Z,WAAW,aAE3C,IAAI1Z,EAAQ4c,SAAS1sB,UAAU8P,MAC/BnO,OAAOiR,eAAe8Z,SAAS1sB,UAAW,QAAS,CAC/C8B,MAAO,cACH,OAAOgO,EAAMxI,KAAK/I,KAAMouB,EAAM,GAAGlqB,MAAM6E,KAAK5E,OAOxD,IAAS7B,EAAI,EAAGA,EAAIyrB,EAAOrtB,SAAU4B,OAEO,KADpC4rB,EAAaH,EAAOzrB,IACFb,UAAUiH,KAC5BtF,OAAOiR,eAAe6Z,EAAWzsB,UAAW,MAAO,CAC/C8B,MAAO,cACH,MAAO,GAAGW,MAAM6E,KAAK/I,MAAM0I,IAAI5C,EAAUsoB,MAQzD,IAAIC,EAAuB,SAAUnY,EAAGC,GACpC,GAAID,EAAIC,EAAG,OAAQ,EACnB,GAAID,EAAIC,EAAG,OAAO,EAElB,GAAID,IAAMC,EAAV,CACI,GAAU,IAAND,EAAS,OAAO,EAEpB,IAAI2U,EAAK,EAAI3U,EACb,OAAO2U,IAAO,EAAI1U,EAAI,EAAK0U,EAAK,GAAK,EAAI,EAG7C,OAAO3U,GAAMA,EAAKC,GAAMA,EAAI,EAAI,GAAM,GAG1C,IAAS7T,EAAI,EAAGA,EAAIyrB,EAAOrtB,SAAU4B,EAArC,CACI,IAAI4rB,OACqC,KADrCA,EAAaH,EAAOzrB,IACFb,UAAU6sB,MAC5BlrB,OAAOiR,eAAe6Z,EAAWzsB,UAAW,OAAQ,CAChD8B,MAAO,YACH,OAAOuF,MAAMrH,UAAU6sB,KAAKvlB,KAAK/I,KAAMuuB,GAAmBF,OAK5E,GExXF/Q,EAAOG,KAAO,CACVE,MAAO,QACPD,UAAW,YACXgB,OAAQ,UAyDZpB,EAAOkR,OAAS,SAAUC,EAAQC,GAC9B,GAAIA,IAAUtrB,OACV,cAAeqrB,OACN,aACA,aACA,cACA,WACD,OAAO,UAEP,OAAOA,aAAkBrrB,OAIrC,GAAc,MAAVqrB,GAA2B,MAATC,GAAoC,iBAAXD,GAAyC,mBAAXA,EACzE,OAAO,EAGX,GAAqB,mBAAVC,GAAwBD,aAAkBC,EACjD,OAAO,EAGX,IAAIC,EAAQvrB,OAAOogB,eAAekL,GAC9B5X,EAAuB,MAAT6X,EAAgBA,EAAM7X,YAAc,KACtD,GAAmB,MAAfA,GAAuB,eAAgBA,GACxBA,EAAYgI,WACdC,OAASzB,EAAOG,KAAKiB,OAC9B,OAAO+P,IAAWC,EAI1B,IAAIE,EAAgBF,EAAM5P,WAG1B,OAAqB,MAAjB8P,EACOH,aAAkBC,EAGzBE,EAAc7P,OAASzB,EAAOG,KAAKC,WAAmC,MAAtB+Q,EAAO3X,aAChDqM,EAA2BsL,EAAO3X,YAAa4X,gGEhG9D,aAkBI,IAjBA,WAA6C,GAC7C,cAAgD,EAgBhD,mECmDuC,sIDhEnC,WAAQ,sFAGR,WAAQ,oDAEZ,YAAyC,OAAQ,qBAAR,KAAAG,QAAkB1H,EAAM0H,6BAEjE,YAAmC,OAAA7uB,OAASmnB,wBAE5C,WAA+B,OAAnC,EAAmC,iBAA8BnnB,4BAE7D,WAA0B,YAAAkK,4EAE1B,2MCfJ,cAC4C,OA0E5C,cACiB,QAAA/F,EAAM,OAAO,EAAb,EAAb,IAAK,IAAL,EAAU,EAAV,SACIA,EAAM7B,GAAKwsB,EAEf,OAAO3qB,EA9EiC4qB,CAAajmB,MAASxB,GAAOwnB,uHCwiwBrD,uBC9puB0C,oCAqRvC,kBAAyB,8BAgBzB,yBAAwB,oBA4JjC,EAAAnL,KAAA,6BA5ImC,SAQ1B,oBAA0B,gDC74BgB,mBCoBA,oBCnBA,mOC9SlB,8BCVA,sFCI/C,OC2E+F,8BC0E/E,6BAIW,gCCgxCc,yBAHvB,0BAr6BO,4BA8WD,MAAAA,MAAA,sBACA,EAAAA,KAAA,iBA4JA,mCAmZP,2BAbc,MAAAA,MAAA,oBAECA,MAAA,kDC90CqD,+sCJtErF,gCKPqC,4BAAC,eAClC,sBAAsB,EACtB,mBACA,iBAA6B,KAC7B,mBAAsC,KACtC,uBAAyC,kCAEzC,sCAgEJ,iKA1DgB,EADR,qJAES,oBADD,EACQ,yDAKhB,QADiC,kBCuBrB,YADR,6CDtBA,EAAJ,CAAApO,EAAA,uBACA,CAGA,IEoCY,IFpCZ,+BAEyB,MAAjB,EAAiB,EAGjB,EAAI,WAAJ,gCAGI,cAAQ,4BAKR,OAAc,KACd,SAAqC,IACrC,IAAgB,KAChB,kBAEA,IAAgB,EAIpB,kDAOI,SAAAyZ,EAAA,wCGThB,iBHSgB,4CALJ,EAAI,EAAAC,0EAeM,MAAlB,GAAkBC,IAAA,MAClB,EAAI,aAAuB,mBAA3B,0WAaJ,sMAJJ,wCI7D+B,aAA6E,QAAAC,EAAAA,EAAA,iCAAS,+GAE1E,OAAvC,iDAAuC,wBAKR,aAA6E,QAAAA,EAAAA,EAAA,iCAAS,mHAM/E,iBAA0D,6CAEzD,OAAvC,iDAAuC,kBAIO,iBAA0D,qDAEjE,OAAvC,iDAAuC,kBAII,iBAA0D,kDAE9D,OAAvC,iDAAuC,gBA0BG,yDAIF,uDAYI,2DACrB,OAAvB,+CAAuB,8CCpF3B,eAiB2B,aAA8B,iCAwBzD,aAEqC,4BAYrC,6BCjDA,kBACI,gCH0CJ,uBASI,uCIrDJ,0CAKA,iJCmCA,2CAYI,SAiB2D,aAAY,yCC8L3E,QAOkDC,GAAA,GAAAA,EAAsB,CACpE,IAAI,IAAJ,OACI,EAAS,SACT,EAAS,EAAM,SACf,GCtBG,IDsBH,EACA,OAAI,EAAJ,QAAc,IAAO,aACrB,MAAc,EAAd,cACQ,EAAW,gBACf,OAAgB,IAEhB,EAAI,GAAJ,OACI,EAAoBC,GAAT,IACC,CAEZ,IAAI,EAAY,EACZ,ED3P2C,EC4P3C,IADoB,SAAT,gDACW,SAAV,6CAEZ,OAAI,YAAJ,yDE/PpB,yBR0FA,wBS/GI,ooCPPI,iKAcA,wBA+DyC,qSAxBrC,EAwBqC,sBAvBzC,GIqJ4F,IJpJ5F,KAAI,OAAJ,0BAAA/sB,GACI,aACA,uGAOJ,YAAY,8PCnDZ,OAAU,KAEN,cAAQ,YACJ,6CAEJ,SAAQ,KACJtC,KAAK,WAAS,gEAcf,wBAJH,OADJ,KAAI,cACA,yBAGJ,OAAa,KAET,WAAsB,yBACtB2Q,EAAA,qBACQ,mJHOpB,08BA2EA,yEAYW,OAZX,mBAYiD,0BAEzC,OADA,EAAW,GACX,iBAdR,wBAYW,kBAAsC,uBAZjD,oGS/GI,qDCW2B,gCACf,OAAc,KACd,OAAI,4BAEA,GAAkB,MAAlB,EACA,OAAI,OAAJ,oCACI,WAAW,KAAiB,SAAT,sECvBU,mCA4ErD,wFDjEI,yHAyC6B,SAAA3Q,KAAA,gBAAAA,KAAA,IAAAA,KAAA,wIAKzB,2lBCmBR,sCAqB8B,cAC1B,kCA6DmB,yDAef,uHAvEA,UAEIsvB,EAAA,OAFM,CACV,UAAO,EAAP,4BACI,wBACA,MAAW,OAAI,8BACf,EAAItqB,8EAQZ,mEAMW,oCAFP,gEACA,IAAc,YAEV,KAAoB,SACpB,wEAOJ,YAEc,EAAJ,KAHN,EAAM,IACC,CAED,UADV,kCACU,aAAN,EAAM,wEAKd,gDAII,UAOwB,MAPd,CACV,IAAO,KAAP,wBACI,OAAK,MAAuB,EAAO,SACnC,MAAW,OAAI,qDACf,EAAIA,uDAQZ,0HAGA,mFAEA,0DAYsB,gBANlB,EAAQ,mBACR,GAAAuQ,EAAe,GAEf,GADA,+BACW,oBAAgB,OAAS,yBAAT,KAA3B,MAAK,ECrFL,QDsFM,gBCpGK,2ICpEnB,KA0CoC,6BAEpC,2GAK0C,yBAAqB,qCAArB,6BAAqB,6BAAW,gCClD1E,kBACI,SAAU,4CASd,0DA2BA,kBAkBI,mDAAAga,IAD+E,GAC/D,sBAChB,uCAAAA,EAAA,yDrBwBkB,KA8BlB,2GkBqE8C,kB1B09Y9B,OADhB,Y0Bz9YmD,c1B09YnD,QAAgB,OAAhB,qS4B5oZJ,0MA4CA,2hBpB2CQ,MAAI,gFAAJ,uIAIJ,sGAEA,gEAOA,0IAIA,2MAGA,wHAEA,wCsB9DkC,cAA4C,YAAlB,sBAC5D,oBAAiC,oCAAAC,IAAA,oBAAAA,IAAA,EACjC,iBAAmC,iBAAU,kCCyH7C,GA7CA,KA6CA,OAtCI,MAAI,EAAJ,6BAAgB,EAAa,KAC7B,MAAI,kFAAwB,MAAa,EAG7C,aAGyBC,EAAA,KAEzB,UAGwB,gBA0BxB,sLDnHI,OAAY,sBACZ,IAAI,eACA,MAAK,SAAS,WAAa,mLC8FnC,+FAEA,yIAQA,2JAIA,iSAGA,mVAEA,oEC3KiD,uBACjD,+CA4BwD,uBACxD,6CnBtB6B,KA2D7B,kLoB1DA,sGAOA,gKA4BA,qGAOA,6YpBvBA,qCAWgB,sBADR,uDAVR,oEAsBQ,WADE,4EAKV,IAOQ,WADE,6JAYN,2KASA,0JAdJ,oCAwBsB,gCAU1B,gCASA,wBAQI,MAAI,EAAAlsB,MAAA,8BCrHwB,QAACmZ,EAAA,sCAAkB,+FD8F3C,2JAEA,oNAxFJ,OAPJ,6abquFA,MAIiB,OAAN,uBACH,8BAAK,IACL,KAAK,0TkCzpFb,wBAEI,MAAI,kBAAY,gOC0BpB,UAWK,OAAD,OAAC,EAAD,2dlBvCJ,qEC/E6D,OADzD,iDACyD,gDCX7D,wyDiBgCkD,uEnB8C9C,KAAJ,IAAO,EAAY,QAAY,QAAG,IAAO,EACzB,MAAZ,MF9BJ,YsB5C2E,MxBkKhE,aADP,WwBhKA,QxBgKA,mBACO,cyB7HkC,ICsXS,EAAW0I,IC1ZlC,GAAS,ID0ZyB,mBErVnC,qBpB2PiC,qBqB5LxB,sChCixCF,sBrBh6CvB,iBAAW,CAAC,OAAZ,esDDVsK,EAA2B,CAAC,EAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBzuB,IAAjB0uB,EACH,OAAOA,EAAajwB,QAGrB,IAAIC,EAAS6vB,EAAyBE,GAAY,CAGjDhwB,QAAS,CAAC,GAOX,OAHAkwB,EAAoBF,GAAU7mB,KAAKlJ,EAAOD,QAASC,EAAQA,EAAOD,QAAS+vB,GAGpE9vB,EAAOD,OACf,Q1FtBIM,EAAWkD,OAAOogB,eAAkBnT,GAASjN,OAAOogB,eAAenT,GAASA,GAASA,EAAa,UAQtGsf,EAAoBta,EAAI,SAAS9R,EAAOwsB,GAEvC,GADU,EAAPA,IAAUxsB,EAAQvD,KAAKuD,IAChB,EAAPwsB,EAAU,OAAOxsB,EACpB,GAAoB,iBAAVA,GAAsBA,EAAO,CACtC,GAAW,EAAPwsB,GAAaxsB,EAAMysB,WAAY,OAAOzsB,EAC1C,GAAW,GAAPwsB,GAAoC,mBAAfxsB,EAAMoV,KAAqB,OAAOpV,CAC5D,CACA,IAAI0sB,EAAK7sB,OAAO8I,OAAO,MACvByjB,EAAoBva,EAAE6a,GACtB,IAAIC,EAAM,CAAC,EACXjwB,EAAiBA,GAAkB,CAAC,KAAMC,EAAS,CAAC,GAAIA,EAAS,IAAKA,EAASA,IAC/E,IAAI,IAAI2U,EAAiB,EAAPkb,GAAYxsB,EAAyB,iBAAXsR,KAAyB5U,EAAe4D,QAAQgR,GAAUA,EAAU3U,EAAS2U,GACxHzR,OAAO+sB,oBAAoBtb,GAASjT,SAASL,GAAS2uB,EAAI3uB,GAAO,IAAOgC,EAAMhC,KAI/E,OAFA2uB,EAAa,QAAI,IAAM,EACvBP,EAAoBpY,EAAE0Y,EAAIC,GACnBD,CACR,E2FxBAN,EAAoBpY,EAAI,CAAC3X,EAASwwB,KACjC,IAAI,IAAI7uB,KAAO6uB,EACXT,EAAoBnN,EAAE4N,EAAY7uB,KAASouB,EAAoBnN,EAAE5iB,EAAS2B,IAC5E6B,OAAOiR,eAAezU,EAAS2B,EAAK,CAAEyhB,YAAY,EAAM/a,IAAKmoB,EAAW7uB,IAE1E,ECNDouB,EAAoBnN,EAAI,CAACnS,EAAKoB,IAAUrO,OAAO3B,UAAU6P,eAAevI,KAAKsH,EAAKoB,GCClFke,EAAoBva,EAAKxV,IACH,oBAAXmV,QAA0BA,OAAOsb,aAC1CjtB,OAAOiR,eAAezU,EAASmV,OAAOsb,YAAa,CAAE9sB,MAAO,WAE7DH,OAAOiR,eAAezU,EAAS,aAAc,CAAE2D,OAAO,GAAO,ECFpCosB,EAAoB","sources":["webpack://fullStackWithKtor/webpack/universalModuleDefinition","webpack://fullStackWithKtor/webpack/runtime/create fake namespace object","webpack://fullStackWithKtor/../../node_modules/@emotion/sheet/dist/emotion-sheet.browser.esm.js","webpack://fullStackWithKtor/../../node_modules/stylis/src/Utility.js","webpack://fullStackWithKtor/../../node_modules/stylis/src/Tokenizer.js","webpack://fullStackWithKtor/../../node_modules/stylis/src/Enum.js","webpack://fullStackWithKtor/../../node_modules/stylis/src/Serializer.js","webpack://fullStackWithKtor/../../node_modules/stylis/src/Parser.js","webpack://fullStackWithKtor/../../node_modules/@emotion/cache/dist/emotion-cache.browser.esm.js","webpack://fullStackWithKtor/../../node_modules/stylis/src/Middleware.js","webpack://fullStackWithKtor/../../node_modules/@emotion/css/create-instance/dist/emotion-css-create-instance.esm.js","webpack://fullStackWithKtor/../../node_modules/@emotion/css/dist/emotion-css.esm.js","webpack://fullStackWithKtor/../../node_modules/@emotion/memoize/dist/emotion-memoize.esm.js","webpack://fullStackWithKtor/../../node_modules/@emotion/hash/dist/emotion-hash.esm.js","webpack://fullStackWithKtor/../../node_modules/@emotion/unitless/dist/emotion-unitless.esm.js","webpack://fullStackWithKtor/../../node_modules/@emotion/serialize/dist/emotion-serialize.browser.esm.js","webpack://fullStackWithKtor/../../node_modules/@babel/runtime/helpers/esm/extends.js","webpack://fullStackWithKtor/../../node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js","webpack://fullStackWithKtor/../../node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.browser.esm.js","webpack://fullStackWithKtor/../../node_modules/@emotion/react/dist/emotion-element-6a883da9.browser.esm.js","webpack://fullStackWithKtor/../../node_modules/@emotion/styled/base/dist/emotion-styled-base.browser.esm.js","webpack://fullStackWithKtor/../../node_modules/@emotion/styled/dist/emotion-styled.browser.esm.js","webpack://fullStackWithKtor/../../node_modules/@emotion/utils/dist/emotion-utils.browser.esm.js","webpack://fullStackWithKtor/../../node_modules/react/cjs/react.production.min.js","webpack://fullStackWithKtor/../../node_modules/react/index.js","webpack://fullStackWithKtor/../kotlin/kotlin-emotion.js","webpack://fullStackWithKtor/../../../../src/jsMain/kotlin/Client.kt","webpack://fullStackWithKtor/./kotlin/src/kotlin/util/Standard.kt","webpack://fullStackWithKtor/../../../../src/jsMain/kotlin/Welcome.kt","webpack://fullStackWithKtor/../kotlin/kotlin-csstype.js","webpack://fullStackWithKtor/../kotlin/kotlin-react-core.js","webpack://fullStackWithKtor/./kotlin-dce/kotlin-csstype.js","webpack://fullStackWithKtor/./kotlin-dce/kotlin-emotion.js","webpack://fullStackWithKtor/./kotlin-dce/kotlin-extensions.js","webpack://fullStackWithKtor/./kotlin-dce/kotlin-react-core.js","webpack://fullStackWithKtor/./kotlin-dce/kotlin-react-dom.js","webpack://fullStackWithKtor/./kotlin-dce/kotlin-react.js","webpack://fullStackWithKtor/./kotlin-dce/wrapper.js","webpack://fullStackWithKtor/./kotlin-dce/js/arrayUtils.js","webpack://fullStackWithKtor/./kotlin-dce/js/conversions.js","webpack://fullStackWithKtor/./kotlin-dce/js/core.js","webpack://fullStackWithKtor/./kotlin-dce/js/misc.js","webpack://fullStackWithKtor/./kotlin-dce/js/polyfills.js","webpack://fullStackWithKtor/./kotlin-dce/js/markerFunctions.js","webpack://fullStackWithKtor/./kotlin-dce/js/rtti.js","webpack://fullStackWithKtor/./kotlin-dce/js/long.js","webpack://fullStackWithKtor/./kotlin-dce/runtime/Enum.kt","webpack://fullStackWithKtor/./kotlin-dce/runtime/arrayUtils.kt","webpack://fullStackWithKtor/./kotlin-dce/common/src/generated/_Arrays.kt","webpack://fullStackWithKtor/./kotlin-dce/common/src/generated/_Ranges.kt","webpack://fullStackWithKtor/./kotlin-dce/unsigned/src/kotlin/UByte.kt","webpack://fullStackWithKtor/./kotlin-dce/unsigned/src/kotlin/UInt.kt","webpack://fullStackWithKtor/./kotlin-dce/unsigned/src/kotlin/UShort.kt","webpack://fullStackWithKtor/./kotlin-dce/src/kotlin/collections/Collections.kt","webpack://fullStackWithKtor/./kotlin-dce/src/kotlin/collections/Maps.kt","webpack://fullStackWithKtor/./kotlin-dce/builtin-sources/Unit.kt","webpack://fullStackWithKtor/./kotlin-dce/src/kotlin/ranges/PrimitiveRanges.kt","webpack://fullStackWithKtor/./kotlin-dce/src/kotlin/text/StringNumberConversions.kt","webpack://fullStackWithKtor/./kotlin-dce/src/kotlin/time/Duration.kt","webpack://fullStackWithKtor/./kotlin-dce/unsigned/src/kotlin/UnsignedUtils.kt","webpack://fullStackWithKtor/./kotlin-dce/src/kotlin/coroutines/CoroutineImpl.kt","webpack://fullStackWithKtor/./kotlin-dce/src/kotlin/util/Result.kt","webpack://fullStackWithKtor/./kotlin-dce/src/kotlin/util/Standard.kt","webpack://fullStackWithKtor/./kotlin-dce/src/kotlin/coroutines/Continuation.kt","webpack://fullStackWithKtor/./kotlin-dce/src/kotlin/exceptions.kt","webpack://fullStackWithKtor/./kotlin-dce/js/src/kotlin/console.kt","webpack://fullStackWithKtor/./kotlin-dce/js/src/kotlin/coroutines/SafeContinuationJs.kt","webpack://fullStackWithKtor/./kotlin-dce/js/src/kotlin/exceptionUtils.kt","webpack://fullStackWithKtor/./kotlin-dce/js/src/kotlin/text/char.kt","webpack://fullStackWithKtor/./kotlin-dce/js/src/kotlin/text/string.kt","webpack://fullStackWithKtor/./kotlin-dce/js/src/generated/_ComparisonsJs.kt","webpack://fullStackWithKtor/./kotlin-dce/src/kotlin/collections/PrimitiveIterators.kt","webpack://fullStackWithKtor/./kotlin-dce/src/kotlin/coroutines/ContinuationInterceptor.kt","webpack://fullStackWithKtor/./kotlin-dce/src/kotlin/coroutines/CoroutineContext.kt","webpack://fullStackWithKtor/./kotlin-dce/src/kotlin/coroutines/CoroutineContextImpl.kt","webpack://fullStackWithKtor/./kotlin-dce/src/kotlin/util/Preconditions.kt","webpack://fullStackWithKtor/./kotlin-dce/src/kotlin/coroutines/intrinsics/Intrinsics.kt","webpack://fullStackWithKtor/./kotlin-dce/src/kotlin/internal/progressionUtil.kt","webpack://fullStackWithKtor/./kotlin-dce/src/kotlin/ranges/ProgressionIterators.kt","webpack://fullStackWithKtor/./kotlin-dce/src/kotlin/ranges/Progressions.kt","webpack://fullStackWithKtor/./kotlin-dce/src/kotlin/ranges/Ranges.kt","webpack://fullStackWithKtor/./kotlin-dce/src/kotlin/ranges/Range.kt","webpack://fullStackWithKtor/./kotlin-dce/src/kotlin/builtins.kt","webpack://fullStackWithKtor/./kotlin-dce/src/kotlin/coroutines/intrinsics/IntrinsicsJs.kt","webpack://fullStackWithKtor/./kotlin-dce/js/src/kotlin/collections/ArraySorting.kt","webpack://fullStackWithKtor/./kotlin-dce/js/src/kotlin/coroutines/js/internal/EmptyContinuation.kt","webpack://fullStackWithKtor/./kotlin-dce/js/src/kotlin/js/js.math.kt","webpack://fullStackWithKtor/./kotlin-dce/js/src/kotlin/math.kt","webpack://fullStackWithKtor/./kotlin-dce/js/src/kotlin/random/PlatformRandom.kt","webpack://fullStackWithKtor/./kotlin-dce/js/src/kotlin/reflect/primitives.kt","webpack://fullStackWithKtor/./kotlin-dce/js/src/kotlin/text/utf8Encoding.kt","webpack://fullStackWithKtor/webpack/bootstrap","webpack://fullStackWithKtor/webpack/runtime/define property getters","webpack://fullStackWithKtor/webpack/runtime/hasOwnProperty shorthand","webpack://fullStackWithKtor/webpack/runtime/make namespace object","webpack://fullStackWithKtor/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"fullStackWithKtor\"] = factory();\n\telse\n\t\troot[\"fullStackWithKtor\"] = factory();\n})(this, () => {\nreturn ","var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);\nvar leafPrototypes;\n// create a fake namespace object\n// mode & 1: value is a module id, require it\n// mode & 2: merge all properties of value into the ns\n// mode & 4: return value when already ns object\n// mode & 16: return value when it's Promise-like\n// mode & 8|1: behave like require\n__webpack_require__.t = function(value, mode) {\n\tif(mode & 1) value = this(value);\n\tif(mode & 8) return value;\n\tif(typeof value === 'object' && value) {\n\t\tif((mode & 4) && value.__esModule) return value;\n\t\tif((mode & 16) && typeof value.then === 'function') return value;\n\t}\n\tvar ns = Object.create(null);\n\t__webpack_require__.r(ns);\n\tvar def = {};\n\tleafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];\n\tfor(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {\n\t\tObject.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));\n\t}\n\tdef['default'] = () => (value);\n\t__webpack_require__.d(ns, def);\n\treturn ns;\n};","/*\n\nBased off glamor's StyleSheet, thanks Sunil ❤️\n\nhigh performance StyleSheet for css-in-js systems\n\n- uses multiple style tags behind the scenes for millions of rules\n- uses `insertRule` for appending in production for *much* faster performance\n\n// usage\n\nimport { StyleSheet } from '@emotion/sheet'\n\nlet styleSheet = new StyleSheet({ key: '', container: document.head })\n\nstyleSheet.insert('#box { border: 1px solid red; }')\n- appends a css rule into the stylesheet\n\nstyleSheet.flush()\n- empties the stylesheet of all its contents\n\n*/\n// $FlowFixMe\nfunction sheetForTag(tag) {\n  if (tag.sheet) {\n    // $FlowFixMe\n    return tag.sheet;\n  } // this weirdness brought to you by firefox\n\n  /* istanbul ignore next */\n\n\n  for (var i = 0; i < document.styleSheets.length; i++) {\n    if (document.styleSheets[i].ownerNode === tag) {\n      // $FlowFixMe\n      return document.styleSheets[i];\n    }\n  }\n}\n\nfunction createStyleElement(options) {\n  var tag = document.createElement('style');\n  tag.setAttribute('data-emotion', options.key);\n\n  if (options.nonce !== undefined) {\n    tag.setAttribute('nonce', options.nonce);\n  }\n\n  tag.appendChild(document.createTextNode(''));\n  tag.setAttribute('data-s', '');\n  return tag;\n}\n\nvar StyleSheet = /*#__PURE__*/function () {\n  // Using Node instead of HTMLElement since container may be a ShadowRoot\n  function StyleSheet(options) {\n    var _this = this;\n\n    this._insertTag = function (tag) {\n      var before;\n\n      if (_this.tags.length === 0) {\n        if (_this.insertionPoint) {\n          before = _this.insertionPoint.nextSibling;\n        } else if (_this.prepend) {\n          before = _this.container.firstChild;\n        } else {\n          before = _this.before;\n        }\n      } else {\n        before = _this.tags[_this.tags.length - 1].nextSibling;\n      }\n\n      _this.container.insertBefore(tag, before);\n\n      _this.tags.push(tag);\n    };\n\n    this.isSpeedy = options.speedy === undefined ? process.env.NODE_ENV === 'production' : options.speedy;\n    this.tags = [];\n    this.ctr = 0;\n    this.nonce = options.nonce; // key is the value of the data-emotion attribute, it's used to identify different sheets\n\n    this.key = options.key;\n    this.container = options.container;\n    this.prepend = options.prepend;\n    this.insertionPoint = options.insertionPoint;\n    this.before = null;\n  }\n\n  var _proto = StyleSheet.prototype;\n\n  _proto.hydrate = function hydrate(nodes) {\n    nodes.forEach(this._insertTag);\n  };\n\n  _proto.insert = function insert(rule) {\n    // the max length is how many rules we have per style tag, it's 65000 in speedy mode\n    // it's 1 in dev because we insert source maps that map a single rule to a location\n    // and you can only have one source map per style tag\n    if (this.ctr % (this.isSpeedy ? 65000 : 1) === 0) {\n      this._insertTag(createStyleElement(this));\n    }\n\n    var tag = this.tags[this.tags.length - 1];\n\n    if (process.env.NODE_ENV !== 'production') {\n      var isImportRule = rule.charCodeAt(0) === 64 && rule.charCodeAt(1) === 105;\n\n      if (isImportRule && this._alreadyInsertedOrderInsensitiveRule) {\n        // this would only cause problem in speedy mode\n        // but we don't want enabling speedy to affect the observable behavior\n        // so we report this error at all times\n        console.error(\"You're attempting to insert the following rule:\\n\" + rule + '\\n\\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules.');\n      }\n      this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !isImportRule;\n    }\n\n    if (this.isSpeedy) {\n      var sheet = sheetForTag(tag);\n\n      try {\n        // this is the ultrafast version, works across browsers\n        // the big drawback is that the css won't be editable in devtools\n        sheet.insertRule(rule, sheet.cssRules.length);\n      } catch (e) {\n        if (process.env.NODE_ENV !== 'production' && !/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(rule)) {\n          console.error(\"There was a problem inserting the following rule: \\\"\" + rule + \"\\\"\", e);\n        }\n      }\n    } else {\n      tag.appendChild(document.createTextNode(rule));\n    }\n\n    this.ctr++;\n  };\n\n  _proto.flush = function flush() {\n    // $FlowFixMe\n    this.tags.forEach(function (tag) {\n      return tag.parentNode && tag.parentNode.removeChild(tag);\n    });\n    this.tags = [];\n    this.ctr = 0;\n\n    if (process.env.NODE_ENV !== 'production') {\n      this._alreadyInsertedOrderInsensitiveRule = false;\n    }\n  };\n\n  return StyleSheet;\n}();\n\nexport { StyleSheet };\n","/**\n * @param {number}\n * @return {number}\n */\nexport var abs = Math.abs\n\n/**\n * @param {number}\n * @return {string}\n */\nexport var from = String.fromCharCode\n\n/**\n * @param {object}\n * @return {object}\n */\nexport var assign = Object.assign\n\n/**\n * @param {string} value\n * @param {number} length\n * @return {number}\n */\nexport function hash (value, length) {\n\treturn charat(value, 0) ^ 45 ? (((((((length << 2) ^ charat(value, 0)) << 2) ^ charat(value, 1)) << 2) ^ charat(value, 2)) << 2) ^ charat(value, 3) : 0\n}\n\n/**\n * @param {string} value\n * @return {string}\n */\nexport function trim (value) {\n\treturn value.trim()\n}\n\n/**\n * @param {string} value\n * @param {RegExp} pattern\n * @return {string?}\n */\nexport function match (value, pattern) {\n\treturn (value = pattern.exec(value)) ? value[0] : value\n}\n\n/**\n * @param {string} value\n * @param {(string|RegExp)} pattern\n * @param {string} replacement\n * @return {string}\n */\nexport function replace (value, pattern, replacement) {\n\treturn value.replace(pattern, replacement)\n}\n\n/**\n * @param {string} value\n * @param {string} search\n * @return {number}\n */\nexport function indexof (value, search) {\n\treturn value.indexOf(search)\n}\n\n/**\n * @param {string} value\n * @param {number} index\n * @return {number}\n */\nexport function charat (value, index) {\n\treturn value.charCodeAt(index) | 0\n}\n\n/**\n * @param {string} value\n * @param {number} begin\n * @param {number} end\n * @return {string}\n */\nexport function substr (value, begin, end) {\n\treturn value.slice(begin, end)\n}\n\n/**\n * @param {string} value\n * @return {number}\n */\nexport function strlen (value) {\n\treturn value.length\n}\n\n/**\n * @param {any[]} value\n * @return {number}\n */\nexport function sizeof (value) {\n\treturn value.length\n}\n\n/**\n * @param {any} value\n * @param {any[]} array\n * @return {any}\n */\nexport function append (value, array) {\n\treturn array.push(value), value\n}\n\n/**\n * @param {string[]} array\n * @param {function} callback\n * @return {string}\n */\nexport function combine (array, callback) {\n\treturn array.map(callback).join('')\n}\n","import {from, trim, charat, strlen, substr, append, assign} from './Utility.js'\n\nexport var line = 1\nexport var column = 1\nexport var length = 0\nexport var position = 0\nexport var character = 0\nexport var characters = ''\n\n/**\n * @param {string} value\n * @param {object | null} root\n * @param {object | null} parent\n * @param {string} type\n * @param {string[] | string} props\n * @param {object[] | string} children\n * @param {number} length\n */\nexport function node (value, root, parent, type, props, children, length) {\n\treturn {value: value, root: root, parent: parent, type: type, props: props, children: children, line: line, column: column, length: length, return: ''}\n}\n\n/**\n * @param {object} root\n * @param {object} props\n * @return {object}\n */\nexport function copy (root, props) {\n\treturn assign(node('', null, null, '', null, null, 0), root, {length: -root.length}, props)\n}\n\n/**\n * @return {number}\n */\nexport function char () {\n\treturn character\n}\n\n/**\n * @return {number}\n */\nexport function prev () {\n\tcharacter = position > 0 ? charat(characters, --position) : 0\n\n\tif (column--, character === 10)\n\t\tcolumn = 1, line--\n\n\treturn character\n}\n\n/**\n * @return {number}\n */\nexport function next () {\n\tcharacter = position < length ? charat(characters, position++) : 0\n\n\tif (column++, character === 10)\n\t\tcolumn = 1, line++\n\n\treturn character\n}\n\n/**\n * @return {number}\n */\nexport function peek () {\n\treturn charat(characters, position)\n}\n\n/**\n * @return {number}\n */\nexport function caret () {\n\treturn position\n}\n\n/**\n * @param {number} begin\n * @param {number} end\n * @return {string}\n */\nexport function slice (begin, end) {\n\treturn substr(characters, begin, end)\n}\n\n/**\n * @param {number} type\n * @return {number}\n */\nexport function token (type) {\n\tswitch (type) {\n\t\t// \\0 \\t \\n \\r \\s whitespace token\n\t\tcase 0: case 9: case 10: case 13: case 32:\n\t\t\treturn 5\n\t\t// ! + , / > @ ~ isolate token\n\t\tcase 33: case 43: case 44: case 47: case 62: case 64: case 126:\n\t\t// ; { } breakpoint token\n\t\tcase 59: case 123: case 125:\n\t\t\treturn 4\n\t\t// : accompanied token\n\t\tcase 58:\n\t\t\treturn 3\n\t\t// \" ' ( [ opening delimit token\n\t\tcase 34: case 39: case 40: case 91:\n\t\t\treturn 2\n\t\t// ) ] closing delimit token\n\t\tcase 41: case 93:\n\t\t\treturn 1\n\t}\n\n\treturn 0\n}\n\n/**\n * @param {string} value\n * @return {any[]}\n */\nexport function alloc (value) {\n\treturn line = column = 1, length = strlen(characters = value), position = 0, []\n}\n\n/**\n * @param {any} value\n * @return {any}\n */\nexport function dealloc (value) {\n\treturn characters = '', value\n}\n\n/**\n * @param {number} type\n * @return {string}\n */\nexport function delimit (type) {\n\treturn trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)))\n}\n\n/**\n * @param {string} value\n * @return {string[]}\n */\nexport function tokenize (value) {\n\treturn dealloc(tokenizer(alloc(value)))\n}\n\n/**\n * @param {number} type\n * @return {string}\n */\nexport function whitespace (type) {\n\twhile (character = peek())\n\t\tif (character < 33)\n\t\t\tnext()\n\t\telse\n\t\t\tbreak\n\n\treturn token(type) > 2 || token(character) > 3 ? '' : ' '\n}\n\n/**\n * @param {string[]} children\n * @return {string[]}\n */\nexport function tokenizer (children) {\n\twhile (next())\n\t\tswitch (token(character)) {\n\t\t\tcase 0: append(identifier(position - 1), children)\n\t\t\t\tbreak\n\t\t\tcase 2: append(delimit(character), children)\n\t\t\t\tbreak\n\t\t\tdefault: append(from(character), children)\n\t\t}\n\n\treturn children\n}\n\n/**\n * @param {number} index\n * @param {number} count\n * @return {string}\n */\nexport function escaping (index, count) {\n\twhile (--count && next())\n\t\t// not 0-9 A-F a-f\n\t\tif (character < 48 || character > 102 || (character > 57 && character < 65) || (character > 70 && character < 97))\n\t\t\tbreak\n\n\treturn slice(index, caret() + (count < 6 && peek() == 32 && next() == 32))\n}\n\n/**\n * @param {number} type\n * @return {number}\n */\nexport function delimiter (type) {\n\twhile (next())\n\t\tswitch (character) {\n\t\t\t// ] ) \" '\n\t\t\tcase type:\n\t\t\t\treturn position\n\t\t\t// \" '\n\t\t\tcase 34: case 39:\n\t\t\t\tif (type !== 34 && type !== 39)\n\t\t\t\t\tdelimiter(character)\n\t\t\t\tbreak\n\t\t\t// (\n\t\t\tcase 40:\n\t\t\t\tif (type === 41)\n\t\t\t\t\tdelimiter(type)\n\t\t\t\tbreak\n\t\t\t// \\\n\t\t\tcase 92:\n\t\t\t\tnext()\n\t\t\t\tbreak\n\t\t}\n\n\treturn position\n}\n\n/**\n * @param {number} type\n * @param {number} index\n * @return {number}\n */\nexport function commenter (type, index) {\n\twhile (next())\n\t\t// //\n\t\tif (type + character === 47 + 10)\n\t\t\tbreak\n\t\t// /*\n\t\telse if (type + character === 42 + 42 && peek() === 47)\n\t\t\tbreak\n\n\treturn '/*' + slice(index, position - 1) + '*' + from(type === 47 ? type : next())\n}\n\n/**\n * @param {number} index\n * @return {string}\n */\nexport function identifier (index) {\n\twhile (!token(peek()))\n\t\tnext()\n\n\treturn slice(index, position)\n}\n","export var MS = '-ms-'\nexport var MOZ = '-moz-'\nexport var WEBKIT = '-webkit-'\n\nexport var COMMENT = 'comm'\nexport var RULESET = 'rule'\nexport var DECLARATION = 'decl'\n\nexport var PAGE = '@page'\nexport var MEDIA = '@media'\nexport var IMPORT = '@import'\nexport var CHARSET = '@charset'\nexport var VIEWPORT = '@viewport'\nexport var SUPPORTS = '@supports'\nexport var DOCUMENT = '@document'\nexport var NAMESPACE = '@namespace'\nexport var KEYFRAMES = '@keyframes'\nexport var FONT_FACE = '@font-face'\nexport var COUNTER_STYLE = '@counter-style'\nexport var FONT_FEATURE_VALUES = '@font-feature-values'\n","import {IMPORT, COMMENT, RULESET, DECLARATION, KEYFRAMES} from './Enum.js'\nimport {strlen, sizeof} from './Utility.js'\n\n/**\n * @param {object[]} children\n * @param {function} callback\n * @return {string}\n */\nexport function serialize (children, callback) {\n\tvar output = ''\n\tvar length = sizeof(children)\n\n\tfor (var i = 0; i < length; i++)\n\t\toutput += callback(children[i], i, children, callback) || ''\n\n\treturn output\n}\n\n/**\n * @param {object} element\n * @param {number} index\n * @param {object[]} children\n * @param {function} callback\n * @return {string}\n */\nexport function stringify (element, index, children, callback) {\n\tswitch (element.type) {\n\t\tcase IMPORT: case DECLARATION: return element.return = element.return || element.value\n\t\tcase COMMENT: return ''\n\t\tcase KEYFRAMES: return element.return = element.value + '{' + serialize(element.children, callback) + '}'\n\t\tcase RULESET: element.value = element.props.join(',')\n\t}\n\n\treturn strlen(children = serialize(element.children, callback)) ? element.return = element.value + '{' + children + '}' : ''\n}\n","import {COMMENT, RULESET, DECLARATION} from './Enum.js'\nimport {abs, charat, trim, from, sizeof, strlen, substr, append, replace, indexof} from './Utility.js'\nimport {node, char, prev, next, peek, caret, alloc, dealloc, delimit, whitespace, escaping, identifier, commenter} from './Tokenizer.js'\n\n/**\n * @param {string} value\n * @return {object[]}\n */\nexport function compile (value) {\n\treturn dealloc(parse('', null, null, null, [''], value = alloc(value), 0, [0], value))\n}\n\n/**\n * @param {string} value\n * @param {object} root\n * @param {object?} parent\n * @param {string[]} rule\n * @param {string[]} rules\n * @param {string[]} rulesets\n * @param {number[]} pseudo\n * @param {number[]} points\n * @param {string[]} declarations\n * @return {object}\n */\nexport function parse (value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {\n\tvar index = 0\n\tvar offset = 0\n\tvar length = pseudo\n\tvar atrule = 0\n\tvar property = 0\n\tvar previous = 0\n\tvar variable = 1\n\tvar scanning = 1\n\tvar ampersand = 1\n\tvar character = 0\n\tvar type = ''\n\tvar props = rules\n\tvar children = rulesets\n\tvar reference = rule\n\tvar characters = type\n\n\twhile (scanning)\n\t\tswitch (previous = character, character = next()) {\n\t\t\t// (\n\t\t\tcase 40:\n\t\t\t\tif (previous != 108 && charat(characters, length - 1) == 58) {\n\t\t\t\t\tif (indexof(characters += replace(delimit(character), '&', '&\\f'), '&\\f') != -1)\n\t\t\t\t\t\tampersand = -1\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t// \" ' [\n\t\t\tcase 34: case 39: case 91:\n\t\t\t\tcharacters += delimit(character)\n\t\t\t\tbreak\n\t\t\t// \\t \\n \\r \\s\n\t\t\tcase 9: case 10: case 13: case 32:\n\t\t\t\tcharacters += whitespace(previous)\n\t\t\t\tbreak\n\t\t\t// \\\n\t\t\tcase 92:\n\t\t\t\tcharacters += escaping(caret() - 1, 7)\n\t\t\t\tcontinue\n\t\t\t// /\n\t\t\tcase 47:\n\t\t\t\tswitch (peek()) {\n\t\t\t\t\tcase 42: case 47:\n\t\t\t\t\t\tappend(comment(commenter(next(), caret()), root, parent), declarations)\n\t\t\t\t\t\tbreak\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tcharacters += '/'\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t// {\n\t\t\tcase 123 * variable:\n\t\t\t\tpoints[index++] = strlen(characters) * ampersand\n\t\t\t// } ; \\0\n\t\t\tcase 125 * variable: case 59: case 0:\n\t\t\t\tswitch (character) {\n\t\t\t\t\t// \\0 }\n\t\t\t\t\tcase 0: case 125: scanning = 0\n\t\t\t\t\t// ;\n\t\t\t\t\tcase 59 + offset:\n\t\t\t\t\t\tif (property > 0 && (strlen(characters) - length))\n\t\t\t\t\t\t\tappend(property > 32 ? declaration(characters + ';', rule, parent, length - 1) : declaration(replace(characters, ' ', '') + ';', rule, parent, length - 2), declarations)\n\t\t\t\t\t\tbreak\n\t\t\t\t\t// @ ;\n\t\t\t\t\tcase 59: characters += ';'\n\t\t\t\t\t// { rule/at-rule\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tappend(reference = ruleset(characters, root, parent, index, offset, rules, points, type, props = [], children = [], length), rulesets)\n\n\t\t\t\t\t\tif (character === 123)\n\t\t\t\t\t\t\tif (offset === 0)\n\t\t\t\t\t\t\t\tparse(characters, root, reference, reference, props, rulesets, length, points, children)\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tswitch (atrule === 99 && charat(characters, 3) === 110 ? 100 : atrule) {\n\t\t\t\t\t\t\t\t\t// d m s\n\t\t\t\t\t\t\t\t\tcase 100: case 109: case 115:\n\t\t\t\t\t\t\t\t\t\tparse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length), children), rules, children, length, points, rule ? props : children)\n\t\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\tparse(characters, reference, reference, reference, [''], children, 0, points, children)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tindex = offset = property = 0, variable = ampersand = 1, type = characters = '', length = pseudo\n\t\t\t\tbreak\n\t\t\t// :\n\t\t\tcase 58:\n\t\t\t\tlength = 1 + strlen(characters), property = previous\n\t\t\tdefault:\n\t\t\t\tif (variable < 1)\n\t\t\t\t\tif (character == 123)\n\t\t\t\t\t\t--variable\n\t\t\t\t\telse if (character == 125 && variable++ == 0 && prev() == 125)\n\t\t\t\t\t\tcontinue\n\n\t\t\t\tswitch (characters += from(character), character * variable) {\n\t\t\t\t\t// &\n\t\t\t\t\tcase 38:\n\t\t\t\t\t\tampersand = offset > 0 ? 1 : (characters += '\\f', -1)\n\t\t\t\t\t\tbreak\n\t\t\t\t\t// ,\n\t\t\t\t\tcase 44:\n\t\t\t\t\t\tpoints[index++] = (strlen(characters) - 1) * ampersand, ampersand = 1\n\t\t\t\t\t\tbreak\n\t\t\t\t\t// @\n\t\t\t\t\tcase 64:\n\t\t\t\t\t\t// -\n\t\t\t\t\t\tif (peek() === 45)\n\t\t\t\t\t\t\tcharacters += delimit(next())\n\n\t\t\t\t\t\tatrule = peek(), offset = length = strlen(type = characters += identifier(caret())), character++\n\t\t\t\t\t\tbreak\n\t\t\t\t\t// -\n\t\t\t\t\tcase 45:\n\t\t\t\t\t\tif (previous === 45 && strlen(characters) == 2)\n\t\t\t\t\t\t\tvariable = 0\n\t\t\t\t}\n\t\t}\n\n\treturn rulesets\n}\n\n/**\n * @param {string} value\n * @param {object} root\n * @param {object?} parent\n * @param {number} index\n * @param {number} offset\n * @param {string[]} rules\n * @param {number[]} points\n * @param {string} type\n * @param {string[]} props\n * @param {string[]} children\n * @param {number} length\n * @return {object}\n */\nexport function ruleset (value, root, parent, index, offset, rules, points, type, props, children, length) {\n\tvar post = offset - 1\n\tvar rule = offset === 0 ? rules : ['']\n\tvar size = sizeof(rule)\n\n\tfor (var i = 0, j = 0, k = 0; i < index; ++i)\n\t\tfor (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x)\n\t\t\tif (z = trim(j > 0 ? rule[x] + ' ' + y : replace(y, /&\\f/g, rule[x])))\n\t\t\t\tprops[k++] = z\n\n\treturn node(value, root, parent, offset === 0 ? RULESET : type, props, children, length)\n}\n\n/**\n * @param {number} value\n * @param {object} root\n * @param {object?} parent\n * @return {object}\n */\nexport function comment (value, root, parent) {\n\treturn node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0)\n}\n\n/**\n * @param {string} value\n * @param {object} root\n * @param {object?} parent\n * @param {number} length\n * @return {object}\n */\nexport function declaration (value, root, parent, length) {\n\treturn node(value, root, parent, DECLARATION, substr(value, 0, length), substr(value, length + 1, -1), length)\n}\n","import { StyleSheet } from '@emotion/sheet';\nimport { dealloc, alloc, next, token, from, peek, delimit, slice, position, RULESET, combine, match, serialize, copy, replace, WEBKIT, MOZ, MS, KEYFRAMES, DECLARATION, hash, charat, strlen, indexof, stringify, COMMENT, rulesheet, middleware, compile } from 'stylis';\nimport '@emotion/weak-memoize';\nimport '@emotion/memoize';\n\nvar identifierWithPointTracking = function identifierWithPointTracking(begin, points, index) {\n  var previous = 0;\n  var character = 0;\n\n  while (true) {\n    previous = character;\n    character = peek(); // &\\f\n\n    if (previous === 38 && character === 12) {\n      points[index] = 1;\n    }\n\n    if (token(character)) {\n      break;\n    }\n\n    next();\n  }\n\n  return slice(begin, position);\n};\n\nvar toRules = function toRules(parsed, points) {\n  // pretend we've started with a comma\n  var index = -1;\n  var character = 44;\n\n  do {\n    switch (token(character)) {\n      case 0:\n        // &\\f\n        if (character === 38 && peek() === 12) {\n          // this is not 100% correct, we don't account for literal sequences here - like for example quoted strings\n          // stylis inserts \\f after & to know when & where it should replace this sequence with the context selector\n          // and when it should just concatenate the outer and inner selectors\n          // it's very unlikely for this sequence to actually appear in a different context, so we just leverage this fact here\n          points[index] = 1;\n        }\n\n        parsed[index] += identifierWithPointTracking(position - 1, points, index);\n        break;\n\n      case 2:\n        parsed[index] += delimit(character);\n        break;\n\n      case 4:\n        // comma\n        if (character === 44) {\n          // colon\n          parsed[++index] = peek() === 58 ? '&\\f' : '';\n          points[index] = parsed[index].length;\n          break;\n        }\n\n      // fallthrough\n\n      default:\n        parsed[index] += from(character);\n    }\n  } while (character = next());\n\n  return parsed;\n};\n\nvar getRules = function getRules(value, points) {\n  return dealloc(toRules(alloc(value), points));\n}; // WeakSet would be more appropriate, but only WeakMap is supported in IE11\n\n\nvar fixedElements = /* #__PURE__ */new WeakMap();\nvar compat = function compat(element) {\n  if (element.type !== 'rule' || !element.parent || // positive .length indicates that this rule contains pseudo\n  // negative .length indicates that this rule has been already prefixed\n  element.length < 1) {\n    return;\n  }\n\n  var value = element.value,\n      parent = element.parent;\n  var isImplicitRule = element.column === parent.column && element.line === parent.line;\n\n  while (parent.type !== 'rule') {\n    parent = parent.parent;\n    if (!parent) return;\n  } // short-circuit for the simplest case\n\n\n  if (element.props.length === 1 && value.charCodeAt(0) !== 58\n  /* colon */\n  && !fixedElements.get(parent)) {\n    return;\n  } // if this is an implicitly inserted rule (the one eagerly inserted at the each new nested level)\n  // then the props has already been manipulated beforehand as they that array is shared between it and its \"rule parent\"\n\n\n  if (isImplicitRule) {\n    return;\n  }\n\n  fixedElements.set(element, true);\n  var points = [];\n  var rules = getRules(value, points);\n  var parentRules = parent.props;\n\n  for (var i = 0, k = 0; i < rules.length; i++) {\n    for (var j = 0; j < parentRules.length; j++, k++) {\n      element.props[k] = points[i] ? rules[i].replace(/&\\f/g, parentRules[j]) : parentRules[j] + \" \" + rules[i];\n    }\n  }\n};\nvar removeLabel = function removeLabel(element) {\n  if (element.type === 'decl') {\n    var value = element.value;\n\n    if ( // charcode for l\n    value.charCodeAt(0) === 108 && // charcode for b\n    value.charCodeAt(2) === 98) {\n      // this ignores label\n      element[\"return\"] = '';\n      element.value = '';\n    }\n  }\n};\nvar ignoreFlag = 'emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason';\n\nvar isIgnoringComment = function isIgnoringComment(element) {\n  return element.type === 'comm' && element.children.indexOf(ignoreFlag) > -1;\n};\n\nvar createUnsafeSelectorsAlarm = function createUnsafeSelectorsAlarm(cache) {\n  return function (element, index, children) {\n    if (element.type !== 'rule' || cache.compat) return;\n    var unsafePseudoClasses = element.value.match(/(:first|:nth|:nth-last)-child/g);\n\n    if (unsafePseudoClasses) {\n      var isNested = element.parent === children[0]; // in nested rules comments become children of the \"auto-inserted\" rule\n      //\n      // considering this input:\n      // .a {\n      //   .b /* comm */ {}\n      //   color: hotpink;\n      // }\n      // we get output corresponding to this:\n      // .a {\n      //   & {\n      //     /* comm */\n      //     color: hotpink;\n      //   }\n      //   .b {}\n      // }\n\n      var commentContainer = isNested ? children[0].children : // global rule at the root level\n      children;\n\n      for (var i = commentContainer.length - 1; i >= 0; i--) {\n        var node = commentContainer[i];\n\n        if (node.line < element.line) {\n          break;\n        } // it is quite weird but comments are *usually* put at `column: element.column - 1`\n        // so we seek *from the end* for the node that is earlier than the rule's `element` and check that\n        // this will also match inputs like this:\n        // .a {\n        //   /* comm */\n        //   .b {}\n        // }\n        //\n        // but that is fine\n        //\n        // it would be the easiest to change the placement of the comment to be the first child of the rule:\n        // .a {\n        //   .b { /* comm */ }\n        // }\n        // with such inputs we wouldn't have to search for the comment at all\n        // TODO: consider changing this comment placement in the next major version\n\n\n        if (node.column < element.column) {\n          if (isIgnoringComment(node)) {\n            return;\n          }\n\n          break;\n        }\n      }\n\n      unsafePseudoClasses.forEach(function (unsafePseudoClass) {\n        console.error(\"The pseudo class \\\"\" + unsafePseudoClass + \"\\\" is potentially unsafe when doing server-side rendering. Try changing it to \\\"\" + unsafePseudoClass.split('-child')[0] + \"-of-type\\\".\");\n      });\n    }\n  };\n};\n\nvar isImportRule = function isImportRule(element) {\n  return element.type.charCodeAt(1) === 105 && element.type.charCodeAt(0) === 64;\n};\n\nvar isPrependedWithRegularRules = function isPrependedWithRegularRules(index, children) {\n  for (var i = index - 1; i >= 0; i--) {\n    if (!isImportRule(children[i])) {\n      return true;\n    }\n  }\n\n  return false;\n}; // use this to remove incorrect elements from further processing\n// so they don't get handed to the `sheet` (or anything else)\n// as that could potentially lead to additional logs which in turn could be overhelming to the user\n\n\nvar nullifyElement = function nullifyElement(element) {\n  element.type = '';\n  element.value = '';\n  element[\"return\"] = '';\n  element.children = '';\n  element.props = '';\n};\n\nvar incorrectImportAlarm = function incorrectImportAlarm(element, index, children) {\n  if (!isImportRule(element)) {\n    return;\n  }\n\n  if (element.parent) {\n    console.error(\"`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles.\");\n    nullifyElement(element);\n  } else if (isPrependedWithRegularRules(index, children)) {\n    console.error(\"`@import` rules can't be after other rules. Please put your `@import` rules before your other rules.\");\n    nullifyElement(element);\n  }\n};\n\n/* eslint-disable no-fallthrough */\n\nfunction prefix(value, length) {\n  switch (hash(value, length)) {\n    // color-adjust\n    case 5103:\n      return WEBKIT + 'print-' + value + value;\n    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)\n\n    case 5737:\n    case 4201:\n    case 3177:\n    case 3433:\n    case 1641:\n    case 4457:\n    case 2921: // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break\n\n    case 5572:\n    case 6356:\n    case 5844:\n    case 3191:\n    case 6645:\n    case 3005: // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,\n\n    case 6391:\n    case 5879:\n    case 5623:\n    case 6135:\n    case 4599:\n    case 4855: // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)\n\n    case 4215:\n    case 6389:\n    case 5109:\n    case 5365:\n    case 5621:\n    case 3829:\n      return WEBKIT + value + value;\n    // appearance, user-select, transform, hyphens, text-size-adjust\n\n    case 5349:\n    case 4246:\n    case 4810:\n    case 6968:\n    case 2756:\n      return WEBKIT + value + MOZ + value + MS + value + value;\n    // flex, flex-direction\n\n    case 6828:\n    case 4268:\n      return WEBKIT + value + MS + value + value;\n    // order\n\n    case 6165:\n      return WEBKIT + value + MS + 'flex-' + value + value;\n    // align-items\n\n    case 5187:\n      return WEBKIT + value + replace(value, /(\\w+).+(:[^]+)/, WEBKIT + 'box-$1$2' + MS + 'flex-$1$2') + value;\n    // align-self\n\n    case 5443:\n      return WEBKIT + value + MS + 'flex-item-' + replace(value, /flex-|-self/, '') + value;\n    // align-content\n\n    case 4675:\n      return WEBKIT + value + MS + 'flex-line-pack' + replace(value, /align-content|flex-|-self/, '') + value;\n    // flex-shrink\n\n    case 5548:\n      return WEBKIT + value + MS + replace(value, 'shrink', 'negative') + value;\n    // flex-basis\n\n    case 5292:\n      return WEBKIT + value + MS + replace(value, 'basis', 'preferred-size') + value;\n    // flex-grow\n\n    case 6060:\n      return WEBKIT + 'box-' + replace(value, '-grow', '') + WEBKIT + value + MS + replace(value, 'grow', 'positive') + value;\n    // transition\n\n    case 4554:\n      return WEBKIT + replace(value, /([^-])(transform)/g, '$1' + WEBKIT + '$2') + value;\n    // cursor\n\n    case 6187:\n      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + '$1'), /(image-set)/, WEBKIT + '$1'), value, '') + value;\n    // background, background-image\n\n    case 5495:\n    case 3959:\n      return replace(value, /(image-set\\([^]*)/, WEBKIT + '$1' + '$`$1');\n    // justify-content\n\n    case 4968:\n      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + 'box-pack:$3' + MS + 'flex-pack:$3'), /s.+-b[^;]+/, 'justify') + WEBKIT + value + value;\n    // (margin|padding)-inline-(start|end)\n\n    case 4095:\n    case 3583:\n    case 4068:\n    case 2532:\n      return replace(value, /(.+)-inline(.+)/, WEBKIT + '$1$2') + value;\n    // (min|max)?(width|height|inline-size|block-size)\n\n    case 8116:\n    case 7059:\n    case 5753:\n    case 5535:\n    case 5445:\n    case 5701:\n    case 4933:\n    case 4677:\n    case 5533:\n    case 5789:\n    case 5021:\n    case 4765:\n      // stretch, max-content, min-content, fill-available\n      if (strlen(value) - 1 - length > 6) switch (charat(value, length + 1)) {\n        // (m)ax-content, (m)in-content\n        case 109:\n          // -\n          if (charat(value, length + 4) !== 45) break;\n        // (f)ill-available, (f)it-content\n\n        case 102:\n          return replace(value, /(.+:)(.+)-([^]+)/, '$1' + WEBKIT + '$2-$3' + '$1' + MOZ + (charat(value, length + 3) == 108 ? '$3' : '$2-$3')) + value;\n        // (s)tretch\n\n        case 115:\n          return ~indexof(value, 'stretch') ? prefix(replace(value, 'stretch', 'fill-available'), length) + value : value;\n      }\n      break;\n    // position: sticky\n\n    case 4949:\n      // (s)ticky?\n      if (charat(value, length + 1) !== 115) break;\n    // display: (flex|inline-flex)\n\n    case 6444:\n      switch (charat(value, strlen(value) - 3 - (~indexof(value, '!important') && 10))) {\n        // stic(k)y\n        case 107:\n          return replace(value, ':', ':' + WEBKIT) + value;\n        // (inline-)?fl(e)x\n\n        case 101:\n          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, '$1' + WEBKIT + (charat(value, 14) === 45 ? 'inline-' : '') + 'box$3' + '$1' + WEBKIT + '$2$3' + '$1' + MS + '$2box$3') + value;\n      }\n\n      break;\n    // writing-mode\n\n    case 5936:\n      switch (charat(value, length + 11)) {\n        // vertical-l(r)\n        case 114:\n          return WEBKIT + value + MS + replace(value, /[svh]\\w+-[tblr]{2}/, 'tb') + value;\n        // vertical-r(l)\n\n        case 108:\n          return WEBKIT + value + MS + replace(value, /[svh]\\w+-[tblr]{2}/, 'tb-rl') + value;\n        // horizontal(-)tb\n\n        case 45:\n          return WEBKIT + value + MS + replace(value, /[svh]\\w+-[tblr]{2}/, 'lr') + value;\n      }\n\n      return WEBKIT + value + MS + value + value;\n  }\n\n  return value;\n}\n\nvar prefixer = function prefixer(element, index, children, callback) {\n  if (element.length > -1) if (!element[\"return\"]) switch (element.type) {\n    case DECLARATION:\n      element[\"return\"] = prefix(element.value, element.length);\n      break;\n\n    case KEYFRAMES:\n      return serialize([copy(element, {\n        value: replace(element.value, '@', '@' + WEBKIT)\n      })], callback);\n\n    case RULESET:\n      if (element.length) return combine(element.props, function (value) {\n        switch (match(value, /(::plac\\w+|:read-\\w+)/)) {\n          // :read-(only|write)\n          case ':read-only':\n          case ':read-write':\n            return serialize([copy(element, {\n              props: [replace(value, /:(read-\\w+)/, ':' + MOZ + '$1')]\n            })], callback);\n          // :placeholder\n\n          case '::placeholder':\n            return serialize([copy(element, {\n              props: [replace(value, /:(plac\\w+)/, ':' + WEBKIT + 'input-$1')]\n            }), copy(element, {\n              props: [replace(value, /:(plac\\w+)/, ':' + MOZ + '$1')]\n            }), copy(element, {\n              props: [replace(value, /:(plac\\w+)/, MS + 'input-$1')]\n            })], callback);\n        }\n\n        return '';\n      });\n  }\n};\n\nvar defaultStylisPlugins = [prefixer];\n\nvar createCache = function createCache(options) {\n  var key = options.key;\n\n  if (process.env.NODE_ENV !== 'production' && !key) {\n    throw new Error(\"You have to configure `key` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.\\n\" + \"If multiple caches share the same key they might \\\"fight\\\" for each other's style elements.\");\n  }\n\n  if ( key === 'css') {\n    var ssrStyles = document.querySelectorAll(\"style[data-emotion]:not([data-s])\"); // get SSRed styles out of the way of React's hydration\n    // document.head is a safe place to move them to(though note document.head is not necessarily the last place they will be)\n    // note this very very intentionally targets all style elements regardless of the key to ensure\n    // that creating a cache works inside of render of a React component\n\n    Array.prototype.forEach.call(ssrStyles, function (node) {\n      // we want to only move elements which have a space in the data-emotion attribute value\n      // because that indicates that it is an Emotion 11 server-side rendered style elements\n      // while we will already ignore Emotion 11 client-side inserted styles because of the :not([data-s]) part in the selector\n      // Emotion 10 client-side inserted styles did not have data-s (but importantly did not have a space in their data-emotion attributes)\n      // so checking for the space ensures that loading Emotion 11 after Emotion 10 has inserted some styles\n      // will not result in the Emotion 10 styles being destroyed\n      var dataEmotionAttribute = node.getAttribute('data-emotion');\n\n      if (dataEmotionAttribute.indexOf(' ') === -1) {\n        return;\n      }\n      document.head.appendChild(node);\n      node.setAttribute('data-s', '');\n    });\n  }\n\n  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;\n\n  if (process.env.NODE_ENV !== 'production') {\n    // $FlowFixMe\n    if (/[^a-z-]/.test(key)) {\n      throw new Error(\"Emotion key must only contain lower case alphabetical characters and - but \\\"\" + key + \"\\\" was passed\");\n    }\n  }\n\n  var inserted = {};\n  var container;\n  var nodesToHydrate = [];\n\n  {\n    container = options.container || document.head;\n    Array.prototype.forEach.call( // this means we will ignore elements which don't have a space in them which\n    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements\n    document.querySelectorAll(\"style[data-emotion^=\\\"\" + key + \" \\\"]\"), function (node) {\n      var attrib = node.getAttribute(\"data-emotion\").split(' '); // $FlowFixMe\n\n      for (var i = 1; i < attrib.length; i++) {\n        inserted[attrib[i]] = true;\n      }\n\n      nodesToHydrate.push(node);\n    });\n  }\n\n  var _insert;\n\n  var omnipresentPlugins = [compat, removeLabel];\n\n  if (process.env.NODE_ENV !== 'production') {\n    omnipresentPlugins.push(createUnsafeSelectorsAlarm({\n      get compat() {\n        return cache.compat;\n      }\n\n    }), incorrectImportAlarm);\n  }\n\n  {\n    var currentSheet;\n    var finalizingPlugins = [stringify, process.env.NODE_ENV !== 'production' ? function (element) {\n      if (!element.root) {\n        if (element[\"return\"]) {\n          currentSheet.insert(element[\"return\"]);\n        } else if (element.value && element.type !== COMMENT) {\n          // insert empty rule in non-production environments\n          // so @emotion/jest can grab `key` from the (JS)DOM for caches without any rules inserted yet\n          currentSheet.insert(element.value + \"{}\");\n        }\n      }\n    } : rulesheet(function (rule) {\n      currentSheet.insert(rule);\n    })];\n    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));\n\n    var stylis = function stylis(styles) {\n      return serialize(compile(styles), serializer);\n    };\n\n    _insert = function insert(selector, serialized, sheet, shouldCache) {\n      currentSheet = sheet;\n\n      if (process.env.NODE_ENV !== 'production' && serialized.map !== undefined) {\n        currentSheet = {\n          insert: function insert(rule) {\n            sheet.insert(rule + serialized.map);\n          }\n        };\n      }\n\n      stylis(selector ? selector + \"{\" + serialized.styles + \"}\" : serialized.styles);\n\n      if (shouldCache) {\n        cache.inserted[serialized.name] = true;\n      }\n    };\n  }\n\n  var cache = {\n    key: key,\n    sheet: new StyleSheet({\n      key: key,\n      container: container,\n      nonce: options.nonce,\n      speedy: options.speedy,\n      prepend: options.prepend,\n      insertionPoint: options.insertionPoint\n    }),\n    nonce: options.nonce,\n    inserted: inserted,\n    registered: {},\n    insert: _insert\n  };\n  cache.sheet.hydrate(nodesToHydrate);\n  return cache;\n};\n\nexport default createCache;\n","import {MS, MOZ, WEBKIT, RULESET, KEYFRAMES, DECLARATION} from './Enum.js'\nimport {match, charat, substr, strlen, sizeof, replace, combine} from './Utility.js'\nimport {copy, tokenize} from './Tokenizer.js'\nimport {serialize} from './Serializer.js'\nimport {prefix} from './Prefixer.js'\n\n/**\n * @param {function[]} collection\n * @return {function}\n */\nexport function middleware (collection) {\n\tvar length = sizeof(collection)\n\n\treturn function (element, index, children, callback) {\n\t\tvar output = ''\n\n\t\tfor (var i = 0; i < length; i++)\n\t\t\toutput += collection[i](element, index, children, callback) || ''\n\n\t\treturn output\n\t}\n}\n\n/**\n * @param {function} callback\n * @return {function}\n */\nexport function rulesheet (callback) {\n\treturn function (element) {\n\t\tif (!element.root)\n\t\t\tif (element = element.return)\n\t\t\t\tcallback(element)\n\t}\n}\n\n/**\n * @param {object} element\n * @param {number} index\n * @param {object[]} children\n * @param {function} callback\n */\nexport function prefixer (element, index, children, callback) {\n\tif (element.length > -1)\n\t\tif (!element.return)\n\t\t\tswitch (element.type) {\n\t\t\t\tcase DECLARATION: element.return = prefix(element.value, element.length, children)\n\t\t\t\t\treturn\n\t\t\t\tcase KEYFRAMES:\n\t\t\t\t\treturn serialize([copy(element, {value: replace(element.value, '@', '@' + WEBKIT)})], callback)\n\t\t\t\tcase RULESET:\n\t\t\t\t\tif (element.length)\n\t\t\t\t\t\treturn combine(element.props, function (value) {\n\t\t\t\t\t\t\tswitch (match(value, /(::plac\\w+|:read-\\w+)/)) {\n\t\t\t\t\t\t\t\t// :read-(only|write)\n\t\t\t\t\t\t\t\tcase ':read-only': case ':read-write':\n\t\t\t\t\t\t\t\t\treturn serialize([copy(element, {props: [replace(value, /:(read-\\w+)/, ':' + MOZ + '$1')]})], callback)\n\t\t\t\t\t\t\t\t// :placeholder\n\t\t\t\t\t\t\t\tcase '::placeholder':\n\t\t\t\t\t\t\t\t\treturn serialize([\n\t\t\t\t\t\t\t\t\t\tcopy(element, {props: [replace(value, /:(plac\\w+)/, ':' + WEBKIT + 'input-$1')]}),\n\t\t\t\t\t\t\t\t\t\tcopy(element, {props: [replace(value, /:(plac\\w+)/, ':' + MOZ + '$1')]}),\n\t\t\t\t\t\t\t\t\t\tcopy(element, {props: [replace(value, /:(plac\\w+)/, MS + 'input-$1')]})\n\t\t\t\t\t\t\t\t\t], callback)\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn ''\n\t\t\t\t\t\t})\n\t\t\t}\n}\n\n/**\n * @param {object} element\n * @param {number} index\n * @param {object[]} children\n */\nexport function namespace (element) {\n\tswitch (element.type) {\n\t\tcase RULESET:\n\t\t\telement.props = element.props.map(function (value) {\n\t\t\t\treturn combine(tokenize(value), function (value, index, children) {\n\t\t\t\t\tswitch (charat(value, 0)) {\n\t\t\t\t\t\t// \\f\n\t\t\t\t\t\tcase 12:\n\t\t\t\t\t\t\treturn substr(value, 1, strlen(value))\n\t\t\t\t\t\t// \\0 ( + > ~\n\t\t\t\t\t\tcase 0: case 40: case 43: case 62: case 126:\n\t\t\t\t\t\t\treturn value\n\t\t\t\t\t\t// :\n\t\t\t\t\t\tcase 58:\n\t\t\t\t\t\t\tif (children[++index] === 'global')\n\t\t\t\t\t\t\t\tchildren[index] = '', children[++index] = '\\f' + substr(children[index], index = 1, -1)\n\t\t\t\t\t\t// \\s\n\t\t\t\t\t\tcase 32:\n\t\t\t\t\t\t\treturn index === 1 ? '' : value\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tswitch (index) {\n\t\t\t\t\t\t\t\tcase 0: element = value\n\t\t\t\t\t\t\t\t\treturn sizeof(children) > 1 ? '' : value\n\t\t\t\t\t\t\t\tcase index = sizeof(children) - 1: case 2:\n\t\t\t\t\t\t\t\t\treturn index === 2 ? value + element + element : value + element\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\treturn value\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t})\n\t}\n}\n","import createCache from '@emotion/cache';\nimport { serializeStyles } from '@emotion/serialize';\nimport { getRegisteredStyles, insertStyles } from '@emotion/utils';\n\nfunction insertWithoutScoping(cache, serialized) {\n  if (cache.inserted[serialized.name] === undefined) {\n    return cache.insert('', serialized, cache.sheet, true);\n  }\n}\n\nfunction merge(registered, css, className) {\n  var registeredStyles = [];\n  var rawClassName = getRegisteredStyles(registered, registeredStyles, className);\n\n  if (registeredStyles.length < 2) {\n    return className;\n  }\n\n  return rawClassName + css(registeredStyles);\n}\n\nvar createEmotion = function createEmotion(options) {\n  var cache = createCache(options); // $FlowFixMe\n\n  cache.sheet.speedy = function (value) {\n    if (process.env.NODE_ENV !== 'production' && this.ctr !== 0) {\n      throw new Error('speedy must be changed before any rules are inserted');\n    }\n\n    this.isSpeedy = value;\n  };\n\n  cache.compat = true;\n\n  var css = function css() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var serialized = serializeStyles(args, cache.registered, undefined);\n    insertStyles(cache, serialized, false);\n    return cache.key + \"-\" + serialized.name;\n  };\n\n  var keyframes = function keyframes() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    var serialized = serializeStyles(args, cache.registered);\n    var animation = \"animation-\" + serialized.name;\n    insertWithoutScoping(cache, {\n      name: serialized.name,\n      styles: \"@keyframes \" + animation + \"{\" + serialized.styles + \"}\"\n    });\n    return animation;\n  };\n\n  var injectGlobal = function injectGlobal() {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    var serialized = serializeStyles(args, cache.registered);\n    insertWithoutScoping(cache, serialized);\n  };\n\n  var cx = function cx() {\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n\n    return merge(cache.registered, css, classnames(args));\n  };\n\n  return {\n    css: css,\n    cx: cx,\n    injectGlobal: injectGlobal,\n    keyframes: keyframes,\n    hydrate: function hydrate(ids) {\n      ids.forEach(function (key) {\n        cache.inserted[key] = true;\n      });\n    },\n    flush: function flush() {\n      cache.registered = {};\n      cache.inserted = {};\n      cache.sheet.flush();\n    },\n    // $FlowFixMe\n    sheet: cache.sheet,\n    cache: cache,\n    getRegisteredStyles: getRegisteredStyles.bind(null, cache.registered),\n    merge: merge.bind(null, cache.registered, css)\n  };\n};\n\nvar classnames = function classnames(args) {\n  var cls = '';\n\n  for (var i = 0; i < args.length; i++) {\n    var arg = args[i];\n    if (arg == null) continue;\n    var toAdd = void 0;\n\n    switch (typeof arg) {\n      case 'boolean':\n        break;\n\n      case 'object':\n        {\n          if (Array.isArray(arg)) {\n            toAdd = classnames(arg);\n          } else {\n            toAdd = '';\n\n            for (var k in arg) {\n              if (arg[k] && k) {\n                toAdd && (toAdd += ' ');\n                toAdd += k;\n              }\n            }\n          }\n\n          break;\n        }\n\n      default:\n        {\n          toAdd = arg;\n        }\n    }\n\n    if (toAdd) {\n      cls && (cls += ' ');\n      cls += toAdd;\n    }\n  }\n\n  return cls;\n};\n\nexport default createEmotion;\n","import '@emotion/cache';\nimport '@emotion/serialize';\nimport '@emotion/utils';\nimport createEmotion from '../create-instance/dist/emotion-css-create-instance.esm.js';\n\nvar _createEmotion = createEmotion({\n  key: 'css'\n}),\n    flush = _createEmotion.flush,\n    hydrate = _createEmotion.hydrate,\n    cx = _createEmotion.cx,\n    merge = _createEmotion.merge,\n    getRegisteredStyles = _createEmotion.getRegisteredStyles,\n    injectGlobal = _createEmotion.injectGlobal,\n    keyframes = _createEmotion.keyframes,\n    css = _createEmotion.css,\n    sheet = _createEmotion.sheet,\n    cache = _createEmotion.cache;\n\nexport { cache, css, cx, flush, getRegisteredStyles, hydrate, injectGlobal, keyframes, merge, sheet };\n","function memoize(fn) {\n  var cache = Object.create(null);\n  return function (arg) {\n    if (cache[arg] === undefined) cache[arg] = fn(arg);\n    return cache[arg];\n  };\n}\n\nexport default memoize;\n","/* eslint-disable */\n// Inspired by https://github.com/garycourt/murmurhash-js\n// Ported from https://github.com/aappleby/smhasher/blob/61a0530f28277f2e850bfc39600ce61d02b518de/src/MurmurHash2.cpp#L37-L86\nfunction murmur2(str) {\n  // 'm' and 'r' are mixing constants generated offline.\n  // They're not really 'magic', they just happen to work well.\n  // const m = 0x5bd1e995;\n  // const r = 24;\n  // Initialize the hash\n  var h = 0; // Mix 4 bytes at a time into the hash\n\n  var k,\n      i = 0,\n      len = str.length;\n\n  for (; len >= 4; ++i, len -= 4) {\n    k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;\n    k =\n    /* Math.imul(k, m): */\n    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16);\n    k ^=\n    /* k >>> r: */\n    k >>> 24;\n    h =\n    /* Math.imul(k, m): */\n    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16) ^\n    /* Math.imul(h, m): */\n    (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);\n  } // Handle the last few bytes of the input array\n\n\n  switch (len) {\n    case 3:\n      h ^= (str.charCodeAt(i + 2) & 0xff) << 16;\n\n    case 2:\n      h ^= (str.charCodeAt(i + 1) & 0xff) << 8;\n\n    case 1:\n      h ^= str.charCodeAt(i) & 0xff;\n      h =\n      /* Math.imul(h, m): */\n      (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);\n  } // Do a few final mixes of the hash to ensure the last few\n  // bytes are well-incorporated.\n\n\n  h ^= h >>> 13;\n  h =\n  /* Math.imul(h, m): */\n  (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);\n  return ((h ^ h >>> 15) >>> 0).toString(36);\n}\n\nexport default murmur2;\n","var unitlessKeys = {\n  animationIterationCount: 1,\n  borderImageOutset: 1,\n  borderImageSlice: 1,\n  borderImageWidth: 1,\n  boxFlex: 1,\n  boxFlexGroup: 1,\n  boxOrdinalGroup: 1,\n  columnCount: 1,\n  columns: 1,\n  flex: 1,\n  flexGrow: 1,\n  flexPositive: 1,\n  flexShrink: 1,\n  flexNegative: 1,\n  flexOrder: 1,\n  gridRow: 1,\n  gridRowEnd: 1,\n  gridRowSpan: 1,\n  gridRowStart: 1,\n  gridColumn: 1,\n  gridColumnEnd: 1,\n  gridColumnSpan: 1,\n  gridColumnStart: 1,\n  msGridRow: 1,\n  msGridRowSpan: 1,\n  msGridColumn: 1,\n  msGridColumnSpan: 1,\n  fontWeight: 1,\n  lineHeight: 1,\n  opacity: 1,\n  order: 1,\n  orphans: 1,\n  tabSize: 1,\n  widows: 1,\n  zIndex: 1,\n  zoom: 1,\n  WebkitLineClamp: 1,\n  // SVG-related properties\n  fillOpacity: 1,\n  floodOpacity: 1,\n  stopOpacity: 1,\n  strokeDasharray: 1,\n  strokeDashoffset: 1,\n  strokeMiterlimit: 1,\n  strokeOpacity: 1,\n  strokeWidth: 1\n};\n\nexport default unitlessKeys;\n","import hashString from '@emotion/hash';\nimport unitless from '@emotion/unitless';\nimport memoize from '@emotion/memoize';\n\nvar ILLEGAL_ESCAPE_SEQUENCE_ERROR = \"You have illegal escape sequence in your template literal, most likely inside content's property value.\\nBecause you write your CSS inside a JavaScript string you actually have to do double escaping, so for example \\\"content: '\\\\00d7';\\\" should become \\\"content: '\\\\\\\\00d7';\\\".\\nYou can read more about this here:\\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences\";\nvar UNDEFINED_AS_OBJECT_KEY_ERROR = \"You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).\";\nvar hyphenateRegex = /[A-Z]|^ms/g;\nvar animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;\n\nvar isCustomProperty = function isCustomProperty(property) {\n  return property.charCodeAt(1) === 45;\n};\n\nvar isProcessableValue = function isProcessableValue(value) {\n  return value != null && typeof value !== 'boolean';\n};\n\nvar processStyleName = /* #__PURE__ */memoize(function (styleName) {\n  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, '-$&').toLowerCase();\n});\n\nvar processStyleValue = function processStyleValue(key, value) {\n  switch (key) {\n    case 'animation':\n    case 'animationName':\n      {\n        if (typeof value === 'string') {\n          return value.replace(animationRegex, function (match, p1, p2) {\n            cursor = {\n              name: p1,\n              styles: p2,\n              next: cursor\n            };\n            return p1;\n          });\n        }\n      }\n  }\n\n  if (unitless[key] !== 1 && !isCustomProperty(key) && typeof value === 'number' && value !== 0) {\n    return value + 'px';\n  }\n\n  return value;\n};\n\nif (process.env.NODE_ENV !== 'production') {\n  var contentValuePattern = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\\(|(no-)?(open|close)-quote/;\n  var contentValues = ['normal', 'none', 'initial', 'inherit', 'unset'];\n  var oldProcessStyleValue = processStyleValue;\n  var msPattern = /^-ms-/;\n  var hyphenPattern = /-(.)/g;\n  var hyphenatedCache = {};\n\n  processStyleValue = function processStyleValue(key, value) {\n    if (key === 'content') {\n      if (typeof value !== 'string' || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '\"' && value.charAt(0) !== \"'\")) {\n        throw new Error(\"You seem to be using a value for 'content' without quotes, try replacing it with `content: '\\\"\" + value + \"\\\"'`\");\n      }\n    }\n\n    var processed = oldProcessStyleValue(key, value);\n\n    if (processed !== '' && !isCustomProperty(key) && key.indexOf('-') !== -1 && hyphenatedCache[key] === undefined) {\n      hyphenatedCache[key] = true;\n      console.error(\"Using kebab-case for css properties in objects is not supported. Did you mean \" + key.replace(msPattern, 'ms-').replace(hyphenPattern, function (str, _char) {\n        return _char.toUpperCase();\n      }) + \"?\");\n    }\n\n    return processed;\n  };\n}\n\nvar noComponentSelectorMessage = 'Component selectors can only be used in conjunction with ' + '@emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware ' + 'compiler transform.';\n\nfunction handleInterpolation(mergedProps, registered, interpolation) {\n  if (interpolation == null) {\n    return '';\n  }\n\n  if (interpolation.__emotion_styles !== undefined) {\n    if (process.env.NODE_ENV !== 'production' && interpolation.toString() === 'NO_COMPONENT_SELECTOR') {\n      throw new Error(noComponentSelectorMessage);\n    }\n\n    return interpolation;\n  }\n\n  switch (typeof interpolation) {\n    case 'boolean':\n      {\n        return '';\n      }\n\n    case 'object':\n      {\n        if (interpolation.anim === 1) {\n          cursor = {\n            name: interpolation.name,\n            styles: interpolation.styles,\n            next: cursor\n          };\n          return interpolation.name;\n        }\n\n        if (interpolation.styles !== undefined) {\n          var next = interpolation.next;\n\n          if (next !== undefined) {\n            // not the most efficient thing ever but this is a pretty rare case\n            // and there will be very few iterations of this generally\n            while (next !== undefined) {\n              cursor = {\n                name: next.name,\n                styles: next.styles,\n                next: cursor\n              };\n              next = next.next;\n            }\n          }\n\n          var styles = interpolation.styles + \";\";\n\n          if (process.env.NODE_ENV !== 'production' && interpolation.map !== undefined) {\n            styles += interpolation.map;\n          }\n\n          return styles;\n        }\n\n        return createStringFromObject(mergedProps, registered, interpolation);\n      }\n\n    case 'function':\n      {\n        if (mergedProps !== undefined) {\n          var previousCursor = cursor;\n          var result = interpolation(mergedProps);\n          cursor = previousCursor;\n          return handleInterpolation(mergedProps, registered, result);\n        } else if (process.env.NODE_ENV !== 'production') {\n          console.error('Functions that are interpolated in css calls will be stringified.\\n' + 'If you want to have a css call based on props, create a function that returns a css call like this\\n' + 'let dynamicStyle = (props) => css`color: ${props.color}`\\n' + 'It can be called directly with props or interpolated in a styled call like this\\n' + \"let SomeComponent = styled('div')`${dynamicStyle}`\");\n        }\n\n        break;\n      }\n\n    case 'string':\n      if (process.env.NODE_ENV !== 'production') {\n        var matched = [];\n        var replaced = interpolation.replace(animationRegex, function (match, p1, p2) {\n          var fakeVarName = \"animation\" + matched.length;\n          matched.push(\"const \" + fakeVarName + \" = keyframes`\" + p2.replace(/^@keyframes animation-\\w+/, '') + \"`\");\n          return \"${\" + fakeVarName + \"}\";\n        });\n\n        if (matched.length) {\n          console.error('`keyframes` output got interpolated into plain string, please wrap it with `css`.\\n\\n' + 'Instead of doing this:\\n\\n' + [].concat(matched, [\"`\" + replaced + \"`\"]).join('\\n') + '\\n\\nYou should wrap it with `css` like this:\\n\\n' + (\"css`\" + replaced + \"`\"));\n        }\n      }\n\n      break;\n  } // finalize string values (regular strings and functions interpolated into css calls)\n\n\n  if (registered == null) {\n    return interpolation;\n  }\n\n  var cached = registered[interpolation];\n  return cached !== undefined ? cached : interpolation;\n}\n\nfunction createStringFromObject(mergedProps, registered, obj) {\n  var string = '';\n\n  if (Array.isArray(obj)) {\n    for (var i = 0; i < obj.length; i++) {\n      string += handleInterpolation(mergedProps, registered, obj[i]) + \";\";\n    }\n  } else {\n    for (var _key in obj) {\n      var value = obj[_key];\n\n      if (typeof value !== 'object') {\n        if (registered != null && registered[value] !== undefined) {\n          string += _key + \"{\" + registered[value] + \"}\";\n        } else if (isProcessableValue(value)) {\n          string += processStyleName(_key) + \":\" + processStyleValue(_key, value) + \";\";\n        }\n      } else {\n        if (_key === 'NO_COMPONENT_SELECTOR' && process.env.NODE_ENV !== 'production') {\n          throw new Error(noComponentSelectorMessage);\n        }\n\n        if (Array.isArray(value) && typeof value[0] === 'string' && (registered == null || registered[value[0]] === undefined)) {\n          for (var _i = 0; _i < value.length; _i++) {\n            if (isProcessableValue(value[_i])) {\n              string += processStyleName(_key) + \":\" + processStyleValue(_key, value[_i]) + \";\";\n            }\n          }\n        } else {\n          var interpolated = handleInterpolation(mergedProps, registered, value);\n\n          switch (_key) {\n            case 'animation':\n            case 'animationName':\n              {\n                string += processStyleName(_key) + \":\" + interpolated + \";\";\n                break;\n              }\n\n            default:\n              {\n                if (process.env.NODE_ENV !== 'production' && _key === 'undefined') {\n                  console.error(UNDEFINED_AS_OBJECT_KEY_ERROR);\n                }\n\n                string += _key + \"{\" + interpolated + \"}\";\n              }\n          }\n        }\n      }\n    }\n  }\n\n  return string;\n}\n\nvar labelPattern = /label:\\s*([^\\s;\\n{]+)\\s*(;|$)/g;\nvar sourceMapPattern;\n\nif (process.env.NODE_ENV !== 'production') {\n  sourceMapPattern = /\\/\\*#\\ssourceMappingURL=data:application\\/json;\\S+\\s+\\*\\//g;\n} // this is the cursor for keyframes\n// keyframes are stored on the SerializedStyles object as a linked list\n\n\nvar cursor;\nvar serializeStyles = function serializeStyles(args, registered, mergedProps) {\n  if (args.length === 1 && typeof args[0] === 'object' && args[0] !== null && args[0].styles !== undefined) {\n    return args[0];\n  }\n\n  var stringMode = true;\n  var styles = '';\n  cursor = undefined;\n  var strings = args[0];\n\n  if (strings == null || strings.raw === undefined) {\n    stringMode = false;\n    styles += handleInterpolation(mergedProps, registered, strings);\n  } else {\n    if (process.env.NODE_ENV !== 'production' && strings[0] === undefined) {\n      console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);\n    }\n\n    styles += strings[0];\n  } // we start at 1 since we've already handled the first arg\n\n\n  for (var i = 1; i < args.length; i++) {\n    styles += handleInterpolation(mergedProps, registered, args[i]);\n\n    if (stringMode) {\n      if (process.env.NODE_ENV !== 'production' && strings[i] === undefined) {\n        console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);\n      }\n\n      styles += strings[i];\n    }\n  }\n\n  var sourceMap;\n\n  if (process.env.NODE_ENV !== 'production') {\n    styles = styles.replace(sourceMapPattern, function (match) {\n      sourceMap = match;\n      return '';\n    });\n  } // using a global regex with .exec is stateful so lastIndex has to be reset each time\n\n\n  labelPattern.lastIndex = 0;\n  var identifierName = '';\n  var match; // https://esbench.com/bench/5b809c2cf2949800a0f61fb5\n\n  while ((match = labelPattern.exec(styles)) !== null) {\n    identifierName += '-' + // $FlowFixMe we know it's not null\n    match[1];\n  }\n\n  var name = hashString(styles) + identifierName;\n\n  if (process.env.NODE_ENV !== 'production') {\n    // $FlowFixMe SerializedStyles type doesn't have toString property (and we don't want to add it)\n    return {\n      name: name,\n      styles: styles,\n      map: sourceMap,\n      next: cursor,\n      toString: function toString() {\n        return \"You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).\";\n      }\n    };\n  }\n\n  return {\n    name: name,\n    styles: styles,\n    next: cursor\n  };\n};\n\nexport { serializeStyles };\n","export default function _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}","import memoize from '@emotion/memoize';\n\nvar reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/; // https://esbench.com/bench/5bfee68a4cd7e6009ef61d23\n\nvar isPropValid = /* #__PURE__ */memoize(function (prop) {\n  return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111\n  /* o */\n  && prop.charCodeAt(1) === 110\n  /* n */\n  && prop.charCodeAt(2) < 91;\n}\n/* Z+1 */\n);\n\nexport default isPropValid;\n","import * as React from 'react';\nimport { useLayoutEffect } from 'react';\n\nvar syncFallback = function syncFallback(create) {\n  return create();\n};\n\nvar useInsertionEffect = React['useInsertion' + 'Effect'] ? React['useInsertion' + 'Effect'] : false;\nvar useInsertionEffectAlwaysWithSyncFallback =  useInsertionEffect || syncFallback;\nvar useInsertionEffectWithLayoutFallback = useInsertionEffect || useLayoutEffect;\n\nexport { useInsertionEffectAlwaysWithSyncFallback, useInsertionEffectWithLayoutFallback };\n","import { createContext, useContext, forwardRef, createElement, Fragment } from 'react';\nimport createCache from '@emotion/cache';\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport weakMemoize from '@emotion/weak-memoize';\nimport hoistNonReactStatics from '../_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js';\nimport { getRegisteredStyles, registerStyles, insertStyles } from '@emotion/utils';\nimport { serializeStyles } from '@emotion/serialize';\nimport { useInsertionEffectAlwaysWithSyncFallback } from '@emotion/use-insertion-effect-with-fallbacks';\n\nvar hasOwnProperty = {}.hasOwnProperty;\n\nvar EmotionCacheContext = /* #__PURE__ */createContext( // we're doing this to avoid preconstruct's dead code elimination in this one case\n// because this module is primarily intended for the browser and node\n// but it's also required in react native and similar environments sometimes\n// and we could have a special build just for that\n// but this is much easier and the native packages\n// might use a different theme context in the future anyway\ntypeof HTMLElement !== 'undefined' ? /* #__PURE__ */createCache({\n  key: 'css'\n}) : null);\n\nif (process.env.NODE_ENV !== 'production') {\n  EmotionCacheContext.displayName = 'EmotionCacheContext';\n}\n\nvar CacheProvider = EmotionCacheContext.Provider;\nvar __unsafe_useEmotionCache = function useEmotionCache() {\n  return useContext(EmotionCacheContext);\n};\n\nvar withEmotionCache = function withEmotionCache(func) {\n  // $FlowFixMe\n  return /*#__PURE__*/forwardRef(function (props, ref) {\n    // the cache will never be null in the browser\n    var cache = useContext(EmotionCacheContext);\n    return func(props, cache, ref);\n  });\n};\n\nvar ThemeContext = /* #__PURE__ */createContext({});\n\nif (process.env.NODE_ENV !== 'production') {\n  ThemeContext.displayName = 'EmotionThemeContext';\n}\n\nvar useTheme = function useTheme() {\n  return useContext(ThemeContext);\n};\n\nvar getTheme = function getTheme(outerTheme, theme) {\n  if (typeof theme === 'function') {\n    var mergedTheme = theme(outerTheme);\n\n    if (process.env.NODE_ENV !== 'production' && (mergedTheme == null || typeof mergedTheme !== 'object' || Array.isArray(mergedTheme))) {\n      throw new Error('[ThemeProvider] Please return an object from your theme function, i.e. theme={() => ({})}!');\n    }\n\n    return mergedTheme;\n  }\n\n  if (process.env.NODE_ENV !== 'production' && (theme == null || typeof theme !== 'object' || Array.isArray(theme))) {\n    throw new Error('[ThemeProvider] Please make your theme prop a plain object');\n  }\n\n  return _extends({}, outerTheme, theme);\n};\n\nvar createCacheWithTheme = /* #__PURE__ */weakMemoize(function (outerTheme) {\n  return weakMemoize(function (theme) {\n    return getTheme(outerTheme, theme);\n  });\n});\nvar ThemeProvider = function ThemeProvider(props) {\n  var theme = useContext(ThemeContext);\n\n  if (props.theme !== theme) {\n    theme = createCacheWithTheme(theme)(props.theme);\n  }\n\n  return /*#__PURE__*/createElement(ThemeContext.Provider, {\n    value: theme\n  }, props.children);\n};\nfunction withTheme(Component) {\n  var componentName = Component.displayName || Component.name || 'Component';\n\n  var render = function render(props, ref) {\n    var theme = useContext(ThemeContext);\n    return /*#__PURE__*/createElement(Component, _extends({\n      theme: theme,\n      ref: ref\n    }, props));\n  }; // $FlowFixMe\n\n\n  var WithTheme = /*#__PURE__*/forwardRef(render);\n  WithTheme.displayName = \"WithTheme(\" + componentName + \")\";\n  return hoistNonReactStatics(WithTheme, Component);\n}\n\nvar getLastPart = function getLastPart(functionName) {\n  // The match may be something like 'Object.createEmotionProps' or\n  // 'Loader.prototype.render'\n  var parts = functionName.split('.');\n  return parts[parts.length - 1];\n};\n\nvar getFunctionNameFromStackTraceLine = function getFunctionNameFromStackTraceLine(line) {\n  // V8\n  var match = /^\\s+at\\s+([A-Za-z0-9$.]+)\\s/.exec(line);\n  if (match) return getLastPart(match[1]); // Safari / Firefox\n\n  match = /^([A-Za-z0-9$.]+)@/.exec(line);\n  if (match) return getLastPart(match[1]);\n  return undefined;\n};\n\nvar internalReactFunctionNames = /* #__PURE__ */new Set(['renderWithHooks', 'processChild', 'finishClassComponent', 'renderToString']); // These identifiers come from error stacks, so they have to be valid JS\n// identifiers, thus we only need to replace what is a valid character for JS,\n// but not for CSS.\n\nvar sanitizeIdentifier = function sanitizeIdentifier(identifier) {\n  return identifier.replace(/\\$/g, '-');\n};\n\nvar getLabelFromStackTrace = function getLabelFromStackTrace(stackTrace) {\n  if (!stackTrace) return undefined;\n  var lines = stackTrace.split('\\n');\n\n  for (var i = 0; i < lines.length; i++) {\n    var functionName = getFunctionNameFromStackTraceLine(lines[i]); // The first line of V8 stack traces is just \"Error\"\n\n    if (!functionName) continue; // If we reach one of these, we have gone too far and should quit\n\n    if (internalReactFunctionNames.has(functionName)) break; // The component name is the first function in the stack that starts with an\n    // uppercase letter\n\n    if (/^[A-Z]/.test(functionName)) return sanitizeIdentifier(functionName);\n  }\n\n  return undefined;\n};\n\nvar typePropName = '__EMOTION_TYPE_PLEASE_DO_NOT_USE__';\nvar labelPropName = '__EMOTION_LABEL_PLEASE_DO_NOT_USE__';\nvar createEmotionProps = function createEmotionProps(type, props) {\n  if (process.env.NODE_ENV !== 'production' && typeof props.css === 'string' && // check if there is a css declaration\n  props.css.indexOf(':') !== -1) {\n    throw new Error(\"Strings are not allowed as css prop values, please wrap it in a css template literal from '@emotion/react' like this: css`\" + props.css + \"`\");\n  }\n\n  var newProps = {};\n\n  for (var key in props) {\n    if (hasOwnProperty.call(props, key)) {\n      newProps[key] = props[key];\n    }\n  }\n\n  newProps[typePropName] = type; // For performance, only call getLabelFromStackTrace in development and when\n  // the label hasn't already been computed\n\n  if (process.env.NODE_ENV !== 'production' && !!props.css && (typeof props.css !== 'object' || typeof props.css.name !== 'string' || props.css.name.indexOf('-') === -1)) {\n    var label = getLabelFromStackTrace(new Error().stack);\n    if (label) newProps[labelPropName] = label;\n  }\n\n  return newProps;\n};\n\nvar Insertion = function Insertion(_ref) {\n  var cache = _ref.cache,\n      serialized = _ref.serialized,\n      isStringTag = _ref.isStringTag;\n  registerStyles(cache, serialized, isStringTag);\n  var rules = useInsertionEffectAlwaysWithSyncFallback(function () {\n    return insertStyles(cache, serialized, isStringTag);\n  });\n\n  return null;\n};\n\nvar Emotion = /* #__PURE__ */withEmotionCache(function (props, cache, ref) {\n  var cssProp = props.css; // so that using `css` from `emotion` and passing the result to the css prop works\n  // not passing the registered cache to serializeStyles because it would\n  // make certain babel optimisations not possible\n\n  if (typeof cssProp === 'string' && cache.registered[cssProp] !== undefined) {\n    cssProp = cache.registered[cssProp];\n  }\n\n  var WrappedComponent = props[typePropName];\n  var registeredStyles = [cssProp];\n  var className = '';\n\n  if (typeof props.className === 'string') {\n    className = getRegisteredStyles(cache.registered, registeredStyles, props.className);\n  } else if (props.className != null) {\n    className = props.className + \" \";\n  }\n\n  var serialized = serializeStyles(registeredStyles, undefined, useContext(ThemeContext));\n\n  if (process.env.NODE_ENV !== 'production' && serialized.name.indexOf('-') === -1) {\n    var labelFromStack = props[labelPropName];\n\n    if (labelFromStack) {\n      serialized = serializeStyles([serialized, 'label:' + labelFromStack + ';']);\n    }\n  }\n\n  className += cache.key + \"-\" + serialized.name;\n  var newProps = {};\n\n  for (var key in props) {\n    if (hasOwnProperty.call(props, key) && key !== 'css' && key !== typePropName && (process.env.NODE_ENV === 'production' || key !== labelPropName)) {\n      newProps[key] = props[key];\n    }\n  }\n\n  newProps.ref = ref;\n  newProps.className = className;\n  return /*#__PURE__*/createElement(Fragment, null, /*#__PURE__*/createElement(Insertion, {\n    cache: cache,\n    serialized: serialized,\n    isStringTag: typeof WrappedComponent === 'string'\n  }), /*#__PURE__*/createElement(WrappedComponent, newProps));\n});\n\nif (process.env.NODE_ENV !== 'production') {\n  Emotion.displayName = 'EmotionCssPropInternal';\n}\n\nexport { CacheProvider as C, Emotion as E, ThemeContext as T, __unsafe_useEmotionCache as _, ThemeProvider as a, withTheme as b, createEmotionProps as c, hasOwnProperty as h, useTheme as u, withEmotionCache as w };\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport { useContext, createElement, Fragment } from 'react';\nimport isPropValid from '@emotion/is-prop-valid';\nimport { withEmotionCache, ThemeContext } from '@emotion/react';\nimport { getRegisteredStyles, registerStyles, insertStyles } from '@emotion/utils';\nimport { serializeStyles } from '@emotion/serialize';\nimport { useInsertionEffectAlwaysWithSyncFallback } from '@emotion/use-insertion-effect-with-fallbacks';\n\nvar testOmitPropsOnStringTag = isPropValid;\n\nvar testOmitPropsOnComponent = function testOmitPropsOnComponent(key) {\n  return key !== 'theme';\n};\n\nvar getDefaultShouldForwardProp = function getDefaultShouldForwardProp(tag) {\n  return typeof tag === 'string' && // 96 is one less than the char code\n  // for \"a\" so this is checking that\n  // it's a lowercase character\n  tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;\n};\nvar composeShouldForwardProps = function composeShouldForwardProps(tag, options, isReal) {\n  var shouldForwardProp;\n\n  if (options) {\n    var optionsShouldForwardProp = options.shouldForwardProp;\n    shouldForwardProp = tag.__emotion_forwardProp && optionsShouldForwardProp ? function (propName) {\n      return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);\n    } : optionsShouldForwardProp;\n  }\n\n  if (typeof shouldForwardProp !== 'function' && isReal) {\n    shouldForwardProp = tag.__emotion_forwardProp;\n  }\n\n  return shouldForwardProp;\n};\n\nvar ILLEGAL_ESCAPE_SEQUENCE_ERROR = \"You have illegal escape sequence in your template literal, most likely inside content's property value.\\nBecause you write your CSS inside a JavaScript string you actually have to do double escaping, so for example \\\"content: '\\\\00d7';\\\" should become \\\"content: '\\\\\\\\00d7';\\\".\\nYou can read more about this here:\\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences\";\n\nvar Insertion = function Insertion(_ref) {\n  var cache = _ref.cache,\n      serialized = _ref.serialized,\n      isStringTag = _ref.isStringTag;\n  registerStyles(cache, serialized, isStringTag);\n  var rules = useInsertionEffectAlwaysWithSyncFallback(function () {\n    return insertStyles(cache, serialized, isStringTag);\n  });\n\n  return null;\n};\n\nvar createStyled = function createStyled(tag, options) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (tag === undefined) {\n      throw new Error('You are trying to create a styled element with an undefined component.\\nYou may have forgotten to import it.');\n    }\n  }\n\n  var isReal = tag.__emotion_real === tag;\n  var baseTag = isReal && tag.__emotion_base || tag;\n  var identifierName;\n  var targetClassName;\n\n  if (options !== undefined) {\n    identifierName = options.label;\n    targetClassName = options.target;\n  }\n\n  var shouldForwardProp = composeShouldForwardProps(tag, options, isReal);\n  var defaultShouldForwardProp = shouldForwardProp || getDefaultShouldForwardProp(baseTag);\n  var shouldUseAs = !defaultShouldForwardProp('as');\n  return function () {\n    var args = arguments;\n    var styles = isReal && tag.__emotion_styles !== undefined ? tag.__emotion_styles.slice(0) : [];\n\n    if (identifierName !== undefined) {\n      styles.push(\"label:\" + identifierName + \";\");\n    }\n\n    if (args[0] == null || args[0].raw === undefined) {\n      styles.push.apply(styles, args);\n    } else {\n      if (process.env.NODE_ENV !== 'production' && args[0][0] === undefined) {\n        console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);\n      }\n\n      styles.push(args[0][0]);\n      var len = args.length;\n      var i = 1;\n\n      for (; i < len; i++) {\n        if (process.env.NODE_ENV !== 'production' && args[0][i] === undefined) {\n          console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);\n        }\n\n        styles.push(args[i], args[0][i]);\n      }\n    } // $FlowFixMe: we need to cast StatelessFunctionalComponent to our PrivateStyledComponent class\n\n\n    var Styled = withEmotionCache(function (props, cache, ref) {\n      var FinalTag = shouldUseAs && props.as || baseTag;\n      var className = '';\n      var classInterpolations = [];\n      var mergedProps = props;\n\n      if (props.theme == null) {\n        mergedProps = {};\n\n        for (var key in props) {\n          mergedProps[key] = props[key];\n        }\n\n        mergedProps.theme = useContext(ThemeContext);\n      }\n\n      if (typeof props.className === 'string') {\n        className = getRegisteredStyles(cache.registered, classInterpolations, props.className);\n      } else if (props.className != null) {\n        className = props.className + \" \";\n      }\n\n      var serialized = serializeStyles(styles.concat(classInterpolations), cache.registered, mergedProps);\n      className += cache.key + \"-\" + serialized.name;\n\n      if (targetClassName !== undefined) {\n        className += \" \" + targetClassName;\n      }\n\n      var finalShouldForwardProp = shouldUseAs && shouldForwardProp === undefined ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;\n      var newProps = {};\n\n      for (var _key in props) {\n        if (shouldUseAs && _key === 'as') continue;\n\n        if ( // $FlowFixMe\n        finalShouldForwardProp(_key)) {\n          newProps[_key] = props[_key];\n        }\n      }\n\n      newProps.className = className;\n      newProps.ref = ref;\n      return /*#__PURE__*/createElement(Fragment, null, /*#__PURE__*/createElement(Insertion, {\n        cache: cache,\n        serialized: serialized,\n        isStringTag: typeof FinalTag === 'string'\n      }), /*#__PURE__*/createElement(FinalTag, newProps));\n    });\n    Styled.displayName = identifierName !== undefined ? identifierName : \"Styled(\" + (typeof baseTag === 'string' ? baseTag : baseTag.displayName || baseTag.name || 'Component') + \")\";\n    Styled.defaultProps = tag.defaultProps;\n    Styled.__emotion_real = Styled;\n    Styled.__emotion_base = baseTag;\n    Styled.__emotion_styles = styles;\n    Styled.__emotion_forwardProp = shouldForwardProp;\n    Object.defineProperty(Styled, 'toString', {\n      value: function value() {\n        if (targetClassName === undefined && process.env.NODE_ENV !== 'production') {\n          return 'NO_COMPONENT_SELECTOR';\n        } // $FlowFixMe: coerce undefined to string\n\n\n        return \".\" + targetClassName;\n      }\n    });\n\n    Styled.withComponent = function (nextTag, nextOptions) {\n      return createStyled(nextTag, _extends({}, options, nextOptions, {\n        shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)\n      })).apply(void 0, styles);\n    };\n\n    return Styled;\n  };\n};\n\nexport default createStyled;\n","import '@babel/runtime/helpers/extends';\nimport 'react';\nimport '@emotion/is-prop-valid';\nimport createStyled from '../base/dist/emotion-styled-base.browser.esm.js';\nimport '@emotion/react';\nimport '@emotion/utils';\nimport '@emotion/serialize';\nimport '@emotion/use-insertion-effect-with-fallbacks';\n\nvar tags = ['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'big', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr', // SVG\n'circle', 'clipPath', 'defs', 'ellipse', 'foreignObject', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'svg', 'text', 'tspan'];\n\nvar newStyled = createStyled.bind();\ntags.forEach(function (tagName) {\n  // $FlowFixMe: we can ignore this because its exposed type is defined by the CreateStyled type\n  newStyled[tagName] = newStyled(tagName);\n});\n\nexport default newStyled;\n","var isBrowser = \"object\" !== 'undefined';\nfunction getRegisteredStyles(registered, registeredStyles, classNames) {\n  var rawClassName = '';\n  classNames.split(' ').forEach(function (className) {\n    if (registered[className] !== undefined) {\n      registeredStyles.push(registered[className] + \";\");\n    } else {\n      rawClassName += className + \" \";\n    }\n  });\n  return rawClassName;\n}\nvar registerStyles = function registerStyles(cache, serialized, isStringTag) {\n  var className = cache.key + \"-\" + serialized.name;\n\n  if ( // we only need to add the styles to the registered cache if the\n  // class name could be used further down\n  // the tree but if it's a string tag, we know it won't\n  // so we don't have to add it to registered cache.\n  // this improves memory usage since we can avoid storing the whole style string\n  (isStringTag === false || // we need to always store it if we're in compat mode and\n  // in node since emotion-server relies on whether a style is in\n  // the registered cache to know whether a style is global or not\n  // also, note that this check will be dead code eliminated in the browser\n  isBrowser === false ) && cache.registered[className] === undefined) {\n    cache.registered[className] = serialized.styles;\n  }\n};\nvar insertStyles = function insertStyles(cache, serialized, isStringTag) {\n  registerStyles(cache, serialized, isStringTag);\n  var className = cache.key + \"-\" + serialized.name;\n\n  if (cache.inserted[serialized.name] === undefined) {\n    var current = serialized;\n\n    do {\n      var maybeStyles = cache.insert(serialized === current ? \".\" + className : '', current, cache.sheet, true);\n\n      current = current.next;\n    } while (current !== undefined);\n  }\n};\n\nexport { getRegisteredStyles, insertStyles, registerStyles };\n","/**\n * @license React\n * react.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var l=Symbol.for(\"react.element\"),n=Symbol.for(\"react.portal\"),p=Symbol.for(\"react.fragment\"),q=Symbol.for(\"react.strict_mode\"),r=Symbol.for(\"react.profiler\"),t=Symbol.for(\"react.provider\"),u=Symbol.for(\"react.context\"),v=Symbol.for(\"react.forward_ref\"),w=Symbol.for(\"react.suspense\"),x=Symbol.for(\"react.memo\"),y=Symbol.for(\"react.lazy\"),z=Symbol.iterator;function A(a){if(null===a||\"object\"!==typeof a)return null;a=z&&a[z]||a[\"@@iterator\"];return\"function\"===typeof a?a:null}\nvar B={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},C=Object.assign,D={};function E(a,b,e){this.props=a;this.context=b;this.refs=D;this.updater=e||B}E.prototype.isReactComponent={};\nE.prototype.setState=function(a,b){if(\"object\"!==typeof a&&\"function\"!==typeof a&&null!=a)throw Error(\"setState(...): takes an object of state variables to update or a function which returns an object of state variables.\");this.updater.enqueueSetState(this,a,b,\"setState\")};E.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,\"forceUpdate\")};function F(){}F.prototype=E.prototype;function G(a,b,e){this.props=a;this.context=b;this.refs=D;this.updater=e||B}var H=G.prototype=new F;\nH.constructor=G;C(H,E.prototype);H.isPureReactComponent=!0;var I=Array.isArray,J=Object.prototype.hasOwnProperty,K={current:null},L={key:!0,ref:!0,__self:!0,__source:!0};\nfunction M(a,b,e){var d,c={},k=null,h=null;if(null!=b)for(d in void 0!==b.ref&&(h=b.ref),void 0!==b.key&&(k=\"\"+b.key),b)J.call(b,d)&&!L.hasOwnProperty(d)&&(c[d]=b[d]);var g=arguments.length-2;if(1===g)c.children=e;else if(1<g){for(var f=Array(g),m=0;m<g;m++)f[m]=arguments[m+2];c.children=f}if(a&&a.defaultProps)for(d in g=a.defaultProps,g)void 0===c[d]&&(c[d]=g[d]);return{$$typeof:l,type:a,key:k,ref:h,props:c,_owner:K.current}}\nfunction N(a,b){return{$$typeof:l,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function O(a){return\"object\"===typeof a&&null!==a&&a.$$typeof===l}function escape(a){var b={\"=\":\"=0\",\":\":\"=2\"};return\"$\"+a.replace(/[=:]/g,function(a){return b[a]})}var P=/\\/+/g;function Q(a,b){return\"object\"===typeof a&&null!==a&&null!=a.key?escape(\"\"+a.key):b.toString(36)}\nfunction R(a,b,e,d,c){var k=typeof a;if(\"undefined\"===k||\"boolean\"===k)a=null;var h=!1;if(null===a)h=!0;else switch(k){case \"string\":case \"number\":h=!0;break;case \"object\":switch(a.$$typeof){case l:case n:h=!0}}if(h)return h=a,c=c(h),a=\"\"===d?\".\"+Q(h,0):d,I(c)?(e=\"\",null!=a&&(e=a.replace(P,\"$&/\")+\"/\"),R(c,b,e,\"\",function(a){return a})):null!=c&&(O(c)&&(c=N(c,e+(!c.key||h&&h.key===c.key?\"\":(\"\"+c.key).replace(P,\"$&/\")+\"/\")+a)),b.push(c)),1;h=0;d=\"\"===d?\".\":d+\":\";if(I(a))for(var g=0;g<a.length;g++){k=\na[g];var f=d+Q(k,g);h+=R(k,b,e,f,c)}else if(f=A(a),\"function\"===typeof f)for(a=f.call(a),g=0;!(k=a.next()).done;)k=k.value,f=d+Q(k,g++),h+=R(k,b,e,f,c);else if(\"object\"===k)throw b=String(a),Error(\"Objects are not valid as a React child (found: \"+(\"[object Object]\"===b?\"object with keys {\"+Object.keys(a).join(\", \")+\"}\":b)+\"). If you meant to render a collection of children, use an array instead.\");return h}\nfunction S(a,b,e){if(null==a)return a;var d=[],c=0;R(a,d,\"\",\"\",function(a){return b.call(e,a,c++)});return d}function T(a){if(-1===a._status){var b=a._result;b=b();b.then(function(b){if(0===a._status||-1===a._status)a._status=1,a._result=b},function(b){if(0===a._status||-1===a._status)a._status=2,a._result=b});-1===a._status&&(a._status=0,a._result=b)}if(1===a._status)return a._result.default;throw a._result;}\nvar U={current:null},V={transition:null},W={ReactCurrentDispatcher:U,ReactCurrentBatchConfig:V,ReactCurrentOwner:K};exports.Children={map:S,forEach:function(a,b,e){S(a,function(){b.apply(this,arguments)},e)},count:function(a){var b=0;S(a,function(){b++});return b},toArray:function(a){return S(a,function(a){return a})||[]},only:function(a){if(!O(a))throw Error(\"React.Children.only expected to receive a single React element child.\");return a}};exports.Component=E;exports.Fragment=p;\nexports.Profiler=r;exports.PureComponent=G;exports.StrictMode=q;exports.Suspense=w;exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=W;\nexports.cloneElement=function(a,b,e){if(null===a||void 0===a)throw Error(\"React.cloneElement(...): The argument must be a React element, but you passed \"+a+\".\");var d=C({},a.props),c=a.key,k=a.ref,h=a._owner;if(null!=b){void 0!==b.ref&&(k=b.ref,h=K.current);void 0!==b.key&&(c=\"\"+b.key);if(a.type&&a.type.defaultProps)var g=a.type.defaultProps;for(f in b)J.call(b,f)&&!L.hasOwnProperty(f)&&(d[f]=void 0===b[f]&&void 0!==g?g[f]:b[f])}var f=arguments.length-2;if(1===f)d.children=e;else if(1<f){g=Array(f);\nfor(var m=0;m<f;m++)g[m]=arguments[m+2];d.children=g}return{$$typeof:l,type:a.type,key:c,ref:k,props:d,_owner:h}};exports.createContext=function(a){a={$$typeof:u,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null};a.Provider={$$typeof:t,_context:a};return a.Consumer=a};exports.createElement=M;exports.createFactory=function(a){var b=M.bind(null,a);b.type=a;return b};exports.createRef=function(){return{current:null}};\nexports.forwardRef=function(a){return{$$typeof:v,render:a}};exports.isValidElement=O;exports.lazy=function(a){return{$$typeof:y,_payload:{_status:-1,_result:a},_init:T}};exports.memo=function(a,b){return{$$typeof:x,type:a,compare:void 0===b?null:b}};exports.startTransition=function(a){var b=V.transition;V.transition={};try{a()}finally{V.transition=b}};exports.unstable_act=function(){throw Error(\"act(...) is not supported in production builds of React.\");};\nexports.useCallback=function(a,b){return U.current.useCallback(a,b)};exports.useContext=function(a){return U.current.useContext(a)};exports.useDebugValue=function(){};exports.useDeferredValue=function(a){return U.current.useDeferredValue(a)};exports.useEffect=function(a,b){return U.current.useEffect(a,b)};exports.useId=function(){return U.current.useId()};exports.useImperativeHandle=function(a,b,e){return U.current.useImperativeHandle(a,b,e)};\nexports.useInsertionEffect=function(a,b){return U.current.useInsertionEffect(a,b)};exports.useLayoutEffect=function(a,b){return U.current.useLayoutEffect(a,b)};exports.useMemo=function(a,b){return U.current.useMemo(a,b)};exports.useReducer=function(a,b,e){return U.current.useReducer(a,b,e)};exports.useRef=function(a){return U.current.useRef(a)};exports.useState=function(a){return U.current.useState(a)};exports.useSyncExternalStore=function(a,b,e){return U.current.useSyncExternalStore(a,b,e)};\nexports.useTransition=function(){return U.current.useTransition()};exports.version=\"18.2.0\";\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react.production.min.js');\n} else {\n  module.exports = require('./cjs/react.development.js');\n}\n",null,"import csstype.px\nimport csstype.rgb\nimport emotion.react.css\nimport kotlinx.browser.document\nimport org.w3c.dom.*\nimport react.create\nimport react.dom.client.createRoot\n\nfun main() {\n    /*\n    val container = document.createElement(\"div\")\n    document.body!!.appendChild(container)\n    println(document.URL)\n    val welcome = Welcome.create {\n        name = document.body!!.innerHTML.toString()\n    }\n    createRoot(container).render(welcome)*/\n\n    val name: String = document.getElementsByTagName(\"h1\").get(0)!!.innerHTML.toString()\n\n    val ws = WebSocket(\"ws://localhost:8080/main/chats/${name}\").apply {\n        onopen = {\n            println(\"connected\")\n            println(document.URL)\n        }\n        onmessage = {\n            println(\"We got a message: ${it.data as String}\")\n            val div = document.getElementById(\"history\") as HTMLDivElement\n\n            div.innerHTML = \"${div.innerHTML}<br>${it.data as String}\"\n\n            Unit\n        }\n    }\n\n    (document.getElementById(\"send\") as HTMLInputElement).apply {\n        onclick = {\n            val message = (document.getElementById(\"message\") as HTMLInputElement).value\n\n            ws.send(message)\n        }\n    }\n\n    (document.getElementById(\"clear\") as HTMLButtonElement).apply {\n       value = \"Clear\"\n        onclick = {\n            ws.send(\"cleaning\")\n        }\n    }\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","import csstype.px\nimport csstype.rgb\nimport react.FC\nimport react.Props\nimport emotion.react.css\nimport react.dom.html.InputType\nimport react.dom.html.ReactHTML.div\nimport react.dom.html.ReactHTML.input\nimport react.useState\n\nexternal interface WelcomeProps : Props {\n    var name: String\n}\n\nval Welcome = FC<WelcomeProps> { props ->\n    var name by useState(props.name)\n    div {\n        css {\n            padding = 5.px\n            backgroundColor = rgb(8, 97, 22)\n            color = rgb(56, 246, 137)\n        }\n        +\"Hello, $name\"\n    }\n    input {\n        css {\n            marginTop = 5.px\n            marginBottom = 5.px\n            fontSize = 14.px\n        }\n        type = InputType.text\n        value = name\n        onChange = { event ->\n            name = event.target.value\n        }\n    }\n}",null,null,"(function (root, factory) {\n  if (typeof define === 'function' && define.amd)\n    define(['exports', 'kotlin', 'kotlin-extensions'], factory);\n  else if (typeof exports === 'object')\n    factory(module.exports, require('kotlin'), require('kotlin-extensions'));\n  else {\n    if (typeof kotlin === 'undefined') {\n      throw new Error(\"Error loading module 'kotlin-csstype'. Its dependency 'kotlin' was not found. Please, check whether 'kotlin' is loaded prior to 'kotlin-csstype'.\");\n    }\n    if (typeof this['kotlin-extensions'] === 'undefined') {\n      throw new Error(\"Error loading module 'kotlin-csstype'. Its dependency 'kotlin-extensions' was not found. Please, check whether 'kotlin-extensions' is loaded prior to 'kotlin-csstype'.\");\n    }\n    root['kotlin-csstype'] = factory(typeof this['kotlin-csstype'] === 'undefined' ? {} : this['kotlin-csstype'], kotlin, this['kotlin-extensions']);\n  }\n}(this, function (_, Kotlin, $module$kotlin_extensions) {\n  'use strict';\n  var defineInlineFunction = Kotlin.defineInlineFunction;\n  var Kind_INTERFACE = Kotlin.Kind.INTERFACE;\n  var Kind_CLASS = Kotlin.Kind.CLASS;\n  return _;\n}));\n\n//# sourceMappingURL=kotlin-csstype.js.map\n","(function (root, factory) {\n  if (typeof define === 'function' && define.amd)\n    define(['exports', 'kotlin', 'kotlin-extensions', '@emotion/css', 'kotlin-csstype', '@emotion/styled'], factory);\n  else if (typeof exports === 'object')\n    factory(module.exports, require('kotlin'), require('kotlin-extensions'), require('@emotion/css'), require('kotlin-csstype'), require('@emotion/styled'));\n  else {\n    if (typeof kotlin === 'undefined') {\n      throw new Error(\"Error loading module 'kotlin-emotion'. Its dependency 'kotlin' was not found. Please, check whether 'kotlin' is loaded prior to 'kotlin-emotion'.\");\n    }\n    if (typeof this['kotlin-extensions'] === 'undefined') {\n      throw new Error(\"Error loading module 'kotlin-emotion'. Its dependency 'kotlin-extensions' was not found. Please, check whether 'kotlin-extensions' is loaded prior to 'kotlin-emotion'.\");\n    }\n    if (typeof this['@emotion/css'] === 'undefined') {\n      throw new Error(\"Error loading module 'kotlin-emotion'. Its dependency '@emotion/css' was not found. Please, check whether '@emotion/css' is loaded prior to 'kotlin-emotion'.\");\n    }\n    if (typeof this['kotlin-csstype'] === 'undefined') {\n      throw new Error(\"Error loading module 'kotlin-emotion'. Its dependency 'kotlin-csstype' was not found. Please, check whether 'kotlin-csstype' is loaded prior to 'kotlin-emotion'.\");\n    }\n    if (typeof this['@emotion/styled'] === 'undefined') {\n      throw new Error(\"Error loading module 'kotlin-emotion'. Its dependency '@emotion/styled' was not found. Please, check whether '@emotion/styled' is loaded prior to 'kotlin-emotion'.\");\n    }\n    root['kotlin-emotion'] = factory(typeof this['kotlin-emotion'] === 'undefined' ? {} : this['kotlin-emotion'], kotlin, this['kotlin-extensions'], this['@emotion/css'], this['kotlin-csstype'], this['@emotion/styled']);\n  }\n}(this, function (_, Kotlin, $module$kotlin_extensions, $module$_emotion_css, $module$kotlin_csstype, $module$_emotion_styled) {\n  'use strict';\n  var $$importsForInline$$ = _.$$importsForInline$$ || (_.$$importsForInline$$ = {});\n  var defineInlineFunction = Kotlin.defineInlineFunction;\n  var wrapFunction = Kotlin.wrapFunction;\n  var Kind_CLASS = Kotlin.Kind.CLASS;\n  var FROM_PERCENTAGE;\n  var TO_PERCENTAGE;\n  var index;\n  $$importsForInline$$['@emotion/css'] = $module$_emotion_css;\n  FROM_PERCENTAGE = (0).toString() + '%';\n  TO_PERCENTAGE = (100).toString() + '%';\n  index = 0;\n  return _;\n}));\n\n//# sourceMappingURL=kotlin-emotion.js.map\n","(function (root, factory) {\n  if (typeof define === 'function' && define.amd)\n    define(['exports', 'kotlin'], factory);\n  else if (typeof exports === 'object')\n    factory(module.exports, require('kotlin'));\n  else {\n    if (typeof kotlin === 'undefined') {\n      throw new Error(\"Error loading module 'kotlin-extensions'. Its dependency 'kotlin' was not found. Please, check whether 'kotlin' is loaded prior to 'kotlin-extensions'.\");\n    }\n    root['kotlin-extensions'] = factory(typeof this['kotlin-extensions'] === 'undefined' ? {} : this['kotlin-extensions'], kotlin);\n  }\n}(this, function (_, Kotlin) {\n  'use strict';\n  var defineInlineFunction = Kotlin.defineInlineFunction;\n  var wrapFunction = Kotlin.wrapFunction;\n  var Kind_CLASS = Kotlin.Kind.CLASS;\n  var Iterator = Kotlin.kotlin.collections.Iterator;\n  var IllegalStateException_init = Kotlin.kotlin.IllegalStateException_init_pdl1vj$;\n  var Kind_INTERFACE = Kotlin.Kind.INTERFACE;\n  return _;\n}));\n\n//# sourceMappingURL=kotlin-extensions.js.map\n","(function (root, factory) {\n  if (typeof define === 'function' && define.amd)\n    define(['exports', 'kotlin', 'react'], factory);\n  else if (typeof exports === 'object')\n    factory(module.exports, require('kotlin'), require('react'));\n  else {\n    if (typeof kotlin === 'undefined') {\n      throw new Error(\"Error loading module 'kotlin-react-core'. Its dependency 'kotlin' was not found. Please, check whether 'kotlin' is loaded prior to 'kotlin-react-core'.\");\n    }\n    if (typeof react === 'undefined') {\n      throw new Error(\"Error loading module 'kotlin-react-core'. Its dependency 'react' was not found. Please, check whether 'react' is loaded prior to 'kotlin-react-core'.\");\n    }\n    root['kotlin-react-core'] = factory(typeof this['kotlin-react-core'] === 'undefined' ? {} : this['kotlin-react-core'], kotlin, react);\n  }\n}(this, function (_, Kotlin, $module$react) {\n  'use strict';\n  var $$importsForInline$$ = _.$$importsForInline$$ || (_.$$importsForInline$$ = {});\n  var Kind_CLASS = Kotlin.Kind.CLASS;\n  var defineInlineFunction = Kotlin.defineInlineFunction;\n  var Unit = Kotlin.kotlin.Unit;\n  var wrapFunction = Kotlin.wrapFunction;\n  var isValidElement = $module$react.isValidElement;\n  var IllegalArgumentException_init = Kotlin.kotlin.IllegalArgumentException_init_pdl1vj$;\n  $$importsForInline$$.react = $module$react;\n  return _;\n}));\n\n//# sourceMappingURL=kotlin-react-core.js.map\n","(function (root, factory) {\n  if (typeof define === 'function' && define.amd)\n    define(['exports', 'kotlin'], factory);\n  else if (typeof exports === 'object')\n    factory(module.exports, require('kotlin'));\n  else {\n    if (typeof kotlin === 'undefined') {\n      throw new Error(\"Error loading module 'kotlin-react-dom'. Its dependency 'kotlin' was not found. Please, check whether 'kotlin' is loaded prior to 'kotlin-react-dom'.\");\n    }\n    root['kotlin-react-dom'] = factory(typeof this['kotlin-react-dom'] === 'undefined' ? {} : this['kotlin-react-dom'], kotlin);\n  }\n}(this, function (_, Kotlin) {\n  'use strict';\n  var defineInlineFunction = Kotlin.defineInlineFunction;\n  var Kind_OBJECT = Kotlin.Kind.OBJECT;\n  function ReactHTML() {\n    ReactHTML_instance = this;\n  }\n  Object.defineProperty(ReactHTML.prototype, 'a', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_a', function () {\n    return 'a';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'abbr', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_abbr', function () {\n    return 'abbr';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'address', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_address', function () {\n    return 'address';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'area', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_area', function () {\n    return 'area';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'article', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_article', function () {\n    return 'article';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'aside', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_aside', function () {\n    return 'aside';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'audio', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_audio', function () {\n    return 'audio';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'b', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_b', function () {\n    return 'b';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'base', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_base', function () {\n    return 'base';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'bdi', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_bdi', function () {\n    return 'bdi';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'bdo', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_bdo', function () {\n    return 'bdo';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'big', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_big', function () {\n    return 'big';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'blockquote', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_blockquote', function () {\n    return 'blockquote';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'body', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_body', function () {\n    return 'body';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'br', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_br', function () {\n    return 'br';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'button', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_button', function () {\n    return 'button';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'canvas', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_canvas', function () {\n    return 'canvas';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'caption', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_caption', function () {\n    return 'caption';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'cite', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_cite', function () {\n    return 'cite';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'code', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_code', function () {\n    return 'code';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'col', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_col', function () {\n    return 'col';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'colgroup', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_colgroup', function () {\n    return 'colgroup';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'data', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_data', function () {\n    return 'data';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'datalist', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_datalist', function () {\n    return 'datalist';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'dd', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_dd', function () {\n    return 'dd';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'del', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_del', function () {\n    return 'del';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'details', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_details', function () {\n    return 'details';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'dfn', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_dfn', function () {\n    return 'dfn';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'dialog', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_dialog', function () {\n    return 'dialog';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'div', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_div', function () {\n    return 'div';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'dl', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_dl', function () {\n    return 'dl';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'dt', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_dt', function () {\n    return 'dt';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'em', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_em', function () {\n    return 'em';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'embed', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_embed', function () {\n    return 'embed';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'fieldset', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_fieldset', function () {\n    return 'fieldset';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'figcaption', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_figcaption', function () {\n    return 'figcaption';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'figure', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_figure', function () {\n    return 'figure';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'footer', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_footer', function () {\n    return 'footer';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'form', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_form', function () {\n    return 'form';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'h1', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_h1', function () {\n    return 'h1';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'h2', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_h2', function () {\n    return 'h2';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'h3', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_h3', function () {\n    return 'h3';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'h4', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_h4', function () {\n    return 'h4';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'h5', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_h5', function () {\n    return 'h5';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'h6', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_h6', function () {\n    return 'h6';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'head', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_head', function () {\n    return 'head';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'header', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_header', function () {\n    return 'header';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'hgroup', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_hgroup', function () {\n    return 'hgroup';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'hr', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_hr', function () {\n    return 'hr';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'html', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_html', function () {\n    return 'html';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'i', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_i', function () {\n    return 'i';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'iframe', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_iframe', function () {\n    return 'iframe';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'img', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_img', function () {\n    return 'img';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'input', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_input', function () {\n    return 'input';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'ins', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_ins', function () {\n    return 'ins';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'kbd', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_kbd', function () {\n    return 'kbd';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'keygen', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_keygen', function () {\n    return 'keygen';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'label', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_label', function () {\n    return 'label';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'legend', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_legend', function () {\n    return 'legend';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'li', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_li', function () {\n    return 'li';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'link', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_link', function () {\n    return 'link';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'main', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_main', function () {\n    return 'main';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'map', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_map', function () {\n    return 'map';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'mark', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_mark', function () {\n    return 'mark';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'menu', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_menu', function () {\n    return 'menu';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'menuitem', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_menuitem', function () {\n    return 'menuitem';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'meta', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_meta', function () {\n    return 'meta';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'meter', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_meter', function () {\n    return 'meter';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'nav', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_nav', function () {\n    return 'nav';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'noscript', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_noscript', function () {\n    return 'noscript';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'object', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_object', function () {\n    return 'object';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'ol', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_ol', function () {\n    return 'ol';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'optgroup', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_optgroup', function () {\n    return 'optgroup';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'option', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_option', function () {\n    return 'option';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'output', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_output', function () {\n    return 'output';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'p', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_p', function () {\n    return 'p';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'param', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_param', function () {\n    return 'param';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'picture', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_picture', function () {\n    return 'picture';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'pre', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_pre', function () {\n    return 'pre';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'progress', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_progress', function () {\n    return 'progress';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'q', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_q', function () {\n    return 'q';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'rp', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_rp', function () {\n    return 'rp';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'rt', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_rt', function () {\n    return 'rt';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'ruby', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_ruby', function () {\n    return 'ruby';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 's', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_s', function () {\n    return 's';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'samp', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_samp', function () {\n    return 'samp';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'slot', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_slot', function () {\n    return 'slot';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'script', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_script', function () {\n    return 'script';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'section', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_section', function () {\n    return 'section';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'select', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_select', function () {\n    return 'select';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'small', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_small', function () {\n    return 'small';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'source', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_source', function () {\n    return 'source';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'span', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_span', function () {\n    return 'span';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'strong', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_strong', function () {\n    return 'strong';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'style', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_style', function () {\n    return 'style';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'sub', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_sub', function () {\n    return 'sub';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'summary', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_summary', function () {\n    return 'summary';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'sup', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_sup', function () {\n    return 'sup';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'table', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_table', function () {\n    return 'table';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'template', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_template', function () {\n    return 'template';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'tbody', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_tbody', function () {\n    return 'tbody';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'td', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_td', function () {\n    return 'td';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'textarea', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_textarea', function () {\n    return 'textarea';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'tfoot', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_tfoot', function () {\n    return 'tfoot';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'th', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_th', function () {\n    return 'th';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'thead', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_thead', function () {\n    return 'thead';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'time', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_time', function () {\n    return 'time';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'title', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_title', function () {\n    return 'title';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'tr', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_tr', function () {\n    return 'tr';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'track', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_track', function () {\n    return 'track';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'u', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_u', function () {\n    return 'u';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'ul', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_ul', function () {\n    return 'ul';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'var', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_var', function () {\n    return 'var';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'video', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_video', function () {\n    return 'video';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'wbr', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_wbr', function () {\n    return 'wbr';\n  })});\n  Object.defineProperty(ReactHTML.prototype, 'webview', {configurable: true, get: defineInlineFunction('kotlin-react-dom.react.dom.html.ReactHTML.get_webview', function () {\n    return 'webview';\n  })});\n  ReactHTML.$metadata$ = {kind: Kind_OBJECT, simpleName: 'ReactHTML', interfaces: []};\n  var ReactHTML_instance = null;\n  function ReactHTML_getInstance() {\n    if (ReactHTML_instance === null) {\n      new ReactHTML();\n    }\n    return ReactHTML_instance;\n  }\n  var ReactSVG_instance = null;\n  var FormEncType_instance = null;\n  var FormMethod_instance = null;\n  var package$react = _.react || (_.react = {});\n  var package$dom = package$react.dom || (package$react.dom = {});\n  var package$html = package$dom.html || (package$dom.html = {});\n  Object.defineProperty(package$html, 'ReactHTML', {get: ReactHTML_getInstance});\n  return _;\n}));\n\n//# sourceMappingURL=kotlin-react-dom.js.map\n","(function (root, factory) {\n  if (typeof define === 'function' && define.amd)\n    define(['exports', 'kotlin', 'kotlin-react-core', 'react'], factory);\n  else if (typeof exports === 'object')\n    factory(module.exports, require('kotlin'), require('kotlin-react-core'), require('react'));\n  else {\n    if (typeof kotlin === 'undefined') {\n      throw new Error(\"Error loading module 'kotlin-react'. Its dependency 'kotlin' was not found. Please, check whether 'kotlin' is loaded prior to 'kotlin-react'.\");\n    }\n    if (typeof this['kotlin-react-core'] === 'undefined') {\n      throw new Error(\"Error loading module 'kotlin-react'. Its dependency 'kotlin-react-core' was not found. Please, check whether 'kotlin-react-core' is loaded prior to 'kotlin-react'.\");\n    }\n    if (typeof react === 'undefined') {\n      throw new Error(\"Error loading module 'kotlin-react'. Its dependency 'react' was not found. Please, check whether 'react' is loaded prior to 'kotlin-react'.\");\n    }\n    root['kotlin-react'] = factory(typeof this['kotlin-react'] === 'undefined' ? {} : this['kotlin-react'], kotlin, this['kotlin-react-core'], react);\n  }\n}(this, function (_, Kotlin, $module$kotlin_react_core, $module$react) {\n  'use strict';\n  var $$importsForInline$$ = _.$$importsForInline$$ || (_.$$importsForInline$$ = {});\n  var defineInlineFunction = Kotlin.defineInlineFunction;\n  var createElement = $module$react.createElement;\n  var Unit = Kotlin.kotlin.Unit;\n  var Kind_INTERFACE = Kotlin.Kind.INTERFACE;\n  var Kind_CLASS = Kotlin.Kind.CLASS;\n  var single = Kotlin.kotlin.collections.single_us0mfu$;\n  var isValidElement = $module$react.isValidElement;\n  var CHILDREN;\n  function ChildrenBuilder() {\n  }\n  ChildrenBuilder.prototype.unaryPlus_lapc4x$ = function ($receiver) {\n    Object.assign(this, $receiver);\n  };\n  ChildrenBuilder.prototype.child_m8hz59$ = function (element) {\n    if (this[CHILDREN] != null) {\n      this[CHILDREN].push(element);\n    } else {\n      this[CHILDREN] = [element];\n    }\n  };\n  ChildrenBuilder.prototype.unaryPlus_kzna72$ = function ($receiver) {\n    this.child_m8hz59$($receiver);\n  };\n  ChildrenBuilder.prototype.unaryPlus_pdl1vz$ = function ($receiver) {\n    this.unaryPlus_kzna72$($receiver);\n  };\n  ChildrenBuilder.prototype.child_sv8fgx$ = function (type, props) {\n    this.unaryPlus_kzna72$(createElement(type, props));\n  };\n  ChildrenBuilder.prototype.invoke_r7bapy$ = function ($receiver) {\n    this.unaryPlus_kzna72$(createElement($receiver));\n  };\n  ChildrenBuilder.prototype.invoke_gax9jq$ = function ($receiver, block) {\n    this.unaryPlus_kzna72$(create_0($receiver, block));\n  };\n  function ChildrenBuilder$invoke$lambda(closure$value, closure$block) {\n    return function ($receiver) {\n      $receiver.value = closure$value;\n      closure$block($receiver);\n      return Unit;\n    };\n  }\n  ChildrenBuilder.prototype.invoke_1uzlnf$ = function ($receiver, value, block) {\n    this.invoke_gax9jq$($receiver.Provider, ChildrenBuilder$invoke$lambda(value, block));\n  };\n  function ChildrenBuilder$invoke$lambda_0(closure$value, closure$block) {\n    return function ($receiver) {\n      $receiver.value = closure$value;\n      closure$block($receiver);\n      return Unit;\n    };\n  }\n  ChildrenBuilder.prototype.invoke_snd3xh$ = function ($receiver, value, block) {\n    this.invoke_gax9jq$($receiver, ChildrenBuilder$invoke$lambda_0(value, block));\n  };\n  ChildrenBuilder.$metadata$ = {kind: Kind_INTERFACE, simpleName: 'ChildrenBuilder', interfaces: []};\n  function ChildrenBuilder_0() {\n    return new ChildrenBuilderImpl();\n  }\n  function ChildrenBuilderImpl() {\n  }\n  ChildrenBuilderImpl.$metadata$ = {kind: Kind_CLASS, simpleName: 'ChildrenBuilderImpl', interfaces: [ChildrenBuilder]};\n  function FC$lambda$lambda(closure$block, closure$props) {\n    return function ($receiver) {\n      closure$block($receiver, closure$props);\n      return Unit;\n    };\n  }\n  function FC$lambda(closure$block) {\n    return function (props) {\n      return createElementOrNull(FC$lambda$lambda(closure$block, props));\n    };\n  }\n  function FC(block) {\n    var component = FC$lambda(block);\n    return component;\n  }\n  function create_0($receiver, block) {\n    var tmp$;\n    var builder = ChildrenBuilder_0();\n    block(builder);\n    var props = builder;\n    var children = (tmp$ = builder[CHILDREN]) != null ? tmp$ : [];\n    return createElement.apply(null, [$receiver, props].concat(children));\n  }\n  function createElementOrNull(block) {\n    var tmp$, tmp$_0;\n    var $receiver = ChildrenBuilder_0();\n    block($receiver);\n    tmp$ = $receiver[CHILDREN];\n    if (tmp$ == null) {\n      return null;\n    }\n    var children = tmp$;\n    if (children.length === 0)\n      return null;\n    if (children.length === 1) {\n      tmp$_0 = single(children);\n      if (tmp$_0 == null) {\n        return null;\n      }\n      var child = tmp$_0;\n      if (isValidElement(child)) {\n        return child;\n      }\n    }\n    return createElement.apply(null, [$module$react.Fragment, void 0].concat(children));\n  }\n  var package$react = _.react || (_.react = {});\n  $$importsForInline$$['kotlin-react-core'] = $module$kotlin_react_core;\n  package$react.ChildrenBuilder = ChildrenBuilder;\n  package$react.createChildrenBuilder = ChildrenBuilder_0;\n  package$react.FC_4y0n3r$ = FC;\n  package$react.create_gax9jq$ = create_0;\n  package$react.createElementOrNull_khlwf$ = createElementOrNull;\n  ChildrenBuilderImpl.prototype.unaryPlus_lapc4x$ = ChildrenBuilder.prototype.unaryPlus_lapc4x$;\n  ChildrenBuilderImpl.prototype.unaryPlus_kzna72$ = ChildrenBuilder.prototype.unaryPlus_kzna72$;\n  ChildrenBuilderImpl.prototype.unaryPlus_pdl1vz$ = ChildrenBuilder.prototype.unaryPlus_pdl1vz$;\n  ChildrenBuilderImpl.prototype.child_m8hz59$ = ChildrenBuilder.prototype.child_m8hz59$;\n  ChildrenBuilderImpl.prototype.child_sv8fgx$ = ChildrenBuilder.prototype.child_sv8fgx$;\n  ChildrenBuilderImpl.prototype.invoke_r7bapy$ = ChildrenBuilder.prototype.invoke_r7bapy$;\n  ChildrenBuilderImpl.prototype.invoke_gax9jq$ = ChildrenBuilder.prototype.invoke_gax9jq$;\n  ChildrenBuilderImpl.prototype.invoke_1uzlnf$ = ChildrenBuilder.prototype.invoke_1uzlnf$;\n  ChildrenBuilderImpl.prototype.invoke_snd3xh$ = ChildrenBuilder.prototype.invoke_snd3xh$;\n  CHILDREN = Symbol('@@children');\n  return _;\n}));\n\n//# sourceMappingURL=kotlin-react.js.map\n","(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define('kotlin', ['exports'], factory);\n    }\n    else if (typeof exports === 'object') {\n        factory(module.exports);\n    }\n    else {\n        root.kotlin = {};\n        factory(root.kotlin);\n    }\n}(this, function (Kotlin) {\n    var _ = Kotlin;\n\n    insertContent();\n}));\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.isBooleanArray = function (a) {\n    return (Array.isArray(a) || a instanceof Int8Array) && a.$type$ === \"BooleanArray\"\n};\n\nKotlin.isByteArray = function (a) {\n    return a instanceof Int8Array && a.$type$ !== \"BooleanArray\"\n};\n\nKotlin.isShortArray = function (a) {\n    return a instanceof Int16Array\n};\n\nKotlin.isCharArray = function (a) {\n    return a instanceof Uint16Array && a.$type$ === \"CharArray\"\n};\n\nKotlin.isIntArray = function (a) {\n    return a instanceof Int32Array\n};\n\nKotlin.isFloatArray = function (a) {\n    return a instanceof Float32Array\n};\n\nKotlin.isDoubleArray = function (a) {\n    return a instanceof Float64Array\n};\n\nKotlin.isLongArray = function (a) {\n    return Array.isArray(a) && a.$type$ === \"LongArray\"\n};\n\nKotlin.isArray = function (a) {\n    return Array.isArray(a) && !a.$type$;\n};\n\nKotlin.isArrayish = function (a) {\n    return Array.isArray(a) || ArrayBuffer.isView(a)\n};\n\nKotlin.arrayToString = function (a) {\n    if (a === null) return \"null\"\n    var toString = Kotlin.isCharArray(a) ? String.fromCharCode : Kotlin.toString;\n    return \"[\" + Array.prototype.map.call(a, function(e) { return toString(e); }).join(\", \") + \"]\";\n};\n\nKotlin.arrayDeepToString = function (arr) {\n    return Kotlin.kotlin.collections.contentDeepToStringImpl(arr);\n};\n\nKotlin.arrayEquals = function (a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (a === null || b === null || !Kotlin.isArrayish(b) || a.length !== b.length) {\n        return false;\n    }\n\n    for (var i = 0, n = a.length; i < n; i++) {\n        if (!Kotlin.equals(a[i], b[i])) {\n            return false;\n        }\n    }\n    return true;\n};\n\nKotlin.arrayDeepEquals = function (a, b) {\n    return Kotlin.kotlin.collections.contentDeepEqualsImpl(a, b);\n};\n\nKotlin.arrayHashCode = function (arr) {\n    if (arr === null) return 0\n    var result = 1;\n    for (var i = 0, n = arr.length; i < n; i++) {\n        result = ((31 * result | 0) + Kotlin.hashCode(arr[i])) | 0;\n    }\n    return result;\n};\n\nKotlin.arrayDeepHashCode = function (arr) {\n    return Kotlin.kotlin.collections.contentDeepHashCodeImpl(arr);\n};\n\nKotlin.primitiveArraySort = function (array) {\n    array.sort(Kotlin.doubleCompareTo)\n};\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.toShort = function (a) {\n    return (a & 0xFFFF) << 16 >> 16;\n};\n\nKotlin.toByte = function (a) {\n    return (a & 0xFF) << 24 >> 24;\n};\n\nKotlin.toChar = function (a) {\n    return a & 0xFFFF;\n};\n\nKotlin.numberToLong = function (a) {\n    return a instanceof Kotlin.Long ? a : Kotlin.Long.fromNumber(a);\n};\n\nKotlin.numberToInt = function (a) {\n    return a instanceof Kotlin.Long ? a.toInt() : Kotlin.doubleToInt(a);\n};\n\nKotlin.numberToShort = function (a) {\n    return Kotlin.toShort(Kotlin.numberToInt(a));\n};\n\nKotlin.numberToByte = function (a) {\n    return Kotlin.toByte(Kotlin.numberToInt(a));\n};\n\nKotlin.numberToDouble = function (a) {\n    return +a;\n};\n\nKotlin.numberToChar = function (a) {\n    return Kotlin.toChar(Kotlin.numberToInt(a));\n};\n\nKotlin.doubleToInt = function(a) {\n    if (a > 2147483647) return 2147483647;\n    if (a < -2147483648) return -2147483648;\n    return a | 0;\n};\n\nKotlin.toBoxedChar = function (a) {\n    if (a == null) return a;\n    if (a instanceof Kotlin.BoxedChar) return a;\n    return new Kotlin.BoxedChar(a);\n};\n\nKotlin.unboxChar = function(a) {\n    if (a == null) return a;\n    return Kotlin.toChar(a);\n};\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.equals = function (obj1, obj2) {\n    if (obj1 == null) {\n        return obj2 == null;\n    }\n\n    if (obj2 == null) {\n        return false;\n    }\n\n    if (obj1 !== obj1) {\n        return obj2 !== obj2;\n    }\n\n    if (typeof obj1 === \"object\" && typeof obj1.equals === \"function\") {\n        return obj1.equals(obj2);\n    }\n\n    if (typeof obj1 === \"number\" && typeof obj2 === \"number\") {\n        return obj1 === obj2 && (obj1 !== 0 || 1 / obj1 === 1 / obj2)\n    }\n\n    return obj1 === obj2;\n};\n\nKotlin.hashCode = function (obj) {\n    if (obj == null) {\n        return 0;\n    }\n    var objType = typeof obj;\n    if (\"object\" === objType) {\n        return \"function\" === typeof obj.hashCode ? obj.hashCode() : getObjectHashCode(obj);\n    }\n    if (\"function\" === objType) {\n        return getObjectHashCode(obj);\n    }\n    if (\"number\" === objType) {\n        return Kotlin.numberHashCode(obj);\n    }\n    if (\"boolean\" === objType) {\n        return Number(obj)\n    }\n\n    var str = String(obj);\n    return getStringHashCode(str);\n};\n\n\nKotlin.toString = function (o) {\n    if (o == null) {\n        return \"null\";\n    }\n    else if (Kotlin.isArrayish(o)) {\n        return \"[...]\";\n    }\n    else {\n        return o.toString();\n    }\n};\n\n/** @const */\nvar POW_2_32 = 4294967296;\n// TODO: consider switching to Symbol type once we are on ES6.\n/** @const */\nvar OBJECT_HASH_CODE_PROPERTY_NAME = \"kotlinHashCodeValue$\";\n\nfunction getObjectHashCode(obj) {\n    if (!(OBJECT_HASH_CODE_PROPERTY_NAME in obj)) {\n        var hash = (Math.random() * POW_2_32) | 0; // Make 32-bit singed integer.\n        Object.defineProperty(obj, OBJECT_HASH_CODE_PROPERTY_NAME, { value:  hash, enumerable: false });\n    }\n    return obj[OBJECT_HASH_CODE_PROPERTY_NAME];\n}\n\nfunction getStringHashCode(str) {\n    var hash = 0;\n    for (var i = 0; i < str.length; i++) {\n        var code  = str.charCodeAt(i);\n        hash  = (hash * 31 + code) | 0; // Keep it 32-bit.\n    }\n    return hash;\n}\n\nKotlin.identityHashCode = getObjectHashCode;\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.compareTo = function (a, b) {\n    var typeA = typeof a;\n    if (typeA === \"number\") {\n        if (typeof b === \"number\") {\n            return Kotlin.doubleCompareTo(a, b);\n        }\n        return Kotlin.primitiveCompareTo(a, b);\n    }\n    if (typeA === \"string\" || typeA === \"boolean\") {\n        return Kotlin.primitiveCompareTo(a, b);\n    }\n    return a.compareTo_11rb$(b);\n};\n\nKotlin.primitiveCompareTo = function (a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n};\n\nKotlin.doubleCompareTo = function (a, b) {\n    if (a < b) return -1;\n    if (a > b) return 1;\n\n    if (a === b) {\n        if (a !== 0) return 0;\n\n        var ia = 1 / a;\n        return ia === 1 / b ? 0 : (ia < 0 ? -1 : 1);\n    }\n\n    return a !== a ? (b !== b ? 0 : 1) : -1\n};\n\nKotlin.charInc = function (value) {\n    return Kotlin.toChar(value+1);\n};\n\nKotlin.charDec = function (value) {\n    return Kotlin.toChar(value-1);\n};\n\nKotlin.imul = Math.imul || imul;\n\nKotlin.imulEmulated = imul;\n\nfunction imul(a, b) {\n    return ((a & 0xffff0000) * (b & 0xffff) + (a & 0xffff) * (b | 0)) | 0;\n}\n\n(function() {\n    var buf = new ArrayBuffer(8);\n    var bufFloat64 = new Float64Array(buf);\n    var bufFloat32 = new Float32Array(buf);\n    var bufInt32 = new Int32Array(buf);\n    var lowIndex = 0;\n    var highIndex = 1;\n\n    bufFloat64[0] = -1; // bff00000_00000000\n    if (bufInt32[lowIndex] !== 0) {\n        lowIndex = 1;\n        highIndex = 0;\n    }\n\n    Kotlin.doubleToBits = function(value) {\n        return Kotlin.doubleToRawBits(isNaN(value) ? NaN : value);\n    };\n\n    Kotlin.doubleToRawBits = function(value) {\n        bufFloat64[0] = value;\n        return Kotlin.Long.fromBits(bufInt32[lowIndex], bufInt32[highIndex]);\n    };\n\n    Kotlin.doubleFromBits = function(value) {\n        bufInt32[lowIndex] = value.low_;\n        bufInt32[highIndex] = value.high_;\n        return bufFloat64[0];\n    };\n\n    Kotlin.floatToBits = function(value) {\n        return Kotlin.floatToRawBits(isNaN(value) ? NaN : value);\n    };\n\n    Kotlin.floatToRawBits = function(value) {\n        bufFloat32[0] = value;\n        return bufInt32[0];\n    };\n\n    Kotlin.floatFromBits = function(value) {\n        bufInt32[0] = value;\n        return bufFloat32[0];\n    };\n\n    // returns zero value for number with positive sign bit and non-zero value for number with negative sign bit.\n    Kotlin.doubleSignBit = function(value) {\n        bufFloat64[0] = value;\n        return bufInt32[highIndex] & 0x80000000;\n    };\n\n    Kotlin.numberHashCode = function(obj) {\n        if ((obj | 0) === obj) {\n            return obj | 0;\n        }\n        else {\n            bufFloat64[0] = obj;\n            return (bufInt32[highIndex] * 31 | 0) + bufInt32[lowIndex] | 0;\n        }\n    }\n})();\n\nKotlin.ensureNotNull = function(x) {\n    return x != null ? x : Kotlin.throwNPE();\n};\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nif (typeof String.prototype.startsWith === \"undefined\") {\n    Object.defineProperty(String.prototype, \"startsWith\", {\n        value: function (searchString, position) {\n            position = position || 0;\n            return this.lastIndexOf(searchString, position) === position;\n        }\n    });\n}\nif (typeof String.prototype.endsWith === \"undefined\") {\n    Object.defineProperty(String.prototype, \"endsWith\", {\n        value: function (searchString, position) {\n            var subjectString = this.toString();\n            if (position === undefined || position > subjectString.length) {\n                position = subjectString.length;\n            }\n            position -= searchString.length;\n            var lastIndex = subjectString.indexOf(searchString, position);\n            return lastIndex !== -1 && lastIndex === position;\n        }\n    });\n}\n// ES6 Math polyfills\nif (typeof Math.sign === \"undefined\") {\n    Math.sign = function(x) {\n        x = +x; // convert to a number\n        if (x === 0 || isNaN(x)) {\n            return Number(x);\n        }\n        return x > 0 ? 1 : -1;\n    };\n}\nif (typeof Math.trunc === \"undefined\") {\n    Math.trunc = function(x) {\n        if (isNaN(x)) {\n            return NaN;\n        }\n        if (x > 0) {\n            return Math.floor(x);\n        }\n        return Math.ceil(x);\n    };\n}\n\n(function() {\n    var epsilon = 2.220446049250313E-16;\n    var taylor_2_bound = Math.sqrt(epsilon);\n    var taylor_n_bound = Math.sqrt(taylor_2_bound);\n    var upper_taylor_2_bound = 1/taylor_2_bound;\n    var upper_taylor_n_bound = 1/taylor_n_bound;\n\n    if (typeof Math.sinh === \"undefined\") {\n        Math.sinh = function(x) {\n            if (Math.abs(x) < taylor_n_bound) {\n                var result = x;\n                if (Math.abs(x) > taylor_2_bound) {\n                    result += (x * x * x) / 6;\n                }\n                return result;\n            } else {\n                var y = Math.exp(x);\n                var y1 = 1 / y;\n                if (!isFinite(y)) return Math.exp(x - Math.LN2);\n                if (!isFinite(y1)) return -Math.exp(-x - Math.LN2);\n                return (y - y1) / 2;\n            }\n        };\n    }\n    if (typeof Math.cosh === \"undefined\") {\n        Math.cosh = function(x) {\n            var y = Math.exp(x);\n            var y1 = 1 / y;\n            if (!isFinite(y) || !isFinite(y1)) return Math.exp(Math.abs(x) - Math.LN2);\n            return (y + y1) / 2;\n        };\n    }\n\n    if (typeof Math.tanh === \"undefined\") {\n        Math.tanh = function(x){\n            if (Math.abs(x) < taylor_n_bound) {\n                var result = x;\n                if (Math.abs(x) > taylor_2_bound) {\n                    result -= (x * x * x) / 3;\n                }\n                return result;\n            }\n            else {\n                var a = Math.exp(+x), b = Math.exp(-x);\n                return a === Infinity ? 1 : b === Infinity ? -1 : (a - b) / (a + b);\n            }\n        };\n    }\n\n    // Inverse hyperbolic function implementations derived from boost special math functions,\n    // Copyright Eric Ford & Hubert Holin 2001.\n\n    if (typeof Math.asinh === \"undefined\") {\n        var asinh = function(x) {\n            if (x >= +taylor_n_bound)\n            {\n                if (x > upper_taylor_n_bound)\n                {\n                    if (x > upper_taylor_2_bound)\n                    {\n                        // approximation by laurent series in 1/x at 0+ order from -1 to 0\n                        return Math.log(x) + Math.LN2;\n                    }\n                    else\n                    {\n                        // approximation by laurent series in 1/x at 0+ order from -1 to 1\n                        return Math.log(x * 2 + (1 / (x * 2)));\n                    }\n                }\n                else\n                {\n                    return Math.log(x + Math.sqrt(x * x + 1));\n                }\n            }\n            else if (x <= -taylor_n_bound)\n            {\n                return -asinh(-x);\n            }\n            else\n            {\n                // approximation by taylor series in x at 0 up to order 2\n                var result = x;\n                if (Math.abs(x) >= taylor_2_bound)\n                {\n                    var x3 = x * x * x;\n                    // approximation by taylor series in x at 0 up to order 4\n                    result -= x3 / 6;\n                }\n                return result;\n            }\n        };\n        Math.asinh = asinh;\n    }\n    if (typeof Math.acosh === \"undefined\") {\n        Math.acosh = function(x) {\n            if (x < 1)\n            {\n                return NaN;\n            }\n            else if (x - 1 >= taylor_n_bound)\n            {\n                if (x > upper_taylor_2_bound)\n                {\n                    // approximation by laurent series in 1/x at 0+ order from -1 to 0\n                    return Math.log(x) + Math.LN2;\n                }\n                else\n                {\n                    return Math.log(x + Math.sqrt(x * x - 1));\n                }\n            }\n            else\n            {\n                var y = Math.sqrt(x - 1);\n                // approximation by taylor series in y at 0 up to order 2\n                var result = y;\n                if (y >= taylor_2_bound)\n                {\n                    var y3 = y * y * y;\n                    // approximation by taylor series in y at 0 up to order 4\n                    result -= y3 / 12;\n                }\n\n                return Math.sqrt(2) * result;\n            }\n        };\n    }\n    if (typeof Math.atanh === \"undefined\") {\n        Math.atanh = function(x) {\n            if (Math.abs(x) < taylor_n_bound) {\n                var result = x;\n                if (Math.abs(x) > taylor_2_bound) {\n                    result += (x * x * x) / 3;\n                }\n                return result;\n            }\n            return Math.log((1 + x) / (1 - x)) / 2;\n        };\n    }\n    if (typeof Math.log1p === \"undefined\") {\n        Math.log1p = function(x) {\n            if (Math.abs(x) < taylor_n_bound) {\n                var x2 = x * x;\n                var x3 = x2 * x;\n                var x4 = x3 * x;\n                // approximation by taylor series in x at 0 up to order 4\n                return (-x4 / 4 + x3 / 3 - x2 / 2 + x);\n            }\n            return Math.log(x + 1);\n        };\n    }\n    if (typeof Math.expm1 === \"undefined\") {\n        Math.expm1 = function(x) {\n            if (Math.abs(x) < taylor_n_bound) {\n                var x2 = x * x;\n                var x3 = x2 * x;\n                var x4 = x3 * x;\n                // approximation by taylor series in x at 0 up to order 4\n                return (x4 / 24 + x3 / 6 + x2 / 2 + x);\n            }\n            return Math.exp(x) - 1;\n        };\n    }\n})();\nif (typeof Math.hypot === \"undefined\") {\n    Math.hypot = function() {\n        var y = 0;\n        var length = arguments.length;\n\n        for (var i = 0; i < length; i++) {\n            if (arguments[i] === Infinity || arguments[i] === -Infinity) {\n                return Infinity;\n            }\n            y += arguments[i] * arguments[i];\n        }\n        return Math.sqrt(y);\n    };\n}\nif (typeof Math.log10 === \"undefined\") {\n    Math.log10 = function(x) {\n        return Math.log(x) * Math.LOG10E;\n    };\n}\nif (typeof Math.log2 === \"undefined\") {\n    Math.log2 = function(x) {\n        return Math.log(x) * Math.LOG2E;\n    };\n}\nif (typeof Math.clz32 === \"undefined\") {\n    Math.clz32 = (function(log, LN2) {\n        return function(x) {\n            var asUint = x >>> 0;\n            if (asUint === 0) {\n                return 32;\n            }\n            return 31 - (log(asUint) / LN2 | 0) | 0; // the \"| 0\" acts like math.floor\n        };\n    })(Math.log, Math.LN2);\n}\n\n// For HtmlUnit and PhantomJs\nif (typeof ArrayBuffer.isView === \"undefined\") {\n    ArrayBuffer.isView = function(a) {\n        return a != null && a.__proto__ != null && a.__proto__.__proto__ === Int8Array.prototype.__proto__;\n    };\n}\n\nif (typeof Array.prototype.fill === \"undefined\") {\n    // Polyfill from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill#Polyfill\n    Object.defineProperty(Array.prototype, 'fill', {\n        value: function (value) {\n\n            // Steps 1-2.\n            if (this == null) {\n                throw new TypeError('this is null or not defined');\n            }\n\n            var O = Object(this);\n\n            // Steps 3-5.\n            var len = O.length >>> 0;\n\n            // Steps 6-7.\n            var start = arguments[1];\n            var relativeStart = start >> 0;\n\n            // Step 8.\n            var k = relativeStart < 0 ?\n                    Math.max(len + relativeStart, 0) :\n                    Math.min(relativeStart, len);\n\n            // Steps 9-10.\n            var end = arguments[2];\n            var relativeEnd = end === undefined ?\n                              len : end >> 0;\n\n            // Step 11.\n            var finalValue = relativeEnd < 0 ?\n                             Math.max(len + relativeEnd, 0) :\n                             Math.min(relativeEnd, len);\n\n            // Step 12.\n            while (k < finalValue) {\n                O[k] = value;\n                k++;\n            }\n\n            // Step 13.\n            return O;\n        }\n    });\n}\n\n(function() {\n    function normalizeOffset(offset, length) {\n        if (offset < 0) return Math.max(0, offset + length);\n        return Math.min(offset, length);\n    }\n    function typedArraySlice(begin, end) {\n        if (typeof end === \"undefined\") {\n            end = this.length;\n        }\n        begin = normalizeOffset(begin || 0, this.length);\n        end = Math.max(begin, normalizeOffset(end, this.length));\n        return new this.constructor(this.subarray(begin, end));\n    }\n\n    var arrays = [Int8Array, Int16Array, Uint16Array, Int32Array, Float32Array, Float64Array];\n    for (var i = 0; i < arrays.length; ++i) {\n        var TypedArray = arrays[i];\n        if (typeof TypedArray.prototype.fill === \"undefined\") {\n            Object.defineProperty(TypedArray.prototype, 'fill', {\n                value: Array.prototype.fill\n            });\n        }\n        if (typeof TypedArray.prototype.slice === \"undefined\") {\n            Object.defineProperty(TypedArray.prototype, 'slice', {\n                value: typedArraySlice\n            });\n        }\n    }\n\n    // Patch apply to work with TypedArrays if needed.\n    try {\n        (function() {}).apply(null, new Int32Array(0))\n    } catch (e) {\n        var apply = Function.prototype.apply;\n        Object.defineProperty(Function.prototype, 'apply', {\n            value: function(self, array) {\n                return apply.call(this, self, [].slice.call(array));\n            }\n        });\n    }\n\n\n    // Patch map to work with TypedArrays if needed.\n    for (var i = 0; i < arrays.length; ++i) {\n        var TypedArray = arrays[i];\n        if (typeof TypedArray.prototype.map === \"undefined\") {\n            Object.defineProperty(TypedArray.prototype, 'map', {\n                value: function(callback, self) {\n                    return [].slice.call(this).map(callback, self);\n                }\n            });\n        }\n    }\n\n    // Patch sort to work with TypedArrays if needed.\n    // TODO: consider to remove following function and replace it with `Kotlin.doubleCompareTo` (see misc.js)\n    var totalOrderComparator = function (a, b) {\n        if (a < b) return -1;\n        if (a > b) return 1;\n\n        if (a === b) {\n            if (a !== 0) return 0;\n\n            var ia = 1 / a;\n            return ia === 1 / b ? 0 : (ia < 0 ? -1 : 1);\n        }\n\n        return a !== a ? (b !== b ? 0 : 1) : -1\n    };\n\n    for (var i = 0; i < arrays.length; ++i) {\n        var TypedArray = arrays[i];\n        if (typeof TypedArray.prototype.sort === \"undefined\") {\n            Object.defineProperty(TypedArray.prototype, 'sort', {\n                value: function(compareFunction) {\n                    return Array.prototype.sort.call(this, compareFunction || totalOrderComparator);\n                }\n            });\n        }\n    }\n})();\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/**\n * @param {string} id\n * @param {Object} declaration\n */\nKotlin.defineModule = function (id, declaration) {\n};\n\nKotlin.defineInlineFunction = function(tag, fun) {\n    return fun;\n};\n\nKotlin.wrapFunction = function(fun) {\n    var f = function() {\n        f = fun();\n        return f.apply(this, arguments);\n    };\n    return function() {\n        return f.apply(this, arguments);\n    };\n};\n\nKotlin.isTypeOf = function(type) {\n    return function (object) {\n        return typeof object === type;\n    }\n};\n\nKotlin.isInstanceOf = function (klass) {\n    return function (object) {\n        return Kotlin.isType(object, klass);\n    }\n};\n\nKotlin.orNull = function (fn) {\n    return function (object) {\n        return object == null || fn(object);\n    }\n};\n\nKotlin.andPredicate = function (a, b) {\n    return function (object) {\n        return a(object) && b(object);\n    }\n};\n\nKotlin.kotlinModuleMetadata = function (abiVersion, moduleName, data) {\n};\n\nKotlin.suspendCall = function(value) {\n    return value;\n};\n\nKotlin.coroutineResult = function(qualifier) {\n    throwMarkerError();\n};\n\nKotlin.coroutineController = function(qualifier) {\n    throwMarkerError();\n};\n\nKotlin.coroutineReceiver = function(qualifier) {\n    throwMarkerError();\n};\n\nKotlin.setCoroutineResult = function(value, qualifier) {\n    throwMarkerError();\n};\n\nKotlin.getReifiedTypeParameterKType = function(typeParameter) {\n    throwMarkerError();\n};\n\nfunction throwMarkerError() {\n    throw new Error(\n        \"This marker function should never been called. \" +\n        \"Looks like compiler did not eliminate it properly. \" +\n        \"Please, report an issue if you caught this exception.\");\n}\n\nKotlin.getFunctionById = function(id, defaultValue) {\n    return function() {\n        return defaultValue;\n    }\n};","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.Kind = {\n    CLASS: \"class\",\n    INTERFACE: \"interface\",\n    OBJECT: \"object\"\n};\n\nKotlin.callGetter = function (thisObject, klass, propertyName) {\n    var propertyDescriptor = Object.getOwnPropertyDescriptor(klass, propertyName);\n    if (propertyDescriptor != null && propertyDescriptor.get != null) {\n        return propertyDescriptor.get.call(thisObject);\n    }\n\n    propertyDescriptor = Object.getOwnPropertyDescriptor(thisObject, propertyName);\n    if (propertyDescriptor != null && \"value\" in propertyDescriptor) {\n        return thisObject[propertyName];\n    }\n\n    return Kotlin.callGetter(thisObject, Object.getPrototypeOf(klass), propertyName);\n};\n\nKotlin.callSetter = function (thisObject, klass, propertyName, value) {\n    var propertyDescriptor = Object.getOwnPropertyDescriptor(klass, propertyName);\n    if (propertyDescriptor != null && propertyDescriptor.set != null) {\n        propertyDescriptor.set.call(thisObject, value);\n        return;\n    }\n\n    propertyDescriptor = Object.getOwnPropertyDescriptor(thisObject, propertyName);\n    if (propertyDescriptor != null && \"value\" in propertyDescriptor) {\n        thisObject[propertyName] = value;\n        return\n    }\n\n    Kotlin.callSetter(thisObject, Object.getPrototypeOf(klass), propertyName, value);\n};\n\nfunction isInheritanceFromInterface(ctor, iface) {\n    if (ctor === iface) return true;\n\n    var metadata = ctor.$metadata$;\n    if (metadata != null) {\n        var interfaces = metadata.interfaces;\n        for (var i = 0; i < interfaces.length; i++) {\n            if (isInheritanceFromInterface(interfaces[i], iface)) {\n                return true;\n            }\n        }\n    }\n\n    var superPrototype = ctor.prototype != null ? Object.getPrototypeOf(ctor.prototype) : null;\n    var superConstructor = superPrototype != null ? superPrototype.constructor : null;\n    return superConstructor != null && isInheritanceFromInterface(superConstructor, iface);\n}\n\n/**\n *\n * @param {*} object\n * @param {Function|Object} klass\n * @returns {Boolean}\n */\nKotlin.isType = function (object, klass) {\n    if (klass === Object) {\n        switch (typeof object) {\n            case \"string\":\n            case \"number\":\n            case \"boolean\":\n            case \"function\":\n                return true;\n            default:\n                return object instanceof Object;\n        }\n    }\n\n    if (object == null || klass == null || (typeof object !== 'object' && typeof object !== 'function')) {\n        return false;\n    }\n\n    if (typeof klass === \"function\" && object instanceof klass) {\n        return true;\n    }\n\n    var proto = Object.getPrototypeOf(klass);\n    var constructor = proto != null ? proto.constructor : null;\n    if (constructor != null && \"$metadata$\" in constructor) {\n        var metadata = constructor.$metadata$;\n        if (metadata.kind === Kotlin.Kind.OBJECT) {\n            return object === klass;\n        }\n    }\n\n    var klassMetadata = klass.$metadata$;\n\n    // In WebKit (JavaScriptCore) for some interfaces from DOM typeof returns \"object\", nevertheless they can be used in RHS of instanceof\n    if (klassMetadata == null) {\n        return object instanceof klass;\n    }\n\n    if (klassMetadata.kind === Kotlin.Kind.INTERFACE && object.constructor != null) {\n        return isInheritanceFromInterface(object.constructor, klass);\n    }\n\n    return false;\n};\n\nKotlin.isNumber = function (a) {\n    return typeof a == \"number\" || a instanceof Kotlin.Long;\n};\n\nKotlin.isChar = function (value) {\n    return value instanceof Kotlin.BoxedChar\n};\n\nKotlin.isComparable = function (value) {\n    var type = typeof value;\n\n    return type === \"string\" ||\n           type === \"boolean\" ||\n           Kotlin.isNumber(value) ||\n           Kotlin.isType(value, Kotlin.kotlin.Comparable);\n};\n\nKotlin.isCharSequence = function (value) {\n    return typeof value === \"string\" || Kotlin.isType(value, Kotlin.kotlin.CharSequence);\n};","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Copyright 2009 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n/**\n * Constructs a 64-bit two's-complement integer, given its low and high 32-bit\n * values as *signed* integers.  See the from* functions below for more\n * convenient ways of constructing Longs.\n *\n * The internal representation of a long is the two given signed, 32-bit values.\n * We use 32-bit pieces because these are the size of integers on which\n * Javascript performs bit-operations.  For operations like addition and\n * multiplication, we split each number into 16-bit pieces, which can easily be\n * multiplied within Javascript's floating-point representation without overflow\n * or change in sign.\n *\n * In the algorithms below, we frequently reduce the negative case to the\n * positive case by negating the input(s) and then post-processing the result.\n * Note that we must ALWAYS check specially whether those values are MIN_VALUE\n * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n * a positive number, it overflows back into a negative).  Not handling this\n * case would often result in infinite recursion.\n *\n * @param {number} low  The low (signed) 32 bits of the long.\n * @param {number} high  The high (signed) 32 bits of the long.\n * @constructor\n * @final\n */\nKotlin.Long = function(low, high) {\n  /**\n   * @type {number}\n   * @private\n   */\n  this.low_ = low | 0;  // force into 32 signed bits.\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.high_ = high | 0;  // force into 32 signed bits.\n};\n\nKotlin.Long.$metadata$ = {\n    kind: \"class\",\n    simpleName: \"Long\",\n    interfaces:[]\n};\n\n\n// NOTE: Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the\n// from* methods on which they depend.\n\n\n/**\n * A cache of the Long representations of small integer values.\n * @type {!Object}\n * @private\n */\nKotlin.Long.IntCache_ = {};\n\n\n/**\n * Returns a Long representing the given (32-bit) integer value.\n * @param {number} value The 32-bit integer in question.\n * @return {!Kotlin.Long} The corresponding Long value.\n */\nKotlin.Long.fromInt = function(value) {\n  if (-128 <= value && value < 128) {\n    var cachedObj = Kotlin.Long.IntCache_[value];\n    if (cachedObj) {\n      return cachedObj;\n    }\n  }\n\n  var obj = new Kotlin.Long(value | 0, value < 0 ? -1 : 0);\n  if (-128 <= value && value < 128) {\n    Kotlin.Long.IntCache_[value] = obj;\n  }\n  return obj;\n};\n\n\n/**\n * Converts this number value to `Long`.\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Double` value is `NaN`, `Long.MIN_VALUE` if it's less than `Long.MIN_VALUE`,\n * `Long.MAX_VALUE` if it's bigger than `Long.MAX_VALUE`.\n * @param {number} value The number in question.\n * @return {!Kotlin.Long} The corresponding Long value.\n */\nKotlin.Long.fromNumber = function(value) {\n  if (isNaN(value)) {\n    return Kotlin.Long.ZERO;\n  } else if (value <= -Kotlin.Long.TWO_PWR_63_DBL_) {\n    return Kotlin.Long.MIN_VALUE;\n  } else if (value + 1 >= Kotlin.Long.TWO_PWR_63_DBL_) {\n    return Kotlin.Long.MAX_VALUE;\n  } else if (value < 0) {\n    return Kotlin.Long.fromNumber(-value).negate();\n  } else {\n    return new Kotlin.Long(\n        (value % Kotlin.Long.TWO_PWR_32_DBL_) | 0,\n        (value / Kotlin.Long.TWO_PWR_32_DBL_) | 0);\n  }\n};\n\n\n/**\n * Returns a Long representing the 64-bit integer that comes by concatenating\n * the given high and low bits.  Each is assumed to use 32 bits.\n * @param {number} lowBits The low 32-bits.\n * @param {number} highBits The high 32-bits.\n * @return {!Kotlin.Long} The corresponding Long value.\n */\nKotlin.Long.fromBits = function(lowBits, highBits) {\n  return new Kotlin.Long(lowBits, highBits);\n};\n\n\n/**\n * Returns a Long representation of the given string, written using the given\n * radix.\n * @param {string} str The textual representation of the Long.\n * @param {number=} opt_radix The radix in which the text is written.\n * @return {!Kotlin.Long} The corresponding Long value.\n */\nKotlin.Long.fromString = function(str, opt_radix) {\n  if (str.length == 0) {\n    throw Error('number format error: empty string');\n  }\n\n  var radix = opt_radix || 10;\n  if (radix < 2 || 36 < radix) {\n    throw Error('radix out of range: ' + radix);\n  }\n\n  if (str.charAt(0) == '-') {\n    return Kotlin.Long.fromString(str.substring(1), radix).negate();\n  } else if (str.indexOf('-') >= 0) {\n    throw Error('number format error: interior \"-\" character: ' + str);\n  }\n\n  // Do several (8) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  var radixToPower = Kotlin.Long.fromNumber(Math.pow(radix, 8));\n\n  var result = Kotlin.Long.ZERO;\n  for (var i = 0; i < str.length; i += 8) {\n    var size = Math.min(8, str.length - i);\n    var value = parseInt(str.substring(i, i + size), radix);\n    if (size < 8) {\n      var power = Kotlin.Long.fromNumber(Math.pow(radix, size));\n      result = result.multiply(power).add(Kotlin.Long.fromNumber(value));\n    } else {\n      result = result.multiply(radixToPower);\n      result = result.add(Kotlin.Long.fromNumber(value));\n    }\n  }\n  return result;\n};\n\n\n// NOTE: the compiler should inline these constant values below and then remove\n// these variables, so there should be no runtime penalty for these.\n\n\n/**\n * Number used repeated below in calculations.  This must appear before the\n * first call to any from* function below.\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_16_DBL_ = 1 << 16;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_24_DBL_ = 1 << 24;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_32_DBL_ =\n    Kotlin.Long.TWO_PWR_16_DBL_ * Kotlin.Long.TWO_PWR_16_DBL_;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_31_DBL_ =\n    Kotlin.Long.TWO_PWR_32_DBL_ / 2;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_48_DBL_ =\n    Kotlin.Long.TWO_PWR_32_DBL_ * Kotlin.Long.TWO_PWR_16_DBL_;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_64_DBL_ =\n    Kotlin.Long.TWO_PWR_32_DBL_ * Kotlin.Long.TWO_PWR_32_DBL_;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_63_DBL_ =\n    Kotlin.Long.TWO_PWR_64_DBL_ / 2;\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.ZERO = Kotlin.Long.fromInt(0);\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.ONE = Kotlin.Long.fromInt(1);\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.NEG_ONE = Kotlin.Long.fromInt(-1);\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.MAX_VALUE =\n    Kotlin.Long.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0);\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.MIN_VALUE = Kotlin.Long.fromBits(0, 0x80000000 | 0);\n\n\n/**\n * @type {!Kotlin.Long}\n * @private\n */\nKotlin.Long.TWO_PWR_24_ = Kotlin.Long.fromInt(1 << 24);\n\n\n/** @return {number} The value, assuming it is a 32-bit integer. */\nKotlin.Long.prototype.toInt = function() {\n  return this.low_;\n};\n\n\n/** @return {number} The closest floating-point representation to this value. */\nKotlin.Long.prototype.toNumber = function() {\n  return this.high_ * Kotlin.Long.TWO_PWR_32_DBL_ +\n         this.getLowBitsUnsigned();\n};\n\n/** @return {number} The 32-bit hashCode of this value. */\nKotlin.Long.prototype.hashCode = function() {\n  return this.high_ ^ this.low_;\n};\n\n/**\n * @param {number=} opt_radix The radix in which the text should be written.\n * @return {string} The textual representation of this value.\n * @override\n */\nKotlin.Long.prototype.toString = function(opt_radix) {\n  var radix = opt_radix || 10;\n  if (radix < 2 || 36 < radix) {\n    throw Error('radix out of range: ' + radix);\n  }\n\n  if (this.isZero()) {\n    return '0';\n  }\n\n  if (this.isNegative()) {\n    if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n      // We need to change the Long value before it can be negated, so we remove\n      // the bottom-most digit in this base and then recurse to do the rest.\n      var radixLong = Kotlin.Long.fromNumber(radix);\n      var div = this.div(radixLong);\n      var rem = div.multiply(radixLong).subtract(this);\n      return div.toString(radix) + rem.toInt().toString(radix);\n    } else {\n      return '-' + this.negate().toString(radix);\n    }\n  }\n\n  // Do several (5) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  var radixToPower = Kotlin.Long.fromNumber(Math.pow(radix, 5));\n\n  var rem = this;\n  var result = '';\n  while (true) {\n    var remDiv = rem.div(radixToPower);\n    var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();\n    var digits = intval.toString(radix);\n\n    rem = remDiv;\n    if (rem.isZero()) {\n      return digits + result;\n    } else {\n      while (digits.length < 5) {\n        digits = '0' + digits;\n      }\n      result = '' + digits + result;\n    }\n  }\n};\n\n\n/** @return {number} The high 32-bits as a signed value. */\nKotlin.Long.prototype.getHighBits = function() {\n  return this.high_;\n};\n\n\n/** @return {number} The low 32-bits as a signed value. */\nKotlin.Long.prototype.getLowBits = function() {\n  return this.low_;\n};\n\n\n/** @return {number} The low 32-bits as an unsigned value. */\nKotlin.Long.prototype.getLowBitsUnsigned = function() {\n  return (this.low_ >= 0) ?\n      this.low_ : Kotlin.Long.TWO_PWR_32_DBL_ + this.low_;\n};\n\n\n/**\n * @return {number} Returns the number of bits needed to represent the absolute\n *     value of this Long.\n */\nKotlin.Long.prototype.getNumBitsAbs = function() {\n  if (this.isNegative()) {\n    if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n      return 64;\n    } else {\n      return this.negate().getNumBitsAbs();\n    }\n  } else {\n    var val = this.high_ != 0 ? this.high_ : this.low_;\n    for (var bit = 31; bit > 0; bit--) {\n      if ((val & (1 << bit)) != 0) {\n        break;\n      }\n    }\n    return this.high_ != 0 ? bit + 33 : bit + 1;\n  }\n};\n\n\n/** @return {boolean} Whether this value is zero. */\nKotlin.Long.prototype.isZero = function() {\n  return this.high_ == 0 && this.low_ == 0;\n};\n\n\n/** @return {boolean} Whether this value is negative. */\nKotlin.Long.prototype.isNegative = function() {\n  return this.high_ < 0;\n};\n\n\n/** @return {boolean} Whether this value is odd. */\nKotlin.Long.prototype.isOdd = function() {\n  return (this.low_ & 1) == 1;\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long equals the other.\n */\nKotlin.Long.prototype.equalsLong = function(other) {\n  return (this.high_ == other.high_) && (this.low_ == other.low_);\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long does not equal the other.\n */\nKotlin.Long.prototype.notEqualsLong = function(other) {\n  return (this.high_ != other.high_) || (this.low_ != other.low_);\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long is less than the other.\n */\nKotlin.Long.prototype.lessThan = function(other) {\n  return this.compare(other) < 0;\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long is less than or equal to the other.\n */\nKotlin.Long.prototype.lessThanOrEqual = function(other) {\n  return this.compare(other) <= 0;\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long is greater than the other.\n */\nKotlin.Long.prototype.greaterThan = function(other) {\n  return this.compare(other) > 0;\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long is greater than or equal to the other.\n */\nKotlin.Long.prototype.greaterThanOrEqual = function(other) {\n  return this.compare(other) >= 0;\n};\n\n\n/**\n * Compares this Long with the given one.\n * @param {Kotlin.Long} other Long to compare against.\n * @return {number} 0 if they are the same, 1 if the this is greater, and -1\n *     if the given one is greater.\n */\nKotlin.Long.prototype.compare = function(other) {\n  if (this.equalsLong(other)) {\n    return 0;\n  }\n\n  var thisNeg = this.isNegative();\n  var otherNeg = other.isNegative();\n  if (thisNeg && !otherNeg) {\n    return -1;\n  }\n  if (!thisNeg && otherNeg) {\n    return 1;\n  }\n\n  // at this point, the signs are the same, so subtraction will not overflow\n  if (this.subtract(other).isNegative()) {\n    return -1;\n  } else {\n    return 1;\n  }\n};\n\n\n/** @return {!Kotlin.Long} The negation of this value. */\nKotlin.Long.prototype.negate = function() {\n  if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    return Kotlin.Long.MIN_VALUE;\n  } else {\n    return this.not().add(Kotlin.Long.ONE);\n  }\n};\n\n\n/**\n * Returns the sum of this and the given Long.\n * @param {Kotlin.Long} other Long to add to this one.\n * @return {!Kotlin.Long} The sum of this and the given Long.\n */\nKotlin.Long.prototype.add = function(other) {\n  // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n\n  var a48 = this.high_ >>> 16;\n  var a32 = this.high_ & 0xFFFF;\n  var a16 = this.low_ >>> 16;\n  var a00 = this.low_ & 0xFFFF;\n\n  var b48 = other.high_ >>> 16;\n  var b32 = other.high_ & 0xFFFF;\n  var b16 = other.low_ >>> 16;\n  var b00 = other.low_ & 0xFFFF;\n\n  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n  c00 += a00 + b00;\n  c16 += c00 >>> 16;\n  c00 &= 0xFFFF;\n  c16 += a16 + b16;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c32 += a32 + b32;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c48 += a48 + b48;\n  c48 &= 0xFFFF;\n  return Kotlin.Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);\n};\n\n\n/**\n * Returns the difference of this and the given Long.\n * @param {Kotlin.Long} other Long to subtract from this.\n * @return {!Kotlin.Long} The difference of this and the given Long.\n */\nKotlin.Long.prototype.subtract = function(other) {\n  return this.add(other.negate());\n};\n\n\n/**\n * Returns the product of this and the given long.\n * @param {Kotlin.Long} other Long to multiply with this.\n * @return {!Kotlin.Long} The product of this and the other.\n */\nKotlin.Long.prototype.multiply = function(other) {\n  if (this.isZero()) {\n    return Kotlin.Long.ZERO;\n  } else if (other.isZero()) {\n    return Kotlin.Long.ZERO;\n  }\n\n  if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    return other.isOdd() ? Kotlin.Long.MIN_VALUE : Kotlin.Long.ZERO;\n  } else if (other.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    return this.isOdd() ? Kotlin.Long.MIN_VALUE : Kotlin.Long.ZERO;\n  }\n\n  if (this.isNegative()) {\n    if (other.isNegative()) {\n      return this.negate().multiply(other.negate());\n    } else {\n      return this.negate().multiply(other).negate();\n    }\n  } else if (other.isNegative()) {\n    return this.multiply(other.negate()).negate();\n  }\n\n  // If both longs are small, use float multiplication\n  if (this.lessThan(Kotlin.Long.TWO_PWR_24_) &&\n      other.lessThan(Kotlin.Long.TWO_PWR_24_)) {\n    return Kotlin.Long.fromNumber(this.toNumber() * other.toNumber());\n  }\n\n  // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n  // We can skip products that would overflow.\n\n  var a48 = this.high_ >>> 16;\n  var a32 = this.high_ & 0xFFFF;\n  var a16 = this.low_ >>> 16;\n  var a00 = this.low_ & 0xFFFF;\n\n  var b48 = other.high_ >>> 16;\n  var b32 = other.high_ & 0xFFFF;\n  var b16 = other.low_ >>> 16;\n  var b00 = other.low_ & 0xFFFF;\n\n  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n  c00 += a00 * b00;\n  c16 += c00 >>> 16;\n  c00 &= 0xFFFF;\n  c16 += a16 * b00;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c16 += a00 * b16;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c32 += a32 * b00;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c32 += a16 * b16;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c32 += a00 * b32;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n  c48 &= 0xFFFF;\n  return Kotlin.Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);\n};\n\n\n/**\n * Returns this Long divided by the given one.\n * @param {Kotlin.Long} other Long by which to divide.\n * @return {!Kotlin.Long} This Long divided by the given one.\n */\nKotlin.Long.prototype.div = function(other) {\n  if (other.isZero()) {\n    throw Error('division by zero');\n  } else if (this.isZero()) {\n    return Kotlin.Long.ZERO;\n  }\n\n  if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    if (other.equalsLong(Kotlin.Long.ONE) ||\n        other.equalsLong(Kotlin.Long.NEG_ONE)) {\n      return Kotlin.Long.MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE\n    } else if (other.equalsLong(Kotlin.Long.MIN_VALUE)) {\n      return Kotlin.Long.ONE;\n    } else {\n      // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n      var halfThis = this.shiftRight(1);\n      var approx = halfThis.div(other).shiftLeft(1);\n      if (approx.equalsLong(Kotlin.Long.ZERO)) {\n        return other.isNegative() ? Kotlin.Long.ONE : Kotlin.Long.NEG_ONE;\n      } else {\n        var rem = this.subtract(other.multiply(approx));\n        var result = approx.add(rem.div(other));\n        return result;\n      }\n    }\n  } else if (other.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    return Kotlin.Long.ZERO;\n  }\n\n  if (this.isNegative()) {\n    if (other.isNegative()) {\n      return this.negate().div(other.negate());\n    } else {\n      return this.negate().div(other).negate();\n    }\n  } else if (other.isNegative()) {\n    return this.div(other.negate()).negate();\n  }\n\n  // Repeat the following until the remainder is less than other:  find a\n  // floating-point that approximates remainder / other *from below*, add this\n  // into the result, and subtract it from the remainder.  It is critical that\n  // the approximate value is less than or equal to the real value so that the\n  // remainder never becomes negative.\n  var res = Kotlin.Long.ZERO;\n  var rem = this;\n  while (rem.greaterThanOrEqual(other)) {\n    // Approximate the result of division. This may be a little greater or\n    // smaller than the actual value.\n    var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));\n\n    // We will tweak the approximate result by changing it in the 48-th digit or\n    // the smallest non-fractional digit, whichever is larger.\n    var log2 = Math.ceil(Math.log(approx) / Math.LN2);\n    var delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48);\n\n    // Decrease the approximation until it is smaller than the remainder.  Note\n    // that if it is too large, the product overflows and is negative.\n    var approxRes = Kotlin.Long.fromNumber(approx);\n    var approxRem = approxRes.multiply(other);\n    while (approxRem.isNegative() || approxRem.greaterThan(rem)) {\n      approx -= delta;\n      approxRes = Kotlin.Long.fromNumber(approx);\n      approxRem = approxRes.multiply(other);\n    }\n\n    // We know the answer can't be zero... and actually, zero would cause\n    // infinite recursion since we would make no progress.\n    if (approxRes.isZero()) {\n      approxRes = Kotlin.Long.ONE;\n    }\n\n    res = res.add(approxRes);\n    rem = rem.subtract(approxRem);\n  }\n  return res;\n};\n\n\n/**\n * Returns this Long modulo the given one.\n * @param {Kotlin.Long} other Long by which to mod.\n * @return {!Kotlin.Long} This Long modulo the given one.\n */\nKotlin.Long.prototype.modulo = function(other) {\n  return this.subtract(this.div(other).multiply(other));\n};\n\n\n/** @return {!Kotlin.Long} The bitwise-NOT of this value. */\nKotlin.Long.prototype.not = function() {\n  return Kotlin.Long.fromBits(~this.low_, ~this.high_);\n};\n\n\n/**\n * Returns the bitwise-AND of this Long and the given one.\n * @param {Kotlin.Long} other The Long with which to AND.\n * @return {!Kotlin.Long} The bitwise-AND of this and the other.\n */\nKotlin.Long.prototype.and = function(other) {\n  return Kotlin.Long.fromBits(this.low_ & other.low_,\n                                 this.high_ & other.high_);\n};\n\n\n/**\n * Returns the bitwise-OR of this Long and the given one.\n * @param {Kotlin.Long} other The Long with which to OR.\n * @return {!Kotlin.Long} The bitwise-OR of this and the other.\n */\nKotlin.Long.prototype.or = function(other) {\n  return Kotlin.Long.fromBits(this.low_ | other.low_,\n                                 this.high_ | other.high_);\n};\n\n\n/**\n * Returns the bitwise-XOR of this Long and the given one.\n * @param {Kotlin.Long} other The Long with which to XOR.\n * @return {!Kotlin.Long} The bitwise-XOR of this and the other.\n */\nKotlin.Long.prototype.xor = function(other) {\n  return Kotlin.Long.fromBits(this.low_ ^ other.low_,\n                                 this.high_ ^ other.high_);\n};\n\n\n/**\n * Returns this Long with bits shifted to the left by the given amount.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!Kotlin.Long} This shifted to the left by the given amount.\n */\nKotlin.Long.prototype.shiftLeft = function(numBits) {\n  numBits &= 63;\n  if (numBits == 0) {\n    return this;\n  } else {\n    var low = this.low_;\n    if (numBits < 32) {\n      var high = this.high_;\n      return Kotlin.Long.fromBits(\n          low << numBits,\n          (high << numBits) | (low >>> (32 - numBits)));\n    } else {\n      return Kotlin.Long.fromBits(0, low << (numBits - 32));\n    }\n  }\n};\n\n\n/**\n * Returns this Long with bits shifted to the right by the given amount.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!Kotlin.Long} This shifted to the right by the given amount.\n */\nKotlin.Long.prototype.shiftRight = function(numBits) {\n  numBits &= 63;\n  if (numBits == 0) {\n    return this;\n  } else {\n    var high = this.high_;\n    if (numBits < 32) {\n      var low = this.low_;\n      return Kotlin.Long.fromBits(\n          (low >>> numBits) | (high << (32 - numBits)),\n          high >> numBits);\n    } else {\n      return Kotlin.Long.fromBits(\n          high >> (numBits - 32),\n          high >= 0 ? 0 : -1);\n    }\n  }\n};\n\n\n/**\n * Returns this Long with bits shifted to the right by the given amount, with\n * zeros placed into the new leading bits.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!Kotlin.Long} This shifted to the right by the given amount, with\n *     zeros placed into the new leading bits.\n */\nKotlin.Long.prototype.shiftRightUnsigned = function(numBits) {\n  numBits &= 63;\n  if (numBits == 0) {\n    return this;\n  } else {\n    var high = this.high_;\n    if (numBits < 32) {\n      var low = this.low_;\n      return Kotlin.Long.fromBits(\n          (low >>> numBits) | (high << (32 - numBits)),\n          high >>> numBits);\n    } else if (numBits == 32) {\n      return Kotlin.Long.fromBits(high, 0);\n    } else {\n      return Kotlin.Long.fromBits(high >>> (numBits - 32), 0);\n    }\n  }\n};\n\n// Support for Kotlin\nKotlin.Long.prototype.equals = function (other) {\n    return other instanceof Kotlin.Long && this.equalsLong(other);\n};\n\nKotlin.Long.prototype.compareTo_11rb$ = Kotlin.Long.prototype.compare;\n\nKotlin.Long.prototype.inc = function() {\n    return this.add(Kotlin.Long.ONE);\n};\n\nKotlin.Long.prototype.dec = function() {\n    return this.add(Kotlin.Long.NEG_ONE);\n};\n\nKotlin.Long.prototype.valueOf = function() {\n    return this.toNumber();\n};\n\nKotlin.Long.prototype.unaryPlus = function() {\n    return this;\n};\n\nKotlin.Long.prototype.unaryMinus = Kotlin.Long.prototype.negate;\nKotlin.Long.prototype.inv = Kotlin.Long.prototype.not;\n\nKotlin.Long.prototype.rangeTo = function (other) {\n    return new Kotlin.kotlin.ranges.LongRange(this, other);\n};","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\npublic class Enum<T : Enum<T>> : Comparable<Enum<T>> {\n    @JsName(\"name$\") private var _name: String = \"\"\n    @JsName(\"ordinal$\") private var _ordinal: Int = 0\n\n    val name: String\n        get() = _name\n\n    val ordinal: Int\n        get() = _ordinal\n\n    override fun compareTo(other: Enum<T>) = ordinal.compareTo(other.ordinal)\n\n    override fun equals(other: Any?) = this === other\n\n    override fun hashCode(): Int = js(\"Kotlin.identityHashCode\")(this)\n\n    override fun toString() = name\n\n    companion object\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// a package is omitted to get declarations directly under the module\n\n@PublishedApi\nexternal internal fun <T> Array(size: Int): Array<T>\n\n@JsName(\"newArray\")\nfun <T> newArray(size: Int, initValue: T) = fillArrayVal(Array<T>(size), initValue)\n\n@JsName(\"newArrayF\")\ninline fun <T> arrayWithFun(size: Int, init: (Int) -> T) = fillArrayFun(Array<T>(size), init)\n\n@JsName(\"fillArray\")\ninline fun <T> fillArrayFun(array: Array<T>, init: (Int) -> T): Array<T> {\n    for (i in 0..array.size - 1) {\n        array[i] = init(i)\n    }\n    return array\n}\n\n@JsName(\"booleanArray\")\nfun booleanArray(size: Int, init: dynamic): Array<Boolean> {\n    val result: dynamic = Array<Boolean>(size)\n    result.`$type$` = \"BooleanArray\"\n    return when (init) {\n        null, true -> fillArrayVal(result, false)\n        false -> result\n        else -> fillArrayFun<Boolean>(result, init)\n    }\n}\n\n@JsName(\"booleanArrayF\")\ninline fun booleanArrayWithFun(size: Int, init: (Int) -> Boolean): Array<Boolean> = fillArrayFun(booleanArray(size, false), init)\n\n@JsName(\"charArray\")\n@Suppress(\"UNUSED_PARAMETER\")\nfun charArray(size: Int, init: dynamic): Array<Char> {\n    val result = js(\"new Uint16Array(size)\")\n    result.`$type$` = \"CharArray\"\n    return when (init) {\n        null, true, false -> result // For consistency\n        else -> fillArrayFun<Char>(result, init)\n    }\n}\n\n@JsName(\"charArrayF\")\ninline fun charArrayWithFun(size: Int, init: (Int) -> Char): Array<Char> {\n    val array = charArray(size, null)\n    for (i in 0..array.size - 1) {\n        @Suppress(\"UNUSED_VARIABLE\") // used in js block\n        val value = init(i)\n        js(\"array[i] = value;\")\n    }\n    return array\n}\n\n@JsName(\"untypedCharArrayF\")\ninline fun untypedCharArrayWithFun(size: Int, init: (Int) -> Char): Array<Char> {\n    val array = Array<Char>(size)\n    for (i in 0..array.size - 1) {\n        @Suppress(\"UNUSED_VARIABLE\") // used in js block\n        val value = init(i)\n        js(\"array[i] = value;\")\n    }\n    return array\n}\n\n@JsName(\"longArray\")\nfun longArray(size: Int, init: dynamic): Array<Long> {\n    val result: dynamic = Array<Long>(size)\n    result.`$type$` = \"LongArray\"\n    return when (init) {\n        null, true -> fillArrayVal(result, 0L)\n        false -> result\n        else -> fillArrayFun<Long>(result, init)\n    }\n}\n\n@JsName(\"longArrayF\")\ninline fun longArrayWithFun(size: Int, init: (Int) -> Long): Array<Long> = fillArrayFun(longArray(size, false), init)\n\nprivate fun <T> fillArrayVal(array: Array<T>, initValue: T): Array<T> {\n    for (i in 0..array.size - 1) {\n        array[i] = initValue\n    }\n    return array\n}","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"ArraysKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component1(): Byte {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component1(): Short {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component1(): Int {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component1(): Long {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component1(): Float {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component1(): Double {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component1(): Boolean {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component1(): Char {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component2(): Byte {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component2(): Short {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component2(): Int {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component2(): Long {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component2(): Float {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component2(): Double {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component2(): Boolean {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component2(): Char {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component3(): Byte {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component3(): Short {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component3(): Int {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component3(): Long {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component3(): Float {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component3(): Double {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component3(): Boolean {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component3(): Char {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component4(): Byte {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component4(): Short {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component4(): Int {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component4(): Long {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component4(): Float {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component4(): Double {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component4(): Boolean {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component4(): Char {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component5(): Byte {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component5(): Short {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component5(): Int {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component5(): Long {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component5(): Float {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component5(): Double {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component5(): Boolean {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component5(): Char {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.contains(element: T): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun ByteArray.contains(element: Byte): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun ShortArray.contains(element: Short): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun IntArray.contains(element: Int): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun LongArray.contains(element: Long): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'any { it == element }' instead to continue using this behavior, or '.asList().contains(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"any { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.6\", hiddenSince = \"1.7\")\npublic operator fun FloatArray.contains(element: Float): Boolean {\n    return any { it == element }\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'any { it == element }' instead to continue using this behavior, or '.asList().contains(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"any { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.6\", hiddenSince = \"1.7\")\npublic operator fun DoubleArray.contains(element: Double): Boolean {\n    return any { it == element }\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun BooleanArray.contains(element: Boolean): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun CharArray.contains(element: Char): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun <T> Array<out T>.elementAt(index: Int): T\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun ByteArray.elementAt(index: Int): Byte\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun ShortArray.elementAt(index: Int): Short\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun IntArray.elementAt(index: Int): Int\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun LongArray.elementAt(index: Int): Long\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun FloatArray.elementAt(index: Int): Float\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun DoubleArray.elementAt(index: Int): Double\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun BooleanArray.elementAt(index: Int): Boolean\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun CharArray.elementAt(index: Int): Char\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Byte): Byte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Short): Short {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Int): Int {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Long): Long {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Float): Float {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Double): Double {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Boolean): Boolean {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.elementAtOrNull(index: Int): Byte? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.elementAtOrNull(index: Int): Short? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.elementAtOrNull(index: Int): Int? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.elementAtOrNull(index: Int): Long? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.elementAtOrNull(index: Int): Float? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.elementAtOrNull(index: Int): Double? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.elementAtOrNull(index: Int): Boolean? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.elementAtOrNull(index: Int): Char? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.find(predicate: (Byte) -> Boolean): Byte? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.find(predicate: (Short) -> Boolean): Short? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.find(predicate: (Int) -> Boolean): Int? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.find(predicate: (Long) -> Boolean): Long? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.find(predicate: (Float) -> Boolean): Float? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.find(predicate: (Double) -> Boolean): Double? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.find(predicate: (Boolean) -> Boolean): Boolean? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.find(predicate: (Char) -> Boolean): Char? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.findLast(predicate: (Byte) -> Boolean): Byte? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.findLast(predicate: (Short) -> Boolean): Short? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.findLast(predicate: (Int) -> Boolean): Int? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.findLast(predicate: (Long) -> Boolean): Long? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.findLast(predicate: (Float) -> Boolean): Float? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.findLast(predicate: (Double) -> Boolean): Double? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.findLast(predicate: (Boolean) -> Boolean): Boolean? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.findLast(predicate: (Char) -> Boolean): Char? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\npublic fun <T> Array<out T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\npublic fun ByteArray.first(): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\npublic fun ShortArray.first(): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\npublic fun IntArray.first(): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\npublic fun LongArray.first(): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\npublic fun FloatArray.first(): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\npublic fun DoubleArray.first(): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\npublic fun BooleanArray.first(): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\npublic fun CharArray.first(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Array<out T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun ByteArray.first(predicate: (Byte) -> Boolean): Byte {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun ShortArray.first(predicate: (Short) -> Boolean): Short {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun IntArray.first(predicate: (Int) -> Boolean): Int {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun LongArray.first(predicate: (Long) -> Boolean): Long {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun FloatArray.first(predicate: (Float) -> Boolean): Float {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun DoubleArray.first(predicate: (Double) -> Boolean): Double {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun BooleanArray.first(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun CharArray.first(predicate: (Char) -> Boolean): Char {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this array in iteration order,\n * or throws [NoSuchElementException] if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Array<out T>.firstNotNullOf(transform: (T) -> R?): R {\n    return firstNotNullOfOrNull(transform) ?: throw NoSuchElementException(\"No element of the array was transformed to a non-null value.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this array in iteration order,\n * or `null` if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Array<out T>.firstNotNullOfOrNull(transform: (T) -> R?): R? {\n    for (element in this) {\n        val result = transform(element)\n        if (result != null) {\n            return result\n        }\n    }\n    return null\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun <T> Array<out T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun ByteArray.firstOrNull(): Byte? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun ShortArray.firstOrNull(): Short? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun IntArray.firstOrNull(): Int? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun LongArray.firstOrNull(): Long? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun FloatArray.firstOrNull(): Float? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun DoubleArray.firstOrNull(): Double? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun BooleanArray.firstOrNull(): Boolean? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun CharArray.firstOrNull(): Char? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Array<out T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun ByteArray.firstOrNull(predicate: (Byte) -> Boolean): Byte? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun ShortArray.firstOrNull(predicate: (Short) -> Boolean): Short? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun IntArray.firstOrNull(predicate: (Int) -> Boolean): Int? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun LongArray.firstOrNull(predicate: (Long) -> Boolean): Long? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun FloatArray.firstOrNull(predicate: (Float) -> Boolean): Float? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun DoubleArray.firstOrNull(predicate: (Double) -> Boolean): Double? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun BooleanArray.firstOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun CharArray.firstOrNull(predicate: (Char) -> Boolean): Char? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.getOrElse(index: Int, defaultValue: (Int) -> Byte): Byte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.getOrElse(index: Int, defaultValue: (Int) -> Short): Short {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.getOrElse(index: Int, defaultValue: (Int) -> Int): Int {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.getOrElse(index: Int, defaultValue: (Int) -> Long): Long {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.getOrElse(index: Int, defaultValue: (Int) -> Float): Float {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.getOrElse(index: Int, defaultValue: (Int) -> Double): Double {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.getOrElse(index: Int, defaultValue: (Int) -> Boolean): Boolean {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.getOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun <T> Array<out T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun ByteArray.getOrNull(index: Int): Byte? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun ShortArray.getOrNull(index: Int): Short? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun IntArray.getOrNull(index: Int): Int? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun LongArray.getOrNull(index: Int): Long? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun FloatArray.getOrNull(index: Int): Float? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun DoubleArray.getOrNull(index: Int): Double? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun BooleanArray.getOrNull(index: Int): Boolean? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun CharArray.getOrNull(index: Int): Char? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.indexOf(element: T): Int {\n    if (element == null) {\n        for (index in indices) {\n            if (this[index] == null) {\n                return index\n            }\n        }\n    } else {\n        for (index in indices) {\n            if (element == this[index]) {\n                return index\n            }\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun ByteArray.indexOf(element: Byte): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun ShortArray.indexOf(element: Short): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun IntArray.indexOf(element: Int): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun LongArray.indexOf(element: Long): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfFirst { it == element }' instead to continue using this behavior, or '.asList().indexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfFirst { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.6\", hiddenSince = \"1.7\")\npublic fun FloatArray.indexOf(element: Float): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfFirst { it == element }' instead to continue using this behavior, or '.asList().indexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfFirst { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.6\", hiddenSince = \"1.7\")\npublic fun DoubleArray.indexOf(element: Double): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun BooleanArray.indexOf(element: Boolean): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun CharArray.indexOf(element: Char): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun <T> Array<out T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ByteArray.indexOfFirst(predicate: (Byte) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ShortArray.indexOfFirst(predicate: (Short) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun IntArray.indexOfFirst(predicate: (Int) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun LongArray.indexOfFirst(predicate: (Long) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun FloatArray.indexOfFirst(predicate: (Float) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun DoubleArray.indexOfFirst(predicate: (Double) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun BooleanArray.indexOfFirst(predicate: (Boolean) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun CharArray.indexOfFirst(predicate: (Char) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun <T> Array<out T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ByteArray.indexOfLast(predicate: (Byte) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ShortArray.indexOfLast(predicate: (Short) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun IntArray.indexOfLast(predicate: (Int) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun LongArray.indexOfLast(predicate: (Long) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun FloatArray.indexOfLast(predicate: (Float) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun DoubleArray.indexOfLast(predicate: (Double) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun BooleanArray.indexOfLast(predicate: (Boolean) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun CharArray.indexOfLast(predicate: (Char) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Array<out T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun ByteArray.last(): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun ShortArray.last(): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun IntArray.last(): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun LongArray.last(): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun FloatArray.last(): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun DoubleArray.last(): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun BooleanArray.last(): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun CharArray.last(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Array<out T>.last(predicate: (T) -> Boolean): T {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun ByteArray.last(predicate: (Byte) -> Boolean): Byte {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun ShortArray.last(predicate: (Short) -> Boolean): Short {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun IntArray.last(predicate: (Int) -> Boolean): Int {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun LongArray.last(predicate: (Long) -> Boolean): Long {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun FloatArray.last(predicate: (Float) -> Boolean): Float {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun DoubleArray.last(predicate: (Double) -> Boolean): Double {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun BooleanArray.last(predicate: (Boolean) -> Boolean): Boolean {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun CharArray.last(predicate: (Char) -> Boolean): Char {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.lastIndexOf(element: T): Int {\n    if (element == null) {\n        for (index in indices.reversed()) {\n            if (this[index] == null) {\n                return index\n            }\n        }\n    } else {\n        for (index in indices.reversed()) {\n            if (element == this[index]) {\n                return index\n            }\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun ByteArray.lastIndexOf(element: Byte): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun ShortArray.lastIndexOf(element: Short): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun IntArray.lastIndexOf(element: Int): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun LongArray.lastIndexOf(element: Long): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfLast { it == element }' instead to continue using this behavior, or '.asList().lastIndexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfLast { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.6\", hiddenSince = \"1.7\")\npublic fun FloatArray.lastIndexOf(element: Float): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfLast { it == element }' instead to continue using this behavior, or '.asList().lastIndexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfLast { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.6\", hiddenSince = \"1.7\")\npublic fun DoubleArray.lastIndexOf(element: Double): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun BooleanArray.lastIndexOf(element: Boolean): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun CharArray.lastIndexOf(element: Char): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Array<out T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun ByteArray.lastOrNull(): Byte? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun ShortArray.lastOrNull(): Short? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun IntArray.lastOrNull(): Int? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun LongArray.lastOrNull(): Long? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun FloatArray.lastOrNull(): Float? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun DoubleArray.lastOrNull(): Double? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun BooleanArray.lastOrNull(): Boolean? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun CharArray.lastOrNull(): Char? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Array<out T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun ByteArray.lastOrNull(predicate: (Byte) -> Boolean): Byte? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun ShortArray.lastOrNull(predicate: (Short) -> Boolean): Short? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun IntArray.lastOrNull(predicate: (Int) -> Boolean): Int? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun LongArray.lastOrNull(predicate: (Long) -> Boolean): Long? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun FloatArray.lastOrNull(predicate: (Float) -> Boolean): Float? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun DoubleArray.lastOrNull(predicate: (Double) -> Boolean): Double? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun BooleanArray.lastOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun CharArray.lastOrNull(predicate: (Char) -> Boolean): Char? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.random(): Byte {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.random(): Short {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.random(): Int {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.random(): Long {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.random(): Float {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.random(): Double {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.random(): Boolean {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.random(): Char {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Array<out T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun ByteArray.random(random: Random): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun ShortArray.random(random: Random): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun IntArray.random(random: Random): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun LongArray.random(random: Random): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun FloatArray.random(random: Random): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun DoubleArray.random(random: Random): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun BooleanArray.random(random: Random): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun CharArray.random(random: Random): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.randomOrNull(): T? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.randomOrNull(): Byte? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.randomOrNull(): Short? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.randomOrNull(): Int? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.randomOrNull(): Long? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.randomOrNull(): Float? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.randomOrNull(): Double? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.randomOrNull(): Boolean? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.randomOrNull(): Char? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> Array<out T>.randomOrNull(random: Random): T? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun ByteArray.randomOrNull(random: Random): Byte? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun ShortArray.randomOrNull(random: Random): Short? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun IntArray.randomOrNull(random: Random): Int? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun LongArray.randomOrNull(random: Random): Long? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun FloatArray.randomOrNull(random: Random): Float? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun DoubleArray.randomOrNull(random: Random): Double? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun BooleanArray.randomOrNull(random: Random): Boolean? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun CharArray.randomOrNull(random: Random): Char? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun <T> Array<out T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun ByteArray.single(): Byte {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun ShortArray.single(): Short {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun IntArray.single(): Int {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun LongArray.single(): Long {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun FloatArray.single(): Float {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun DoubleArray.single(): Double {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun BooleanArray.single(): Boolean {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun CharArray.single(): Char {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Array<out T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun ByteArray.single(predicate: (Byte) -> Boolean): Byte {\n    var single: Byte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Byte\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun ShortArray.single(predicate: (Short) -> Boolean): Short {\n    var single: Short? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Short\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun IntArray.single(predicate: (Int) -> Boolean): Int {\n    var single: Int? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Int\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun LongArray.single(predicate: (Long) -> Boolean): Long {\n    var single: Long? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Long\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun FloatArray.single(predicate: (Float) -> Boolean): Float {\n    var single: Float? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Float\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun DoubleArray.single(predicate: (Double) -> Boolean): Double {\n    var single: Double? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Double\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun BooleanArray.single(predicate: (Boolean) -> Boolean): Boolean {\n    var single: Boolean? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Boolean\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun CharArray.single(predicate: (Char) -> Boolean): Char {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Char\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun <T> Array<out T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun ByteArray.singleOrNull(): Byte? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun ShortArray.singleOrNull(): Short? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun IntArray.singleOrNull(): Int? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun LongArray.singleOrNull(): Long? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun FloatArray.singleOrNull(): Float? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun DoubleArray.singleOrNull(): Double? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun BooleanArray.singleOrNull(): Boolean? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun CharArray.singleOrNull(): Char? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Array<out T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun ByteArray.singleOrNull(predicate: (Byte) -> Boolean): Byte? {\n    var single: Byte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun ShortArray.singleOrNull(predicate: (Short) -> Boolean): Short? {\n    var single: Short? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun IntArray.singleOrNull(predicate: (Int) -> Boolean): Int? {\n    var single: Int? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun LongArray.singleOrNull(predicate: (Long) -> Boolean): Long? {\n    var single: Long? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun FloatArray.singleOrNull(predicate: (Float) -> Boolean): Float? {\n    var single: Float? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun DoubleArray.singleOrNull(predicate: (Double) -> Boolean): Double? {\n    var single: Double? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun BooleanArray.singleOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    var single: Boolean? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun CharArray.singleOrNull(predicate: (Char) -> Boolean): Char? {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Array<out T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ByteArray.drop(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ShortArray.drop(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun IntArray.drop(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun LongArray.drop(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun FloatArray.drop(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun DoubleArray.drop(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun BooleanArray.drop(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun CharArray.drop(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Array<out T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ByteArray.dropLast(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ShortArray.dropLast(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun IntArray.dropLast(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun LongArray.dropLast(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun FloatArray.dropLast(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun DoubleArray.dropLast(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun BooleanArray.dropLast(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun CharArray.dropLast(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Array<out T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ByteArray.dropLastWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ShortArray.dropLastWhile(predicate: (Short) -> Boolean): List<Short> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun IntArray.dropLastWhile(predicate: (Int) -> Boolean): List<Int> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun LongArray.dropLastWhile(predicate: (Long) -> Boolean): List<Long> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun FloatArray.dropLastWhile(predicate: (Float) -> Boolean): List<Float> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun DoubleArray.dropLastWhile(predicate: (Double) -> Boolean): List<Double> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun BooleanArray.dropLastWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun CharArray.dropLastWhile(predicate: (Char) -> Boolean): List<Char> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Array<out T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ByteArray.dropWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    var yielding = false\n    val list = ArrayList<Byte>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ShortArray.dropWhile(predicate: (Short) -> Boolean): List<Short> {\n    var yielding = false\n    val list = ArrayList<Short>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun IntArray.dropWhile(predicate: (Int) -> Boolean): List<Int> {\n    var yielding = false\n    val list = ArrayList<Int>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun LongArray.dropWhile(predicate: (Long) -> Boolean): List<Long> {\n    var yielding = false\n    val list = ArrayList<Long>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun FloatArray.dropWhile(predicate: (Float) -> Boolean): List<Float> {\n    var yielding = false\n    val list = ArrayList<Float>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun DoubleArray.dropWhile(predicate: (Double) -> Boolean): List<Double> {\n    var yielding = false\n    val list = ArrayList<Double>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun BooleanArray.dropWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    var yielding = false\n    val list = ArrayList<Boolean>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun CharArray.dropWhile(predicate: (Char) -> Boolean): List<Char> {\n    var yielding = false\n    val list = ArrayList<Char>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Array<out T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ByteArray.filter(predicate: (Byte) -> Boolean): List<Byte> {\n    return filterTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ShortArray.filter(predicate: (Short) -> Boolean): List<Short> {\n    return filterTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun IntArray.filter(predicate: (Int) -> Boolean): List<Int> {\n    return filterTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun LongArray.filter(predicate: (Long) -> Boolean): List<Long> {\n    return filterTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun FloatArray.filter(predicate: (Float) -> Boolean): List<Float> {\n    return filterTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun DoubleArray.filter(predicate: (Double) -> Boolean): List<Double> {\n    return filterTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun BooleanArray.filter(predicate: (Boolean) -> Boolean): List<Boolean> {\n    return filterTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun CharArray.filter(predicate: (Char) -> Boolean): List<Char> {\n    return filterTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun <T> Array<out T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun ByteArray.filterIndexed(predicate: (index: Int, Byte) -> Boolean): List<Byte> {\n    return filterIndexedTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun ShortArray.filterIndexed(predicate: (index: Int, Short) -> Boolean): List<Short> {\n    return filterIndexedTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun IntArray.filterIndexed(predicate: (index: Int, Int) -> Boolean): List<Int> {\n    return filterIndexedTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun LongArray.filterIndexed(predicate: (index: Int, Long) -> Boolean): List<Long> {\n    return filterIndexedTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun FloatArray.filterIndexed(predicate: (index: Int, Float) -> Boolean): List<Float> {\n    return filterIndexedTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun DoubleArray.filterIndexed(predicate: (index: Int, Double) -> Boolean): List<Double> {\n    return filterIndexedTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun BooleanArray.filterIndexed(predicate: (index: Int, Boolean) -> Boolean): List<Boolean> {\n    return filterIndexedTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun CharArray.filterIndexed(predicate: (index: Int, Char) -> Boolean): List<Char> {\n    return filterIndexedTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterIndexedTo(destination: C, predicate: (index: Int, Byte) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterIndexedTo(destination: C, predicate: (index: Int, Short) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterIndexedTo(destination: C, predicate: (index: Int, Int) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterIndexedTo(destination: C, predicate: (index: Int, Long) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterIndexedTo(destination: C, predicate: (index: Int, Float) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterIndexedTo(destination: C, predicate: (index: Int, Double) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterIndexedTo(destination: C, predicate: (index: Int, Boolean) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterIndexedTo(destination: C, predicate: (index: Int, Char) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstance\n */\npublic inline fun <reified R> Array<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstanceTo\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Array<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Array<out T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ByteArray.filterNot(predicate: (Byte) -> Boolean): List<Byte> {\n    return filterNotTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ShortArray.filterNot(predicate: (Short) -> Boolean): List<Short> {\n    return filterNotTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun IntArray.filterNot(predicate: (Int) -> Boolean): List<Int> {\n    return filterNotTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun LongArray.filterNot(predicate: (Long) -> Boolean): List<Long> {\n    return filterNotTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun FloatArray.filterNot(predicate: (Float) -> Boolean): List<Float> {\n    return filterNotTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun DoubleArray.filterNot(predicate: (Double) -> Boolean): List<Double> {\n    return filterNotTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun BooleanArray.filterNot(predicate: (Boolean) -> Boolean): List<Boolean> {\n    return filterNotTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun CharArray.filterNot(predicate: (Char) -> Boolean): List<Char> {\n    return filterNotTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Array<out T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterNotNullTo\n */\npublic fun <C : MutableCollection<in T>, T : Any> Array<out T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterNotTo(destination: C, predicate: (Byte) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterNotTo(destination: C, predicate: (Short) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterNotTo(destination: C, predicate: (Int) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterNotTo(destination: C, predicate: (Long) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterNotTo(destination: C, predicate: (Float) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterNotTo(destination: C, predicate: (Double) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterNotTo(destination: C, predicate: (Boolean) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterNotTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterTo(destination: C, predicate: (Byte) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterTo(destination: C, predicate: (Short) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterTo(destination: C, predicate: (Int) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterTo(destination: C, predicate: (Long) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterTo(destination: C, predicate: (Float) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterTo(destination: C, predicate: (Double) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterTo(destination: C, predicate: (Boolean) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> Array<out T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun ByteArray.slice(indices: IntRange): List<Byte> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun ShortArray.slice(indices: IntRange): List<Short> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun IntArray.slice(indices: IntRange): List<Int> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun LongArray.slice(indices: IntRange): List<Long> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun FloatArray.slice(indices: IntRange): List<Float> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun DoubleArray.slice(indices: IntRange): List<Double> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun BooleanArray.slice(indices: IntRange): List<Boolean> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun CharArray.slice(indices: IntRange): List<Char> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> Array<out T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun ByteArray.slice(indices: Iterable<Int>): List<Byte> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Byte>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun ShortArray.slice(indices: Iterable<Int>): List<Short> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Short>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun IntArray.slice(indices: Iterable<Int>): List<Int> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Int>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun LongArray.slice(indices: Iterable<Int>): List<Long> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Long>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun FloatArray.slice(indices: Iterable<Int>): List<Float> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Float>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun DoubleArray.slice(indices: Iterable<Int>): List<Double> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Double>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun BooleanArray.slice(indices: Iterable<Int>): List<Boolean> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Boolean>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun CharArray.slice(indices: Iterable<Int>): List<Char> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Char>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun <T> Array<T>.sliceArray(indices: Collection<Int>): Array<T> {\n    val result = arrayOfNulls(this, indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun ByteArray.sliceArray(indices: Collection<Int>): ByteArray {\n    val result = ByteArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun ShortArray.sliceArray(indices: Collection<Int>): ShortArray {\n    val result = ShortArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun IntArray.sliceArray(indices: Collection<Int>): IntArray {\n    val result = IntArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun LongArray.sliceArray(indices: Collection<Int>): LongArray {\n    val result = LongArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun FloatArray.sliceArray(indices: Collection<Int>): FloatArray {\n    val result = FloatArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun DoubleArray.sliceArray(indices: Collection<Int>): DoubleArray {\n    val result = DoubleArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun BooleanArray.sliceArray(indices: Collection<Int>): BooleanArray {\n    val result = BooleanArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun CharArray.sliceArray(indices: Collection<Int>): CharArray {\n    val result = CharArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun <T> Array<T>.sliceArray(indices: IntRange): Array<T> {\n    if (indices.isEmpty()) return copyOfRange(0, 0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun ByteArray.sliceArray(indices: IntRange): ByteArray {\n    if (indices.isEmpty()) return ByteArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun ShortArray.sliceArray(indices: IntRange): ShortArray {\n    if (indices.isEmpty()) return ShortArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun IntArray.sliceArray(indices: IntRange): IntArray {\n    if (indices.isEmpty()) return IntArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun LongArray.sliceArray(indices: IntRange): LongArray {\n    if (indices.isEmpty()) return LongArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun FloatArray.sliceArray(indices: IntRange): FloatArray {\n    if (indices.isEmpty()) return FloatArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun DoubleArray.sliceArray(indices: IntRange): DoubleArray {\n    if (indices.isEmpty()) return DoubleArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun BooleanArray.sliceArray(indices: IntRange): BooleanArray {\n    if (indices.isEmpty()) return BooleanArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun CharArray.sliceArray(indices: IntRange): CharArray {\n    if (indices.isEmpty()) return CharArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Array<out T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ByteArray.take(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Byte>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ShortArray.take(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Short>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun IntArray.take(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Int>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun LongArray.take(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Long>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun FloatArray.take(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Float>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun DoubleArray.take(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Double>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun BooleanArray.take(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Boolean>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun CharArray.take(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Char>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Array<out T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<T>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ByteArray.takeLast(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Byte>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ShortArray.takeLast(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Short>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun IntArray.takeLast(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Int>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun LongArray.takeLast(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Long>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun FloatArray.takeLast(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Float>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun DoubleArray.takeLast(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Double>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun BooleanArray.takeLast(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Boolean>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun CharArray.takeLast(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Char>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Array<out T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ByteArray.takeLastWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ShortArray.takeLastWhile(predicate: (Short) -> Boolean): List<Short> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun IntArray.takeLastWhile(predicate: (Int) -> Boolean): List<Int> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun LongArray.takeLastWhile(predicate: (Long) -> Boolean): List<Long> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun FloatArray.takeLastWhile(predicate: (Float) -> Boolean): List<Float> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun DoubleArray.takeLastWhile(predicate: (Double) -> Boolean): List<Double> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun BooleanArray.takeLastWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun CharArray.takeLastWhile(predicate: (Char) -> Boolean): List<Char> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Array<out T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ByteArray.takeWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    val list = ArrayList<Byte>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ShortArray.takeWhile(predicate: (Short) -> Boolean): List<Short> {\n    val list = ArrayList<Short>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun IntArray.takeWhile(predicate: (Int) -> Boolean): List<Int> {\n    val list = ArrayList<Int>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun LongArray.takeWhile(predicate: (Long) -> Boolean): List<Long> {\n    val list = ArrayList<Long>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun FloatArray.takeWhile(predicate: (Float) -> Boolean): List<Float> {\n    val list = ArrayList<Float>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun DoubleArray.takeWhile(predicate: (Double) -> Boolean): List<Double> {\n    val list = ArrayList<Double>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun BooleanArray.takeWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    val list = ArrayList<Boolean>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun CharArray.takeWhile(predicate: (Char) -> Boolean): List<Char> {\n    val list = ArrayList<Char>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun <T> Array<T>.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun ByteArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun ShortArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun IntArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun LongArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun FloatArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun DoubleArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun BooleanArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun CharArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<T>.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Array<out T>.reversed(): List<T> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun ByteArray.reversed(): List<Byte> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun ShortArray.reversed(): List<Short> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun IntArray.reversed(): List<Int> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun LongArray.reversed(): List<Long> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun FloatArray.reversed(): List<Float> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun DoubleArray.reversed(): List<Double> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun BooleanArray.reversed(): List<Boolean> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun CharArray.reversed(): List<Char> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun <T> Array<T>.reversedArray(): Array<T> {\n    if (isEmpty()) return this\n    val result = arrayOfNulls(this, size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun ByteArray.reversedArray(): ByteArray {\n    if (isEmpty()) return this\n    val result = ByteArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun ShortArray.reversedArray(): ShortArray {\n    if (isEmpty()) return this\n    val result = ShortArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun IntArray.reversedArray(): IntArray {\n    if (isEmpty()) return this\n    val result = IntArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun LongArray.reversedArray(): LongArray {\n    if (isEmpty()) return this\n    val result = LongArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun FloatArray.reversedArray(): FloatArray {\n    if (isEmpty()) return this\n    val result = FloatArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun DoubleArray.reversedArray(): DoubleArray {\n    if (isEmpty()) return this\n    val result = DoubleArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun BooleanArray.reversedArray(): BooleanArray {\n    if (isEmpty()) return this\n    val result = BooleanArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun CharArray.reversedArray(): CharArray {\n    if (isEmpty()) return this\n    val result = CharArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<T>.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<T>.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Sorts elements in the array in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the array in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun ByteArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun ShortArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun IntArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun LongArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun FloatArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun DoubleArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun CharArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sorted(): List<T> {\n    return sortedArray().asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun ByteArray.sorted(): List<Byte> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun ShortArray.sorted(): List<Short> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun IntArray.sorted(): List<Int> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun LongArray.sorted(): List<Long> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun FloatArray.sorted(): List<Float> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun DoubleArray.sorted(): List<Double> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun CharArray.sorted(): List<Char> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<T>.sortedArray(): Array<T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun ByteArray.sortedArray(): ByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun ShortArray.sortedArray(): ShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun IntArray.sortedArray(): IntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun LongArray.sortedArray(): LongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun FloatArray.sortedArray(): FloatArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun DoubleArray.sortedArray(): DoubleArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun CharArray.sortedArray(): CharArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<T>.sortedArrayDescending(): Array<T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortWith(reverseOrder()) }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun ByteArray.sortedArrayDescending(): ByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun ShortArray.sortedArrayDescending(): ShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun IntArray.sortedArrayDescending(): IntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun LongArray.sortedArrayDescending(): LongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun FloatArray.sortedArrayDescending(): FloatArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun DoubleArray.sortedArrayDescending(): DoubleArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun CharArray.sortedArrayDescending(): CharArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Array<out T>.sortedArrayWith(comparator: Comparator<in T>): Array<out T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortWith(comparator) }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> ByteArray.sortedBy(crossinline selector: (Byte) -> R?): List<Byte> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> ShortArray.sortedBy(crossinline selector: (Short) -> R?): List<Short> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> IntArray.sortedBy(crossinline selector: (Int) -> R?): List<Int> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> LongArray.sortedBy(crossinline selector: (Long) -> R?): List<Long> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> FloatArray.sortedBy(crossinline selector: (Float) -> R?): List<Float> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> DoubleArray.sortedBy(crossinline selector: (Double) -> R?): List<Double> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> BooleanArray.sortedBy(crossinline selector: (Boolean) -> R?): List<Boolean> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> CharArray.sortedBy(crossinline selector: (Char) -> R?): List<Char> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> ByteArray.sortedByDescending(crossinline selector: (Byte) -> R?): List<Byte> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> ShortArray.sortedByDescending(crossinline selector: (Short) -> R?): List<Short> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> IntArray.sortedByDescending(crossinline selector: (Int) -> R?): List<Int> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> LongArray.sortedByDescending(crossinline selector: (Long) -> R?): List<Long> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> FloatArray.sortedByDescending(crossinline selector: (Float) -> R?): List<Float> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> DoubleArray.sortedByDescending(crossinline selector: (Double) -> R?): List<Double> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> BooleanArray.sortedByDescending(crossinline selector: (Boolean) -> R?): List<Boolean> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> CharArray.sortedByDescending(crossinline selector: (Char) -> R?): List<Char> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun ByteArray.sortedDescending(): List<Byte> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun ShortArray.sortedDescending(): List<Short> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun IntArray.sortedDescending(): List<Int> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun LongArray.sortedDescending(): List<Long> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun FloatArray.sortedDescending(): List<Float> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun DoubleArray.sortedDescending(): List<Double> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun CharArray.sortedDescending(): List<Char> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Array<out T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    return sortedArrayWith(comparator).asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun ByteArray.sortedWith(comparator: Comparator<in Byte>): List<Byte> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun ShortArray.sortedWith(comparator: Comparator<in Short>): List<Short> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun IntArray.sortedWith(comparator: Comparator<in Int>): List<Int> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun LongArray.sortedWith(comparator: Comparator<in Long>): List<Long> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun FloatArray.sortedWith(comparator: Comparator<in Float>): List<Float> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun DoubleArray.sortedWith(comparator: Comparator<in Double>): List<Double> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun BooleanArray.sortedWith(comparator: Comparator<in Boolean>): List<Boolean> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun CharArray.sortedWith(comparator: Comparator<in Char>): List<Char> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun <T> Array<out T>.asList(): List<T>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun ByteArray.asList(): List<Byte>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun ShortArray.asList(): List<Short>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun IntArray.asList(): List<Int>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun LongArray.asList(): List<Long>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun FloatArray.asList(): List<Float>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun DoubleArray.asList(): List<Double>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun BooleanArray.asList(): List<Boolean>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun CharArray.asList(): List<Char>\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic expect infix fun <T> Array<out T>.contentDeepEquals(other: Array<out T>): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The specified arrays are also considered deeply equal if both are `null`.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun <T> Array<out T>?.contentDeepEquals(other: Array<out T>?): Boolean\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic expect fun <T> Array<out T>.contentDeepHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentDeepHashCode(): Int\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic expect fun <T> Array<out T>.contentDeepToString(): String\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentDeepToString(): String\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun <T> Array<out T>.contentEquals(other: Array<out T>): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun ByteArray.contentEquals(other: ByteArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun ShortArray.contentEquals(other: ShortArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun IntArray.contentEquals(other: IntArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun LongArray.contentEquals(other: LongArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun FloatArray.contentEquals(other: FloatArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun DoubleArray.contentEquals(other: DoubleArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun BooleanArray.contentEquals(other: BooleanArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun CharArray.contentEquals(other: CharArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun <T> Array<out T>?.contentEquals(other: Array<out T>?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun ByteArray?.contentEquals(other: ByteArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun ShortArray?.contentEquals(other: ShortArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun IntArray?.contentEquals(other: IntArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun LongArray?.contentEquals(other: LongArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun FloatArray?.contentEquals(other: FloatArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun DoubleArray?.contentEquals(other: DoubleArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun BooleanArray?.contentEquals(other: BooleanArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun CharArray?.contentEquals(other: CharArray?): Boolean\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun <T> Array<out T>.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ByteArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ShortArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun IntArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun LongArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun FloatArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun DoubleArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun BooleanArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun CharArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ByteArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ShortArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun IntArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun LongArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun FloatArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun DoubleArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun BooleanArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun CharArray?.contentHashCode(): Int\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun <T> Array<out T>.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ByteArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ShortArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun IntArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun LongArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun FloatArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun DoubleArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun BooleanArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun CharArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ByteArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ShortArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun IntArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun LongArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun FloatArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun DoubleArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun BooleanArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun CharArray?.contentToString(): String\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun <T> Array<out T>.copyInto(destination: Array<T>, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): Array<T>\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ByteArray.copyInto(destination: ByteArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ByteArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ShortArray.copyInto(destination: ShortArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ShortArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun IntArray.copyInto(destination: IntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): IntArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun LongArray.copyInto(destination: LongArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): LongArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun FloatArray.copyInto(destination: FloatArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): FloatArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun DoubleArray.copyInto(destination: DoubleArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): DoubleArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun BooleanArray.copyInto(destination: BooleanArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): BooleanArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun CharArray.copyInto(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): CharArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOf(): Array<T>\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun ByteArray.copyOf(): ByteArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun ShortArray.copyOf(): ShortArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun IntArray.copyOf(): IntArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun LongArray.copyOf(): LongArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun FloatArray.copyOf(): FloatArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun DoubleArray.copyOf(): DoubleArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun BooleanArray.copyOf(): BooleanArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun CharArray.copyOf(): CharArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun ByteArray.copyOf(newSize: Int): ByteArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun ShortArray.copyOf(newSize: Int): ShortArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun IntArray.copyOf(newSize: Int): IntArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun LongArray.copyOf(newSize: Int): LongArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun FloatArray.copyOf(newSize: Int): FloatArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun DoubleArray.copyOf(newSize: Int): DoubleArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `false` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `false` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun BooleanArray.copyOf(newSize: Int): BooleanArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with null char (`\\u0000`) values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with null char (`\\u0000`) values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun CharArray.copyOf(newSize: Int): CharArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `null` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `null` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizingCopyOf\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOf(newSize: Int): Array<T?>\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOfRange(fromIndex: Int, toIndex: Int): Array<T>\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun ByteArray.copyOfRange(fromIndex: Int, toIndex: Int): ByteArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun ShortArray.copyOfRange(fromIndex: Int, toIndex: Int): ShortArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun IntArray.copyOfRange(fromIndex: Int, toIndex: Int): IntArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun LongArray.copyOfRange(fromIndex: Int, toIndex: Int): LongArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun FloatArray.copyOfRange(fromIndex: Int, toIndex: Int): FloatArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun DoubleArray.copyOfRange(fromIndex: Int, toIndex: Int): DoubleArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun BooleanArray.copyOfRange(fromIndex: Int, toIndex: Int): BooleanArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun CharArray.copyOfRange(fromIndex: Int, toIndex: Int): CharArray\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun <T> Array<T>.fill(element: T, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ByteArray.fill(element: Byte, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ShortArray.fill(element: Short, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun IntArray.fill(element: Int, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun LongArray.fill(element: Long, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun FloatArray.fill(element: Float, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun DoubleArray.fill(element: Double, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun BooleanArray.fill(element: Boolean, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun CharArray.fill(element: Char, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val <T> Array<out T>.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val ByteArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val ShortArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val IntArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val LongArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val FloatArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val DoubleArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val BooleanArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val CharArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns the last valid index for the array.\n */\npublic val <T> Array<out T>.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val ByteArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val ShortArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val IntArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val LongArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val FloatArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val DoubleArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val BooleanArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val CharArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(element: T): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun ByteArray.plus(element: Byte): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun ShortArray.plus(element: Short): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun IntArray.plus(element: Int): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun LongArray.plus(element: Long): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun FloatArray.plus(element: Float): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun DoubleArray.plus(element: Double): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun BooleanArray.plus(element: Boolean): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun CharArray.plus(element: Char): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(elements: Collection<T>): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun ByteArray.plus(elements: Collection<Byte>): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun ShortArray.plus(elements: Collection<Short>): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun IntArray.plus(elements: Collection<Int>): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun LongArray.plus(elements: Collection<Long>): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun FloatArray.plus(elements: Collection<Float>): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun DoubleArray.plus(elements: Collection<Double>): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun BooleanArray.plus(elements: Collection<Boolean>): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun CharArray.plus(elements: Collection<Char>): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(elements: Array<out T>): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun ByteArray.plus(elements: ByteArray): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun ShortArray.plus(elements: ShortArray): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun IntArray.plus(elements: IntArray): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun LongArray.plus(elements: LongArray): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun FloatArray.plus(elements: FloatArray): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun DoubleArray.plus(elements: DoubleArray): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun BooleanArray.plus(elements: BooleanArray): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun CharArray.plus(elements: CharArray): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.plusElement(element: T): Array<T>\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun IntArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun LongArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun ByteArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun ShortArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun DoubleArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun FloatArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun CharArray.sort(): Unit\n\n/**\n * Sorts the array in-place according to the natural order of its elements.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Arrays.Sorting.sortArrayOfComparable\n */\npublic expect fun <T : Comparable<T>> Array<out T>.sort(): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArrayOfComparable\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T : Comparable<T>> Array<out T>.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ByteArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ShortArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun IntArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun LongArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun FloatArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun DoubleArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun CharArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Array<out T>.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sortWith(reverseOrder(), fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic expect fun <T> Array<out T>.sortWith(comparator: Comparator<in T>): Unit\n\n/**\n * Sorts a range in the array in-place with the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun <T> Array<out T>.sortWith(comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Returns an array of Boolean containing all of the elements of this generic array.\n */\npublic fun Array<out Boolean>.toBooleanArray(): BooleanArray {\n    return BooleanArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this generic array.\n */\npublic fun Array<out Byte>.toByteArray(): ByteArray {\n    return ByteArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Char containing all of the elements of this generic array.\n */\npublic fun Array<out Char>.toCharArray(): CharArray {\n    return CharArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Double containing all of the elements of this generic array.\n */\npublic fun Array<out Double>.toDoubleArray(): DoubleArray {\n    return DoubleArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Float containing all of the elements of this generic array.\n */\npublic fun Array<out Float>.toFloatArray(): FloatArray {\n    return FloatArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Int containing all of the elements of this generic array.\n */\npublic fun Array<out Int>.toIntArray(): IntArray {\n    return IntArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Long containing all of the elements of this generic array.\n */\npublic fun Array<out Long>.toLongArray(): LongArray {\n    return LongArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Short containing all of the elements of this generic array.\n */\npublic fun Array<out Short>.toShortArray(): ShortArray {\n    return ShortArray(size) { index -> this[index] }\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun ByteArray.toTypedArray(): Array<Byte>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun ShortArray.toTypedArray(): Array<Short>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun IntArray.toTypedArray(): Array<Int>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun LongArray.toTypedArray(): Array<Long>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun FloatArray.toTypedArray(): Array<Float>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun DoubleArray.toTypedArray(): Array<Double>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun BooleanArray.toTypedArray(): Array<Boolean>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun CharArray.toTypedArray(): Array<Char>\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <T, K, V> Array<out T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> ByteArray.associate(transform: (Byte) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> ShortArray.associate(transform: (Short) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> IntArray.associate(transform: (Int) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> LongArray.associate(transform: (Long) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> FloatArray.associate(transform: (Float) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> DoubleArray.associate(transform: (Double) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> BooleanArray.associate(transform: (Boolean) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> CharArray.associate(transform: (Char) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <T, K> Array<out T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> ByteArray.associateBy(keySelector: (Byte) -> K): Map<K, Byte> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Byte>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> ShortArray.associateBy(keySelector: (Short) -> K): Map<K, Short> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Short>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> IntArray.associateBy(keySelector: (Int) -> K): Map<K, Int> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Int>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> LongArray.associateBy(keySelector: (Long) -> K): Map<K, Long> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Long>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> FloatArray.associateBy(keySelector: (Float) -> K): Map<K, Float> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Float>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> DoubleArray.associateBy(keySelector: (Double) -> K): Map<K, Double> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Double>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> BooleanArray.associateBy(keySelector: (Boolean) -> K): Map<K, Boolean> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Boolean>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> CharArray.associateBy(keySelector: (Char) -> K): Map<K, Char> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Char>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <T, K, V> Array<out T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> ByteArray.associateBy(keySelector: (Byte) -> K, valueTransform: (Byte) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> ShortArray.associateBy(keySelector: (Short) -> K, valueTransform: (Short) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> IntArray.associateBy(keySelector: (Int) -> K, valueTransform: (Int) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> LongArray.associateBy(keySelector: (Long) -> K, valueTransform: (Long) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> FloatArray.associateBy(keySelector: (Float) -> K, valueTransform: (Float) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> DoubleArray.associateBy(keySelector: (Double) -> K, valueTransform: (Double) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> BooleanArray.associateBy(keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> CharArray.associateBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Array<out T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Byte>> ByteArray.associateByTo(destination: M, keySelector: (Byte) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Short>> ShortArray.associateByTo(destination: M, keySelector: (Short) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Int>> IntArray.associateByTo(destination: M, keySelector: (Int) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Long>> LongArray.associateByTo(destination: M, keySelector: (Long) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Float>> FloatArray.associateByTo(destination: M, keySelector: (Float) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Double>> DoubleArray.associateByTo(destination: M, keySelector: (Double) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Boolean>> BooleanArray.associateByTo(destination: M, keySelector: (Boolean) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Char>> CharArray.associateByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Array<out T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ByteArray.associateByTo(destination: M, keySelector: (Byte) -> K, valueTransform: (Byte) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ShortArray.associateByTo(destination: M, keySelector: (Short) -> K, valueTransform: (Short) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> IntArray.associateByTo(destination: M, keySelector: (Int) -> K, valueTransform: (Int) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> LongArray.associateByTo(destination: M, keySelector: (Long) -> K, valueTransform: (Long) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> FloatArray.associateByTo(destination: M, keySelector: (Float) -> K, valueTransform: (Float) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> DoubleArray.associateByTo(destination: M, keySelector: (Double) -> K, valueTransform: (Double) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> BooleanArray.associateByTo(destination: M, keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharArray.associateByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Array<out T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ByteArray.associateTo(destination: M, transform: (Byte) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ShortArray.associateTo(destination: M, transform: (Short) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> IntArray.associateTo(destination: M, transform: (Int) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> LongArray.associateTo(destination: M, transform: (Long) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> FloatArray.associateTo(destination: M, transform: (Float) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> DoubleArray.associateTo(destination: M, transform: (Double) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> BooleanArray.associateTo(destination: M, transform: (Boolean) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharArray.associateTo(destination: M, transform: (Char) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <K, V> Array<out K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> ByteArray.associateWith(valueSelector: (Byte) -> V): Map<Byte, V> {\n    val result = LinkedHashMap<Byte, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> ShortArray.associateWith(valueSelector: (Short) -> V): Map<Short, V> {\n    val result = LinkedHashMap<Short, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> IntArray.associateWith(valueSelector: (Int) -> V): Map<Int, V> {\n    val result = LinkedHashMap<Int, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> LongArray.associateWith(valueSelector: (Long) -> V): Map<Long, V> {\n    val result = LinkedHashMap<Long, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> FloatArray.associateWith(valueSelector: (Float) -> V): Map<Float, V> {\n    val result = LinkedHashMap<Float, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> DoubleArray.associateWith(valueSelector: (Double) -> V): Map<Double, V> {\n    val result = LinkedHashMap<Double, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> BooleanArray.associateWith(valueSelector: (Boolean) -> V): Map<Boolean, V> {\n    val result = LinkedHashMap<Boolean, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> CharArray.associateWith(valueSelector: (Char) -> V): Map<Char, V> {\n    val result = LinkedHashMap<Char, V>(mapCapacity(size.coerceAtMost(128)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Array<out K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Byte, in V>> ByteArray.associateWithTo(destination: M, valueSelector: (Byte) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Short, in V>> ShortArray.associateWithTo(destination: M, valueSelector: (Short) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Int, in V>> IntArray.associateWithTo(destination: M, valueSelector: (Int) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Long, in V>> LongArray.associateWithTo(destination: M, valueSelector: (Long) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Float, in V>> FloatArray.associateWithTo(destination: M, valueSelector: (Float) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Double, in V>> DoubleArray.associateWithTo(destination: M, valueSelector: (Double) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Boolean, in V>> BooleanArray.associateWithTo(destination: M, valueSelector: (Boolean) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Char, in V>> CharArray.associateWithTo(destination: M, valueSelector: (Char) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Array<out T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Byte>> ByteArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Short>> ShortArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Int>> IntArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Long>> LongArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Float>> FloatArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Double>> DoubleArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Boolean>> BooleanArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Char>> CharArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun <T> Array<out T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun ByteArray.toHashSet(): HashSet<Byte> {\n    return toCollection(HashSet<Byte>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun ShortArray.toHashSet(): HashSet<Short> {\n    return toCollection(HashSet<Short>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun IntArray.toHashSet(): HashSet<Int> {\n    return toCollection(HashSet<Int>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun LongArray.toHashSet(): HashSet<Long> {\n    return toCollection(HashSet<Long>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun FloatArray.toHashSet(): HashSet<Float> {\n    return toCollection(HashSet<Float>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun DoubleArray.toHashSet(): HashSet<Double> {\n    return toCollection(HashSet<Double>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun BooleanArray.toHashSet(): HashSet<Boolean> {\n    return toCollection(HashSet<Boolean>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun CharArray.toHashSet(): HashSet<Char> {\n    return toCollection(HashSet<Char>(mapCapacity(size.coerceAtMost(128))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Array<out T>.toList(): List<T> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun ByteArray.toList(): List<Byte> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun ShortArray.toList(): List<Short> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun IntArray.toList(): List<Int> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun LongArray.toList(): List<Long> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun FloatArray.toList(): List<Float> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun DoubleArray.toList(): List<Double> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun BooleanArray.toList(): List<Boolean> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun CharArray.toList(): List<Char> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun <T> Array<out T>.toMutableList(): MutableList<T> {\n    return ArrayList(this.asCollection())\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun ByteArray.toMutableList(): MutableList<Byte> {\n    val list = ArrayList<Byte>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun ShortArray.toMutableList(): MutableList<Short> {\n    val list = ArrayList<Short>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun IntArray.toMutableList(): MutableList<Int> {\n    val list = ArrayList<Int>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun LongArray.toMutableList(): MutableList<Long> {\n    val list = ArrayList<Long>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun FloatArray.toMutableList(): MutableList<Float> {\n    val list = ArrayList<Float>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun DoubleArray.toMutableList(): MutableList<Double> {\n    val list = ArrayList<Double>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun BooleanArray.toMutableList(): MutableList<Boolean> {\n    val list = ArrayList<Boolean>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun CharArray.toMutableList(): MutableList<Char> {\n    val list = ArrayList<Char>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun <T> Array<out T>.toSet(): Set<T> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ByteArray.toSet(): Set<Byte> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Byte>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ShortArray.toSet(): Set<Short> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Short>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun IntArray.toSet(): Set<Int> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Int>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun LongArray.toSet(): Set<Long> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Long>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun FloatArray.toSet(): Set<Float> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Float>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun DoubleArray.toSet(): Set<Double> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Double>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun BooleanArray.toSet(): Set<Boolean> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Boolean>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun CharArray.toSet(): Set<Char> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Char>(mapCapacity(size.coerceAtMost(128))))\n    }\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <T, R> Array<out T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> ByteArray.flatMap(transform: (Byte) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> ShortArray.flatMap(transform: (Short) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> IntArray.flatMap(transform: (Int) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> LongArray.flatMap(transform: (Long) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> FloatArray.flatMap(transform: (Float) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> DoubleArray.flatMap(transform: (Double) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> BooleanArray.flatMap(transform: (Boolean) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> CharArray.flatMap(transform: (Char) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequence\")\npublic inline fun <T, R> Array<out T>.flatMap(transform: (T) -> Sequence<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.flatMapIndexed(transform: (index: Int, T) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.flatMapIndexed(transform: (index: Int, Byte) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.flatMapIndexed(transform: (index: Int, Short) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.flatMapIndexed(transform: (index: Int, Int) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.flatMapIndexed(transform: (index: Int, Long) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.flatMapIndexed(transform: (index: Int, Float) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.flatMapIndexed(transform: (index: Int, Double) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.flatMapIndexed(transform: (index: Int, Boolean) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.flatMapIndexed(transform: (index: Int, Char) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.flatMapIndexed(transform: (index: Int, T) -> Sequence<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.flatMapIndexedTo(destination: C, transform: (index: Int, Byte) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.flatMapIndexedTo(destination: C, transform: (index: Int, Short) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> IntArray.flatMapIndexedTo(destination: C, transform: (index: Int, Int) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> LongArray.flatMapIndexedTo(destination: C, transform: (index: Int, Long) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.flatMapIndexedTo(destination: C, transform: (index: Int, Float) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.flatMapIndexedTo(destination: C, transform: (index: Int, Double) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.flatMapIndexedTo(destination: C, transform: (index: Int, Boolean) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> CharArray.flatMapIndexedTo(destination: C, transform: (index: Int, Char) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequenceTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Sequence<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.flatMapTo(destination: C, transform: (Byte) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.flatMapTo(destination: C, transform: (Short) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.flatMapTo(destination: C, transform: (Int) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.flatMapTo(destination: C, transform: (Long) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.flatMapTo(destination: C, transform: (Float) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.flatMapTo(destination: C, transform: (Double) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.flatMapTo(destination: C, transform: (Boolean) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.flatMapTo(destination: C, transform: (Char) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequenceTo\")\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Array<out T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> ByteArray.groupBy(keySelector: (Byte) -> K): Map<K, List<Byte>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Byte>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> ShortArray.groupBy(keySelector: (Short) -> K): Map<K, List<Short>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Short>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> IntArray.groupBy(keySelector: (Int) -> K): Map<K, List<Int>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Int>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> LongArray.groupBy(keySelector: (Long) -> K): Map<K, List<Long>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Long>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> FloatArray.groupBy(keySelector: (Float) -> K): Map<K, List<Float>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Float>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> DoubleArray.groupBy(keySelector: (Double) -> K): Map<K, List<Double>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Double>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> BooleanArray.groupBy(keySelector: (Boolean) -> K): Map<K, List<Boolean>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Boolean>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> CharArray.groupBy(keySelector: (Char) -> K): Map<K, List<Char>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Char>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Array<out T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> ByteArray.groupBy(keySelector: (Byte) -> K, valueTransform: (Byte) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> ShortArray.groupBy(keySelector: (Short) -> K, valueTransform: (Short) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> IntArray.groupBy(keySelector: (Int) -> K, valueTransform: (Int) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> LongArray.groupBy(keySelector: (Long) -> K, valueTransform: (Long) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> FloatArray.groupBy(keySelector: (Float) -> K, valueTransform: (Float) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> DoubleArray.groupBy(keySelector: (Double) -> K, valueTransform: (Double) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> BooleanArray.groupBy(keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> CharArray.groupBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Array<out T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Byte>>> ByteArray.groupByTo(destination: M, keySelector: (Byte) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Byte>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Short>>> ShortArray.groupByTo(destination: M, keySelector: (Short) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Short>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Int>>> IntArray.groupByTo(destination: M, keySelector: (Int) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Int>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Long>>> LongArray.groupByTo(destination: M, keySelector: (Long) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Long>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Float>>> FloatArray.groupByTo(destination: M, keySelector: (Float) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Float>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Double>>> DoubleArray.groupByTo(destination: M, keySelector: (Double) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Double>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Boolean>>> BooleanArray.groupByTo(destination: M, keySelector: (Boolean) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Boolean>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Char>>> CharArray.groupByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Char>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Array<out T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ByteArray.groupByTo(destination: M, keySelector: (Byte) -> K, valueTransform: (Byte) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ShortArray.groupByTo(destination: M, keySelector: (Short) -> K, valueTransform: (Short) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> IntArray.groupByTo(destination: M, keySelector: (Int) -> K, valueTransform: (Int) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> LongArray.groupByTo(destination: M, keySelector: (Long) -> K, valueTransform: (Long) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> FloatArray.groupByTo(destination: M, keySelector: (Float) -> K, valueTransform: (Float) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> DoubleArray.groupByTo(destination: M, keySelector: (Double) -> K, valueTransform: (Double) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> BooleanArray.groupByTo(destination: M, keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> CharArray.groupByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from an array to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Array<out T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <T, R> Array<out T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> ByteArray.map(transform: (Byte) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> ShortArray.map(transform: (Short) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> IntArray.map(transform: (Int) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> LongArray.map(transform: (Long) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> FloatArray.map(transform: (Float) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> DoubleArray.map(transform: (Double) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> BooleanArray.map(transform: (Boolean) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> CharArray.map(transform: (Char) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Array<out T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> ByteArray.mapIndexed(transform: (index: Int, Byte) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> ShortArray.mapIndexed(transform: (index: Int, Short) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> IntArray.mapIndexed(transform: (index: Int, Int) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> LongArray.mapIndexed(transform: (index: Int, Long) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> FloatArray.mapIndexed(transform: (index: Int, Float) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> DoubleArray.mapIndexed(transform: (index: Int, Double) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> BooleanArray.mapIndexed(transform: (index: Int, Boolean) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> CharArray.mapIndexed(transform: (index: Int, Char) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Array<out T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Array<out T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.mapIndexedTo(destination: C, transform: (index: Int, Byte) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.mapIndexedTo(destination: C, transform: (index: Int, Short) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.mapIndexedTo(destination: C, transform: (index: Int, Int) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.mapIndexedTo(destination: C, transform: (index: Int, Long) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.mapIndexedTo(destination: C, transform: (index: Int, Float) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.mapIndexedTo(destination: C, transform: (index: Int, Double) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.mapIndexedTo(destination: C, transform: (index: Int, Boolean) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.mapIndexedTo(destination: C, transform: (index: Int, Char) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic inline fun <T, R : Any> Array<out T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original array\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Array<out T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.mapTo(destination: C, transform: (Byte) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.mapTo(destination: C, transform: (Short) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.mapTo(destination: C, transform: (Int) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.mapTo(destination: C, transform: (Long) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.mapTo(destination: C, transform: (Float) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.mapTo(destination: C, transform: (Double) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.mapTo(destination: C, transform: (Boolean) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.mapTo(destination: C, transform: (Char) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun <T> Array<out T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun ByteArray.withIndex(): Iterable<IndexedValue<Byte>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun ShortArray.withIndex(): Iterable<IndexedValue<Short>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun IntArray.withIndex(): Iterable<IndexedValue<Int>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun LongArray.withIndex(): Iterable<IndexedValue<Long>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun FloatArray.withIndex(): Iterable<IndexedValue<Float>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun DoubleArray.withIndex(): Iterable<IndexedValue<Double>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun BooleanArray.withIndex(): Iterable<IndexedValue<Boolean>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun CharArray.withIndex(): Iterable<IndexedValue<Char>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * Among equal elements of the given array, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Array<out T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun ByteArray.distinct(): List<Byte> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun ShortArray.distinct(): List<Short> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun IntArray.distinct(): List<Int> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun LongArray.distinct(): List<Long> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun FloatArray.distinct(): List<Float> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun DoubleArray.distinct(): List<Double> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun BooleanArray.distinct(): List<Boolean> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun CharArray.distinct(): List<Char> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * Among elements of the given array with equal keys, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <T, K> Array<out T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> ByteArray.distinctBy(selector: (Byte) -> K): List<Byte> {\n    val set = HashSet<K>()\n    val list = ArrayList<Byte>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> ShortArray.distinctBy(selector: (Short) -> K): List<Short> {\n    val set = HashSet<K>()\n    val list = ArrayList<Short>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> IntArray.distinctBy(selector: (Int) -> K): List<Int> {\n    val set = HashSet<K>()\n    val list = ArrayList<Int>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> LongArray.distinctBy(selector: (Long) -> K): List<Long> {\n    val set = HashSet<K>()\n    val list = ArrayList<Long>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> FloatArray.distinctBy(selector: (Float) -> K): List<Float> {\n    val set = HashSet<K>()\n    val list = ArrayList<Float>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> DoubleArray.distinctBy(selector: (Double) -> K): List<Double> {\n    val set = HashSet<K>()\n    val list = ArrayList<Double>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> BooleanArray.distinctBy(selector: (Boolean) -> K): List<Boolean> {\n    val set = HashSet<K>()\n    val list = ArrayList<Boolean>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> CharArray.distinctBy(selector: (Char) -> K): List<Char> {\n    val set = HashSet<K>()\n    val list = ArrayList<Char>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun <T> Array<out T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun ByteArray.intersect(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun ShortArray.intersect(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun IntArray.intersect(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun LongArray.intersect(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun FloatArray.intersect(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun DoubleArray.intersect(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun BooleanArray.intersect(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun CharArray.intersect(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun <T> Array<out T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun ByteArray.subtract(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun ShortArray.subtract(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun IntArray.subtract(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun LongArray.subtract(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun FloatArray.subtract(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun DoubleArray.subtract(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun BooleanArray.subtract(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun CharArray.subtract(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun <T> Array<out T>.toMutableSet(): MutableSet<T> {\n    return toCollection(LinkedHashSet<T>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ByteArray.toMutableSet(): MutableSet<Byte> {\n    return toCollection(LinkedHashSet<Byte>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ShortArray.toMutableSet(): MutableSet<Short> {\n    return toCollection(LinkedHashSet<Short>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun IntArray.toMutableSet(): MutableSet<Int> {\n    return toCollection(LinkedHashSet<Int>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun LongArray.toMutableSet(): MutableSet<Long> {\n    return toCollection(LinkedHashSet<Long>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun FloatArray.toMutableSet(): MutableSet<Float> {\n    return toCollection(LinkedHashSet<Float>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun DoubleArray.toMutableSet(): MutableSet<Double> {\n    return toCollection(LinkedHashSet<Double>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun BooleanArray.toMutableSet(): MutableSet<Boolean> {\n    return toCollection(LinkedHashSet<Boolean>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun CharArray.toMutableSet(): MutableSet<Char> {\n    return toCollection(LinkedHashSet<Char>(mapCapacity(size.coerceAtMost(128))))\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun <T> Array<out T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun ByteArray.union(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun ShortArray.union(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun IntArray.union(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun LongArray.union(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun FloatArray.union(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun DoubleArray.union(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun BooleanArray.union(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun CharArray.union(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Array<out T>.all(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun ByteArray.all(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun ShortArray.all(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun IntArray.all(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun LongArray.all(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun FloatArray.all(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun DoubleArray.all(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun BooleanArray.all(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun CharArray.all(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Array<out T>.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun ByteArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun ShortArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun IntArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun LongArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun FloatArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun DoubleArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun BooleanArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun CharArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Array<out T>.any(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun ByteArray.any(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun ShortArray.any(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun IntArray.any(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun LongArray.any(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun FloatArray.any(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun DoubleArray.any(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun BooleanArray.any(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun CharArray.any(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Array<out T>.count(predicate: (T) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun ByteArray.count(predicate: (Byte) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun ShortArray.count(predicate: (Short) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun IntArray.count(predicate: (Int) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun LongArray.count(predicate: (Long) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun FloatArray.count(predicate: (Float) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun DoubleArray.count(predicate: (Double) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun BooleanArray.count(predicate: (Boolean) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun CharArray.count(predicate: (Char) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.fold(initial: R, operation: (acc: R, Byte) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.fold(initial: R, operation: (acc: R, Short) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.fold(initial: R, operation: (acc: R, Int) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.fold(initial: R, operation: (acc: R, Long) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.fold(initial: R, operation: (acc: R, Float) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.fold(initial: R, operation: (acc: R, Double) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.fold(initial: R, operation: (acc: R, Boolean) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.fold(initial: R, operation: (acc: R, Char) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Byte) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Short) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Boolean) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldRight(initial: R, operation: (Byte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldRight(initial: R, operation: (Short, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldRight(initial: R, operation: (Int, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldRight(initial: R, operation: (Long, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldRight(initial: R, operation: (Float, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldRight(initial: R, operation: (Double, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldRight(initial: R, operation: (Boolean, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldRight(initial: R, operation: (Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldRightIndexed(initial: R, operation: (index: Int, Byte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldRightIndexed(initial: R, operation: (index: Int, Short, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldRightIndexed(initial: R, operation: (index: Int, Int, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldRightIndexed(initial: R, operation: (index: Int, Long, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldRightIndexed(initial: R, operation: (index: Int, Float, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldRightIndexed(initial: R, operation: (index: Int, Double, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldRightIndexed(initial: R, operation: (index: Int, Boolean, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldRightIndexed(initial: R, operation: (index: Int, Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun <T> Array<out T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun ByteArray.forEach(action: (Byte) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun ShortArray.forEach(action: (Short) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun IntArray.forEach(action: (Int) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun LongArray.forEach(action: (Long) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun FloatArray.forEach(action: (Float) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun DoubleArray.forEach(action: (Double) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun BooleanArray.forEach(action: (Boolean) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun CharArray.forEach(action: (Char) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun <T> Array<out T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun ByteArray.forEachIndexed(action: (index: Int, Byte) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun ShortArray.forEachIndexed(action: (index: Int, Short) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun IntArray.forEachIndexed(action: (index: Int, Int) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun LongArray.forEachIndexed(action: (index: Int, Long) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun FloatArray.forEachIndexed(action: (index: Int, Float) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun DoubleArray.forEachIndexed(action: (index: Int, Double) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun BooleanArray.forEachIndexed(action: (index: Int, Boolean) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun CharArray.forEachIndexed(action: (index: Int, Char) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Returns the largest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun Array<out Double>.max(): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun Array<out Float>.max(): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun <T : Comparable<T>> Array<out T>.max(): T {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun ByteArray.max(): Byte {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun ShortArray.max(): Short {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun IntArray.max(): Int {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun LongArray.max(): Long {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun FloatArray.max(): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun DoubleArray.max(): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun CharArray.max(): Char {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxBy(selector: (T) -> R): T {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> ByteArray.maxBy(selector: (Byte) -> R): Byte {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> ShortArray.maxBy(selector: (Short) -> R): Short {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> IntArray.maxBy(selector: (Int) -> R): Int {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> LongArray.maxBy(selector: (Long) -> R): Long {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> FloatArray.maxBy(selector: (Float) -> R): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> DoubleArray.maxBy(selector: (Double) -> R): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> BooleanArray.maxBy(selector: (Boolean) -> R): Boolean {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> CharArray.maxBy(selector: (Char) -> R): Char {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxByOrNull(selector: (T) -> R): T? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ByteArray.maxByOrNull(selector: (Byte) -> R): Byte? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ShortArray.maxByOrNull(selector: (Short) -> R): Short? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> IntArray.maxByOrNull(selector: (Int) -> R): Int? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> LongArray.maxByOrNull(selector: (Long) -> R): Long? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> FloatArray.maxByOrNull(selector: (Float) -> R): Float? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> DoubleArray.maxByOrNull(selector: (Double) -> R): Double? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> BooleanArray.maxByOrNull(selector: (Boolean) -> R): Boolean? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharArray.maxByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOf(selector: (T) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOf(selector: (Byte) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOf(selector: (Short) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOf(selector: (Int) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOf(selector: (Long) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOf(selector: (Float) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOf(selector: (Double) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOf(selector: (Boolean) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOf(selector: (T) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOf(selector: (Byte) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOf(selector: (Short) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOf(selector: (Int) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOf(selector: (Long) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOf(selector: (Float) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOf(selector: (Double) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOf(selector: (Boolean) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxOf(selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.maxOf(selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.maxOf(selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.maxOf(selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.maxOf(selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.maxOf(selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.maxOf(selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.maxOf(selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.maxOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOfOrNull(selector: (T) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOfOrNull(selector: (Byte) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOfOrNull(selector: (Short) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOfOrNull(selector: (Int) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOfOrNull(selector: (Long) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOfOrNull(selector: (Float) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOfOrNull(selector: (Double) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOfOrNull(selector: (Boolean) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOfOrNull(selector: (T) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOfOrNull(selector: (Byte) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOfOrNull(selector: (Short) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOfOrNull(selector: (Int) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOfOrNull(selector: (Long) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOfOrNull(selector: (Float) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOfOrNull(selector: (Double) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOfOrNull(selector: (Boolean) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxOfOrNull(selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.maxOfOrNull(selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.maxOfOrNull(selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.maxOfOrNull(selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.maxOfOrNull(selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.maxOfOrNull(selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.maxOfOrNull(selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.maxOfOrNull(selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.maxOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.maxOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.maxOfWith(comparator: Comparator<in R>, selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.maxOfWith(comparator: Comparator<in R>, selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.maxOfWith(comparator: Comparator<in R>, selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.maxOfWith(comparator: Comparator<in R>, selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.maxOfWith(comparator: Comparator<in R>, selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.maxOfWith(comparator: Comparator<in R>, selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.maxOfWith(comparator: Comparator<in R>, selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.maxOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Double>.maxOrNull(): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Float>.maxOrNull(): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Array<out T>.maxOrNull(): T? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.maxOrNull(): Byte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.maxOrNull(): Short? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.maxOrNull(): Int? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.maxOrNull(): Long? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.maxOrNull(): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.maxOrNull(): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.maxOrNull(): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun <T> Array<out T>.maxWith(comparator: Comparator<in T>): T {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun ByteArray.maxWith(comparator: Comparator<in Byte>): Byte {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun ShortArray.maxWith(comparator: Comparator<in Short>): Short {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun IntArray.maxWith(comparator: Comparator<in Int>): Int {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun LongArray.maxWith(comparator: Comparator<in Long>): Long {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun FloatArray.maxWith(comparator: Comparator<in Float>): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun DoubleArray.maxWith(comparator: Comparator<in Double>): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun BooleanArray.maxWith(comparator: Comparator<in Boolean>): Boolean {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun CharArray.maxWith(comparator: Comparator<in Char>): Char {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<out T>.maxWithOrNull(comparator: Comparator<in T>): T? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.maxWithOrNull(comparator: Comparator<in Byte>): Byte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.maxWithOrNull(comparator: Comparator<in Short>): Short? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.maxWithOrNull(comparator: Comparator<in Int>): Int? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.maxWithOrNull(comparator: Comparator<in Long>): Long? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.maxWithOrNull(comparator: Comparator<in Float>): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.maxWithOrNull(comparator: Comparator<in Double>): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.maxWithOrNull(comparator: Comparator<in Boolean>): Boolean? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.maxWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun Array<out Double>.min(): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun Array<out Float>.min(): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun <T : Comparable<T>> Array<out T>.min(): T {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun ByteArray.min(): Byte {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun ShortArray.min(): Short {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun IntArray.min(): Int {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun LongArray.min(): Long {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun FloatArray.min(): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun DoubleArray.min(): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun CharArray.min(): Char {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.minBy(selector: (T) -> R): T {\n    if (isEmpty()) throw NoSuchElementException()\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> ByteArray.minBy(selector: (Byte) -> R): Byte {\n    if (isEmpty()) throw NoSuchElementException()\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> ShortArray.minBy(selector: (Short) -> R): Short {\n    if (isEmpty()) throw NoSuchElementException()\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> IntArray.minBy(selector: (Int) -> R): Int {\n    if (isEmpty()) throw NoSuchElementException()\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> LongArray.minBy(selector: (Long) -> R): Long {\n    if (isEmpty()) throw NoSuchElementException()\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> FloatArray.minBy(selector: (Float) -> R): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> DoubleArray.minBy(selector: (Double) -> R): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> BooleanArray.minBy(selector: (Boolean) -> R): Boolean {\n    if (isEmpty()) throw NoSuchElementException()\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> CharArray.minBy(selector: (Char) -> R): Char {\n    if (isEmpty()) throw NoSuchElementException()\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.minByOrNull(selector: (T) -> R): T? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ByteArray.minByOrNull(selector: (Byte) -> R): Byte? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ShortArray.minByOrNull(selector: (Short) -> R): Short? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> IntArray.minByOrNull(selector: (Int) -> R): Int? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> LongArray.minByOrNull(selector: (Long) -> R): Long? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> FloatArray.minByOrNull(selector: (Float) -> R): Float? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> DoubleArray.minByOrNull(selector: (Double) -> R): Double? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> BooleanArray.minByOrNull(selector: (Boolean) -> R): Boolean? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharArray.minByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOf(selector: (T) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOf(selector: (Byte) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOf(selector: (Short) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOf(selector: (Int) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOf(selector: (Long) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOf(selector: (Float) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOf(selector: (Double) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOf(selector: (Boolean) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOf(selector: (T) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOf(selector: (Byte) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOf(selector: (Short) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOf(selector: (Int) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOf(selector: (Long) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOf(selector: (Float) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOf(selector: (Double) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOf(selector: (Boolean) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.minOf(selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.minOf(selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.minOf(selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.minOf(selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.minOf(selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.minOf(selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.minOf(selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.minOf(selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.minOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOfOrNull(selector: (T) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOfOrNull(selector: (Byte) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOfOrNull(selector: (Short) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOfOrNull(selector: (Int) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOfOrNull(selector: (Long) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOfOrNull(selector: (Float) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOfOrNull(selector: (Double) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOfOrNull(selector: (Boolean) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOfOrNull(selector: (T) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOfOrNull(selector: (Byte) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOfOrNull(selector: (Short) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOfOrNull(selector: (Int) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOfOrNull(selector: (Long) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOfOrNull(selector: (Float) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOfOrNull(selector: (Double) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOfOrNull(selector: (Boolean) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.minOfOrNull(selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.minOfOrNull(selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.minOfOrNull(selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.minOfOrNull(selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.minOfOrNull(selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.minOfOrNull(selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.minOfOrNull(selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.minOfOrNull(selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.minOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.minOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.minOfWith(comparator: Comparator<in R>, selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.minOfWith(comparator: Comparator<in R>, selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.minOfWith(comparator: Comparator<in R>, selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.minOfWith(comparator: Comparator<in R>, selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.minOfWith(comparator: Comparator<in R>, selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.minOfWith(comparator: Comparator<in R>, selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.minOfWith(comparator: Comparator<in R>, selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.minOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.minOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Double>.minOrNull(): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Float>.minOrNull(): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Array<out T>.minOrNull(): T? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.minOrNull(): Byte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.minOrNull(): Short? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.minOrNull(): Int? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.minOrNull(): Long? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.minOrNull(): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.minOrNull(): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.minOrNull(): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun <T> Array<out T>.minWith(comparator: Comparator<in T>): T {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun ByteArray.minWith(comparator: Comparator<in Byte>): Byte {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun ShortArray.minWith(comparator: Comparator<in Short>): Short {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun IntArray.minWith(comparator: Comparator<in Int>): Int {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun LongArray.minWith(comparator: Comparator<in Long>): Long {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun FloatArray.minWith(comparator: Comparator<in Float>): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun DoubleArray.minWith(comparator: Comparator<in Double>): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun BooleanArray.minWith(comparator: Comparator<in Boolean>): Boolean {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun CharArray.minWith(comparator: Comparator<in Char>): Char {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<out T>.minWithOrNull(comparator: Comparator<in T>): T? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.minWithOrNull(comparator: Comparator<in Byte>): Byte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.minWithOrNull(comparator: Comparator<in Short>): Short? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.minWithOrNull(comparator: Comparator<in Int>): Int? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.minWithOrNull(comparator: Comparator<in Long>): Long? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.minWithOrNull(comparator: Comparator<in Float>): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.minWithOrNull(comparator: Comparator<in Double>): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.minWithOrNull(comparator: Comparator<in Boolean>): Boolean? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.minWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Array<out T>.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun ByteArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun ShortArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun IntArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun LongArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun FloatArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun DoubleArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun BooleanArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun CharArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Array<out T>.none(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun ByteArray.none(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun ShortArray.none(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun IntArray.none(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun LongArray.none(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun FloatArray.none(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun DoubleArray.none(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun BooleanArray.none(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun CharArray.none(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.onEach(action: (T) -> Unit): Array<out T> {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.onEach(action: (Byte) -> Unit): ByteArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.onEach(action: (Short) -> Unit): ShortArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.onEach(action: (Int) -> Unit): IntArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.onEach(action: (Long) -> Unit): LongArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.onEach(action: (Float) -> Unit): FloatArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.onEach(action: (Double) -> Unit): DoubleArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.onEach(action: (Boolean) -> Unit): BooleanArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.onEach(action: (Char) -> Unit): CharArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.onEachIndexed(action: (index: Int, T) -> Unit): Array<out T> {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.onEachIndexed(action: (index: Int, Byte) -> Unit): ByteArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.onEachIndexed(action: (index: Int, Short) -> Unit): ShortArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.onEachIndexed(action: (index: Int, Int) -> Unit): IntArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.onEachIndexed(action: (index: Int, Long) -> Unit): LongArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.onEachIndexed(action: (index: Int, Float) -> Unit): FloatArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.onEachIndexed(action: (index: Int, Double) -> Unit): DoubleArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.onEachIndexed(action: (index: Int, Boolean) -> Unit): BooleanArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.onEachIndexed(action: (index: Int, Char) -> Unit): CharArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Array<out T>.reduce(operation: (acc: S, T) -> S): S {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ByteArray.reduce(operation: (acc: Byte, Byte) -> Byte): Byte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ShortArray.reduce(operation: (acc: Short, Short) -> Short): Short {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun IntArray.reduce(operation: (acc: Int, Int) -> Int): Int {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun LongArray.reduce(operation: (acc: Long, Long) -> Long): Long {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun FloatArray.reduce(operation: (acc: Float, Float) -> Float): Float {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun DoubleArray.reduce(operation: (acc: Double, Double) -> Double): Double {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun BooleanArray.reduce(operation: (acc: Boolean, Boolean) -> Boolean): Boolean {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharArray.reduce(operation: (acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Array<out T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ByteArray.reduceIndexed(operation: (index: Int, acc: Byte, Byte) -> Byte): Byte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ShortArray.reduceIndexed(operation: (index: Int, acc: Short, Short) -> Short): Short {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun IntArray.reduceIndexed(operation: (index: Int, acc: Int, Int) -> Int): Int {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun LongArray.reduceIndexed(operation: (index: Int, acc: Long, Long) -> Long): Long {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun FloatArray.reduceIndexed(operation: (index: Int, acc: Float, Float) -> Float): Float {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun DoubleArray.reduceIndexed(operation: (index: Int, acc: Double, Double) -> Double): Double {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun BooleanArray.reduceIndexed(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): Boolean {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharArray.reduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Array<out T>.reduceIndexedOrNull(operation: (index: Int, acc: S, T) -> S): S? {\n    if (isEmpty())\n        return null\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ByteArray.reduceIndexedOrNull(operation: (index: Int, acc: Byte, Byte) -> Byte): Byte? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ShortArray.reduceIndexedOrNull(operation: (index: Int, acc: Short, Short) -> Short): Short? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun IntArray.reduceIndexedOrNull(operation: (index: Int, acc: Int, Int) -> Int): Int? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun LongArray.reduceIndexedOrNull(operation: (index: Int, acc: Long, Long) -> Long): Long? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun FloatArray.reduceIndexedOrNull(operation: (index: Int, acc: Float, Float) -> Float): Float? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun DoubleArray.reduceIndexedOrNull(operation: (index: Int, acc: Double, Double) -> Double): Double? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun BooleanArray.reduceIndexedOrNull(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): Boolean? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharArray.reduceIndexedOrNull(operation: (index: Int, acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Array<out T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    if (isEmpty())\n        return null\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ByteArray.reduceOrNull(operation: (acc: Byte, Byte) -> Byte): Byte? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ShortArray.reduceOrNull(operation: (acc: Short, Short) -> Short): Short? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun IntArray.reduceOrNull(operation: (acc: Int, Int) -> Int): Int? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun LongArray.reduceOrNull(operation: (acc: Long, Long) -> Long): Long? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun FloatArray.reduceOrNull(operation: (acc: Float, Float) -> Float): Float? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun DoubleArray.reduceOrNull(operation: (acc: Double, Double) -> Double): Double? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun BooleanArray.reduceOrNull(operation: (acc: Boolean, Boolean) -> Boolean): Boolean? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharArray.reduceOrNull(operation: (acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> Array<out T>.reduceRight(operation: (T, acc: S) -> S): S {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ByteArray.reduceRight(operation: (Byte, acc: Byte) -> Byte): Byte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ShortArray.reduceRight(operation: (Short, acc: Short) -> Short): Short {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun IntArray.reduceRight(operation: (Int, acc: Int) -> Int): Int {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun LongArray.reduceRight(operation: (Long, acc: Long) -> Long): Long {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun FloatArray.reduceRight(operation: (Float, acc: Float) -> Float): Float {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun DoubleArray.reduceRight(operation: (Double, acc: Double) -> Double): Double {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun BooleanArray.reduceRight(operation: (Boolean, acc: Boolean) -> Boolean): Boolean {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharArray.reduceRight(operation: (Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> Array<out T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ByteArray.reduceRightIndexed(operation: (index: Int, Byte, acc: Byte) -> Byte): Byte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ShortArray.reduceRightIndexed(operation: (index: Int, Short, acc: Short) -> Short): Short {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun IntArray.reduceRightIndexed(operation: (index: Int, Int, acc: Int) -> Int): Int {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun LongArray.reduceRightIndexed(operation: (index: Int, Long, acc: Long) -> Long): Long {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun FloatArray.reduceRightIndexed(operation: (index: Int, Float, acc: Float) -> Float): Float {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun DoubleArray.reduceRightIndexed(operation: (index: Int, Double, acc: Double) -> Double): Double {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun BooleanArray.reduceRightIndexed(operation: (index: Int, Boolean, acc: Boolean) -> Boolean): Boolean {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharArray.reduceRightIndexed(operation: (index: Int, Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Array<out T>.reduceRightIndexedOrNull(operation: (index: Int, T, acc: S) -> S): S? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ByteArray.reduceRightIndexedOrNull(operation: (index: Int, Byte, acc: Byte) -> Byte): Byte? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ShortArray.reduceRightIndexedOrNull(operation: (index: Int, Short, acc: Short) -> Short): Short? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun IntArray.reduceRightIndexedOrNull(operation: (index: Int, Int, acc: Int) -> Int): Int? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun LongArray.reduceRightIndexedOrNull(operation: (index: Int, Long, acc: Long) -> Long): Long? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun FloatArray.reduceRightIndexedOrNull(operation: (index: Int, Float, acc: Float) -> Float): Float? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun DoubleArray.reduceRightIndexedOrNull(operation: (index: Int, Double, acc: Double) -> Double): Double? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun BooleanArray.reduceRightIndexedOrNull(operation: (index: Int, Boolean, acc: Boolean) -> Boolean): Boolean? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharArray.reduceRightIndexedOrNull(operation: (index: Int, Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Array<out T>.reduceRightOrNull(operation: (T, acc: S) -> S): S? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ByteArray.reduceRightOrNull(operation: (Byte, acc: Byte) -> Byte): Byte? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ShortArray.reduceRightOrNull(operation: (Short, acc: Short) -> Short): Short? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun IntArray.reduceRightOrNull(operation: (Int, acc: Int) -> Int): Int? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun LongArray.reduceRightOrNull(operation: (Long, acc: Long) -> Long): Long? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun FloatArray.reduceRightOrNull(operation: (Float, acc: Float) -> Float): Float? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun DoubleArray.reduceRightOrNull(operation: (Double, acc: Double) -> Double): Double? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun BooleanArray.reduceRightOrNull(operation: (Boolean, acc: Boolean) -> Boolean): Boolean? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharArray.reduceRightOrNull(operation: (Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Array<out T>.runningFold(initial: R, operation: (acc: R, T) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.runningFold(initial: R, operation: (acc: R, Byte) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.runningFold(initial: R, operation: (acc: R, Short) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.runningFold(initial: R, operation: (acc: R, Int) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.runningFold(initial: R, operation: (acc: R, Long) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.runningFold(initial: R, operation: (acc: R, Float) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.runningFold(initial: R, operation: (acc: R, Double) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.runningFold(initial: R, operation: (acc: R, Boolean) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.runningFold(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Array<out T>.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Byte) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Short) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Boolean) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Array<out T>.runningReduce(operation: (acc: S, T) -> S): List<S> {\n    if (isEmpty()) return emptyList()\n    var accumulator: S = this[0]\n    val result = ArrayList<S>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.runningReduce(operation: (acc: Byte, Byte) -> Byte): List<Byte> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Byte>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.runningReduce(operation: (acc: Short, Short) -> Short): List<Short> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Short>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.runningReduce(operation: (acc: Int, Int) -> Int): List<Int> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Int>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.runningReduce(operation: (acc: Long, Long) -> Long): List<Long> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Long>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.runningReduce(operation: (acc: Float, Float) -> Float): List<Float> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Float>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.runningReduce(operation: (acc: Double, Double) -> Double): List<Double> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Double>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.runningReduce(operation: (acc: Boolean, Boolean) -> Boolean): List<Boolean> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Boolean>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.runningReduce(operation: (acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Array<out T>.runningReduceIndexed(operation: (index: Int, acc: S, T) -> S): List<S> {\n    if (isEmpty()) return emptyList()\n    var accumulator: S = this[0]\n    val result = ArrayList<S>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.runningReduceIndexed(operation: (index: Int, acc: Byte, Byte) -> Byte): List<Byte> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Byte>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.runningReduceIndexed(operation: (index: Int, acc: Short, Short) -> Short): List<Short> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Short>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.runningReduceIndexed(operation: (index: Int, acc: Int, Int) -> Int): List<Int> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Int>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.runningReduceIndexed(operation: (index: Int, acc: Long, Long) -> Long): List<Long> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Long>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.runningReduceIndexed(operation: (index: Int, acc: Float, Float) -> Float): List<Float> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Float>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.runningReduceIndexed(operation: (index: Int, acc: Double, Double) -> Double): List<Double> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Double>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.runningReduceIndexed(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): List<Boolean> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Boolean>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.runningReduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Array<out T>.scan(initial: R, operation: (acc: R, T) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.scan(initial: R, operation: (acc: R, Byte) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.scan(initial: R, operation: (acc: R, Short) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.scan(initial: R, operation: (acc: R, Int) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.scan(initial: R, operation: (acc: R, Long) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.scan(initial: R, operation: (acc: R, Float) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.scan(initial: R, operation: (acc: R, Double) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.scan(initial: R, operation: (acc: R, Boolean) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.scan(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Array<out T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Byte) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Short) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Boolean) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Array<out T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun ByteArray.sumBy(selector: (Byte) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun ShortArray.sumBy(selector: (Short) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun IntArray.sumBy(selector: (Int) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun LongArray.sumBy(selector: (Long) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun FloatArray.sumBy(selector: (Float) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun DoubleArray.sumBy(selector: (Double) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun BooleanArray.sumBy(selector: (Boolean) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun CharArray.sumBy(selector: (Char) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Array<out T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun ByteArray.sumByDouble(selector: (Byte) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun ShortArray.sumByDouble(selector: (Short) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun IntArray.sumByDouble(selector: (Int) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun LongArray.sumByDouble(selector: (Long) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun FloatArray.sumByDouble(selector: (Float) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun DoubleArray.sumByDouble(selector: (Double) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun BooleanArray.sumByDouble(selector: (Boolean) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun CharArray.sumByDouble(selector: (Char) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Array<T?>.requireNoNulls(): Array<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Array<T>\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun <T> Array<out T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun ByteArray.partition(predicate: (Byte) -> Boolean): Pair<List<Byte>, List<Byte>> {\n    val first = ArrayList<Byte>()\n    val second = ArrayList<Byte>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun ShortArray.partition(predicate: (Short) -> Boolean): Pair<List<Short>, List<Short>> {\n    val first = ArrayList<Short>()\n    val second = ArrayList<Short>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun IntArray.partition(predicate: (Int) -> Boolean): Pair<List<Int>, List<Int>> {\n    val first = ArrayList<Int>()\n    val second = ArrayList<Int>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun LongArray.partition(predicate: (Long) -> Boolean): Pair<List<Long>, List<Long>> {\n    val first = ArrayList<Long>()\n    val second = ArrayList<Long>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun FloatArray.partition(predicate: (Float) -> Boolean): Pair<List<Float>, List<Float>> {\n    val first = ArrayList<Float>()\n    val second = ArrayList<Float>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun DoubleArray.partition(predicate: (Double) -> Boolean): Pair<List<Double>, List<Double>> {\n    val first = ArrayList<Double>()\n    val second = ArrayList<Double>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun BooleanArray.partition(predicate: (Boolean) -> Boolean): Pair<List<Boolean>, List<Boolean>> {\n    val first = ArrayList<Boolean>()\n    val second = ArrayList<Boolean>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun CharArray.partition(predicate: (Char) -> Boolean): Pair<List<Char>, List<Char>> {\n    val first = ArrayList<Char>()\n    val second = ArrayList<Char>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Array<out T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ByteArray.zip(other: Array<out R>): List<Pair<Byte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ShortArray.zip(other: Array<out R>): List<Pair<Short, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> IntArray.zip(other: Array<out R>): List<Pair<Int, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> LongArray.zip(other: Array<out R>): List<Pair<Long, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> FloatArray.zip(other: Array<out R>): List<Pair<Float, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> DoubleArray.zip(other: Array<out R>): List<Pair<Double, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> BooleanArray.zip(other: Array<out R>): List<Pair<Boolean, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> CharArray.zip(other: Array<out R>): List<Pair<Char, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Array<out T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ByteArray.zip(other: Array<out R>, transform: (a: Byte, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ShortArray.zip(other: Array<out R>, transform: (a: Short, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> IntArray.zip(other: Array<out R>, transform: (a: Int, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> LongArray.zip(other: Array<out R>, transform: (a: Long, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> FloatArray.zip(other: Array<out R>, transform: (a: Float, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> DoubleArray.zip(other: Array<out R>, transform: (a: Double, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> BooleanArray.zip(other: Array<out R>, transform: (a: Boolean, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> CharArray.zip(other: Array<out R>, transform: (a: Char, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Array<out T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ByteArray.zip(other: Iterable<R>): List<Pair<Byte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ShortArray.zip(other: Iterable<R>): List<Pair<Short, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> IntArray.zip(other: Iterable<R>): List<Pair<Int, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> LongArray.zip(other: Iterable<R>): List<Pair<Long, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> FloatArray.zip(other: Iterable<R>): List<Pair<Float, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> DoubleArray.zip(other: Iterable<R>): List<Pair<Double, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> BooleanArray.zip(other: Iterable<R>): List<Pair<Boolean, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> CharArray.zip(other: Iterable<R>): List<Pair<Char, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Array<out T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ByteArray.zip(other: Iterable<R>, transform: (a: Byte, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ShortArray.zip(other: Iterable<R>, transform: (a: Short, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> IntArray.zip(other: Iterable<R>, transform: (a: Int, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> LongArray.zip(other: Iterable<R>, transform: (a: Long, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> FloatArray.zip(other: Iterable<R>, transform: (a: Float, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> DoubleArray.zip(other: Iterable<R>, transform: (a: Double, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> BooleanArray.zip(other: Iterable<R>, transform: (a: Boolean, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> CharArray.zip(other: Iterable<R>, transform: (a: Char, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun ByteArray.zip(other: ByteArray): List<Pair<Byte, Byte>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun ShortArray.zip(other: ShortArray): List<Pair<Short, Short>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun IntArray.zip(other: IntArray): List<Pair<Int, Int>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun LongArray.zip(other: LongArray): List<Pair<Long, Long>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun FloatArray.zip(other: FloatArray): List<Pair<Float, Float>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun DoubleArray.zip(other: DoubleArray): List<Pair<Double, Double>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun BooleanArray.zip(other: BooleanArray): List<Pair<Boolean, Boolean>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun CharArray.zip(other: CharArray): List<Pair<Char, Char>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> ByteArray.zip(other: ByteArray, transform: (a: Byte, b: Byte) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> ShortArray.zip(other: ShortArray, transform: (a: Short, b: Short) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> IntArray.zip(other: IntArray, transform: (a: Int, b: Int) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> LongArray.zip(other: LongArray, transform: (a: Long, b: Long) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> FloatArray.zip(other: FloatArray, transform: (a: Float, b: Float) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> DoubleArray.zip(other: DoubleArray, transform: (a: Double, b: Double) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> BooleanArray.zip(other: BooleanArray, transform: (a: Boolean, b: Boolean) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> CharArray.zip(other: CharArray, transform: (a: Char, b: Char) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Array<out T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> ByteArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Byte) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> ShortArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Short) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> IntArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Int) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> LongArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Long) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> FloatArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Float) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> DoubleArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Double) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> BooleanArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Boolean) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> CharArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Char) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Array<out T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun ByteArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Byte) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun ShortArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Short) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun IntArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Int) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun LongArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Long) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun FloatArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Float) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun DoubleArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Double) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun BooleanArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Boolean) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun CharArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Char) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun <T> Array<out T>.asIterable(): Iterable<T> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun ByteArray.asIterable(): Iterable<Byte> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun ShortArray.asIterable(): Iterable<Short> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun IntArray.asIterable(): Iterable<Int> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun LongArray.asIterable(): Iterable<Long> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun FloatArray.asIterable(): Iterable<Float> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun DoubleArray.asIterable(): Iterable<Double> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun BooleanArray.asIterable(): Iterable<Boolean> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun CharArray.asIterable(): Iterable<Char> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun <T> Array<out T>.asSequence(): Sequence<T> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun ByteArray.asSequence(): Sequence<Byte> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun ShortArray.asSequence(): Sequence<Short> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun IntArray.asSequence(): Sequence<Int> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun LongArray.asSequence(): Sequence<Long> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun FloatArray.asSequence(): Sequence<Float> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun DoubleArray.asSequence(): Sequence<Double> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun BooleanArray.asSequence(): Sequence<Boolean> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun CharArray.asSequence(): Sequence<Char> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Array<out Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Array<out Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Array<out Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Array<out Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Array<out Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Array<out Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun ByteArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun ShortArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun IntArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun LongArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun FloatArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun DoubleArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Array<out Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Array<out Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Array<out Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Array<out Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Array<out Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Array<out Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun ByteArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun ShortArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun IntArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun LongArray.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun FloatArray.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun DoubleArray.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"RangesKt\")\n\npackage kotlin.ranges\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the progression is empty.\n */\n@SinceKotlin(\"1.7\")\npublic fun IntProgression.first(): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Progression $this is empty.\")\n    return this.first\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the progression is empty.\n */\n@SinceKotlin(\"1.7\")\npublic fun LongProgression.first(): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Progression $this is empty.\")\n    return this.first\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the progression is empty.\n */\n@SinceKotlin(\"1.7\")\npublic fun CharProgression.first(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Progression $this is empty.\")\n    return this.first\n}\n\n/**\n * Returns the first element, or `null` if the progression is empty.\n */\n@SinceKotlin(\"1.7\")\npublic fun IntProgression.firstOrNull(): Int? {\n    return if (isEmpty()) null else this.first\n}\n\n/**\n * Returns the first element, or `null` if the progression is empty.\n */\n@SinceKotlin(\"1.7\")\npublic fun LongProgression.firstOrNull(): Long? {\n    return if (isEmpty()) null else this.first\n}\n\n/**\n * Returns the first element, or `null` if the progression is empty.\n */\n@SinceKotlin(\"1.7\")\npublic fun CharProgression.firstOrNull(): Char? {\n    return if (isEmpty()) null else this.first\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the progression is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.7\")\npublic fun IntProgression.last(): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Progression $this is empty.\")\n    return this.last\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the progression is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.7\")\npublic fun LongProgression.last(): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Progression $this is empty.\")\n    return this.last\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the progression is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.7\")\npublic fun CharProgression.last(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Progression $this is empty.\")\n    return this.last\n}\n\n/**\n * Returns the last element, or `null` if the progression is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.7\")\npublic fun IntProgression.lastOrNull(): Int? {\n    return if (isEmpty()) null else this.last\n}\n\n/**\n * Returns the last element, or `null` if the progression is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.7\")\npublic fun LongProgression.lastOrNull(): Long? {\n    return if (isEmpty()) null else this.last\n}\n\n/**\n * Returns the last element, or `null` if the progression is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.7\")\npublic fun CharProgression.lastOrNull(): Char? {\n    return if (isEmpty()) null else this.last\n}\n\n/**\n * Returns a random element from this range.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun IntRange.random(): Int {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this range.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun LongRange.random(): Long {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this range.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun CharRange.random(): Char {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun IntRange.random(random: Random): Int {\n    try {\n        return random.nextInt(this)\n    } catch(e: IllegalArgumentException) {\n        throw NoSuchElementException(e.message)\n    }\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun LongRange.random(random: Random): Long {\n    try {\n        return random.nextLong(this)\n    } catch(e: IllegalArgumentException) {\n        throw NoSuchElementException(e.message)\n    }\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun CharRange.random(random: Random): Char {\n    try {\n        return random.nextInt(first.code, last.code + 1).toChar()\n    } catch(e: IllegalArgumentException) {\n        throw NoSuchElementException(e.message)\n    }\n}\n\n/**\n * Returns a random element from this range, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun IntRange.randomOrNull(): Int? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this range, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun LongRange.randomOrNull(): Long? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this range, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharRange.randomOrNull(): Char? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun IntRange.randomOrNull(random: Random): Int? {\n    if (isEmpty())\n        return null\n    return random.nextInt(this)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun LongRange.randomOrNull(random: Random): Long? {\n    if (isEmpty())\n        return null\n    return random.nextLong(this)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun CharRange.randomOrNull(random: Random): Char? {\n    if (isEmpty())\n        return null\n    return random.nextInt(first.code, last.code + 1).toChar()\n}\n\n/**\n * Returns `true` if this range contains the specified [element].\n * \n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun IntRange.contains(element: Int?): Boolean {\n    return element != null && contains(element)\n}\n\n/**\n * Returns `true` if this range contains the specified [element].\n * \n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun LongRange.contains(element: Long?): Boolean {\n    return element != null && contains(element)\n}\n\n/**\n * Returns `true` if this range contains the specified [element].\n * \n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun CharRange.contains(element: Char?): Boolean {\n    return element != null && contains(element)\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Byte): Boolean {\n    return contains(value.toInt())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Byte): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Byte): Boolean {\n    return contains(value.toShort())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Byte): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Byte): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\npublic operator fun OpenEndRange<Int>.contains(value: Byte): Boolean {\n    return contains(value.toInt())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\npublic operator fun OpenEndRange<Long>.contains(value: Byte): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\npublic operator fun OpenEndRange<Short>.contains(value: Byte): Boolean {\n    return contains(value.toShort())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntRange.contains(value: Byte): Boolean {\n    return (this as ClosedRange<Int>).contains(value)\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongRange.contains(value: Byte): Boolean {\n    return (this as ClosedRange<Long>).contains(value)\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Double): Boolean {\n    return value.toIntExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Double): Boolean {\n    return value.toLongExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Double): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Double): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Double): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Float): Boolean {\n    return value.toIntExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Float): Boolean {\n    return value.toLongExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Float): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Float): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Float): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\npublic operator fun OpenEndRange<Double>.contains(value: Float): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Int): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Int): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Int): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Int): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Int): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\npublic operator fun OpenEndRange<Long>.contains(value: Int): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\npublic operator fun OpenEndRange<Byte>.contains(value: Int): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\npublic operator fun OpenEndRange<Short>.contains(value: Int): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongRange.contains(value: Int): Boolean {\n    return (this as ClosedRange<Long>).contains(value)\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Long): Boolean {\n    return value.toIntExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Long): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Long): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Long): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Long): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\npublic operator fun OpenEndRange<Int>.contains(value: Long): Boolean {\n    return value.toIntExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\npublic operator fun OpenEndRange<Byte>.contains(value: Long): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\npublic operator fun OpenEndRange<Short>.contains(value: Long): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntRange.contains(value: Long): Boolean {\n    return (this as ClosedRange<Int>).contains(value)\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Short): Boolean {\n    return contains(value.toInt())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Short): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Short): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Short): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Short): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\npublic operator fun OpenEndRange<Int>.contains(value: Short): Boolean {\n    return contains(value.toInt())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\npublic operator fun OpenEndRange<Long>.contains(value: Short): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\npublic operator fun OpenEndRange<Byte>.contains(value: Short): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntRange.contains(value: Short): Boolean {\n    return (this as ClosedRange<Int>).contains(value)\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongRange.contains(value: Short): Boolean {\n    return (this as ClosedRange<Long>).contains(value)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Byte): IntProgression {\n    return IntProgression.fromClosedRange(this, to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Byte): LongProgression {\n    return LongProgression.fromClosedRange(this, to.toLong(), -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Byte): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Byte): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Char.downTo(to: Char): CharProgression {\n    return CharProgression.fromClosedRange(this, to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Int): IntProgression {\n    return IntProgression.fromClosedRange(this, to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Int): LongProgression {\n    return LongProgression.fromClosedRange(this, to.toLong(), -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Int): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Int): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this.toLong(), to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this, to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this.toLong(), to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this.toLong(), to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Short): IntProgression {\n    return IntProgression.fromClosedRange(this, to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Short): LongProgression {\n    return LongProgression.fromClosedRange(this, to.toLong(), -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Short): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Short): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline operator fun Int.rangeUntil(to: Byte): IntRange {\n    return until(to)\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline operator fun Long.rangeUntil(to: Byte): LongRange {\n    return until(to)\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline operator fun Byte.rangeUntil(to: Byte): IntRange {\n    return until(to)\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline operator fun Short.rangeUntil(to: Byte): IntRange {\n    return until(to)\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline operator fun Char.rangeUntil(to: Char): CharRange {\n    return until(to)\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline operator fun Int.rangeUntil(to: Int): IntRange {\n    return until(to)\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline operator fun Long.rangeUntil(to: Int): LongRange {\n    return until(to)\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline operator fun Byte.rangeUntil(to: Int): IntRange {\n    return until(to)\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline operator fun Short.rangeUntil(to: Int): IntRange {\n    return until(to)\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline operator fun Int.rangeUntil(to: Long): LongRange {\n    return until(to)\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline operator fun Long.rangeUntil(to: Long): LongRange {\n    return until(to)\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline operator fun Byte.rangeUntil(to: Long): LongRange {\n    return until(to)\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline operator fun Short.rangeUntil(to: Long): LongRange {\n    return until(to)\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline operator fun Int.rangeUntil(to: Short): IntRange {\n    return until(to)\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline operator fun Long.rangeUntil(to: Short): LongRange {\n    return until(to)\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline operator fun Byte.rangeUntil(to: Short): IntRange {\n    return until(to)\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline operator fun Short.rangeUntil(to: Short): IntRange {\n    return until(to)\n}\n\n/**\n * Returns a progression that goes over the same range in the opposite direction with the same step.\n */\npublic fun IntProgression.reversed(): IntProgression {\n    return IntProgression.fromClosedRange(last, first, -step)\n}\n\n/**\n * Returns a progression that goes over the same range in the opposite direction with the same step.\n */\npublic fun LongProgression.reversed(): LongProgression {\n    return LongProgression.fromClosedRange(last, first, -step)\n}\n\n/**\n * Returns a progression that goes over the same range in the opposite direction with the same step.\n */\npublic fun CharProgression.reversed(): CharProgression {\n    return CharProgression.fromClosedRange(last, first, -step)\n}\n\n/**\n * Returns a progression that goes over the same range with the given step.\n */\npublic infix fun IntProgression.step(step: Int): IntProgression {\n    checkStepIsPositive(step > 0, step)\n    return IntProgression.fromClosedRange(first, last, if (this.step > 0) step else -step)\n}\n\n/**\n * Returns a progression that goes over the same range with the given step.\n */\npublic infix fun LongProgression.step(step: Long): LongProgression {\n    checkStepIsPositive(step > 0, step)\n    return LongProgression.fromClosedRange(first, last, if (this.step > 0) step else -step)\n}\n\n/**\n * Returns a progression that goes over the same range with the given step.\n */\npublic infix fun CharProgression.step(step: Int): CharProgression {\n    checkStepIsPositive(step > 0, step)\n    return CharProgression.fromClosedRange(first, last, if (this.step > 0) step else -step)\n}\n\ninternal fun Int.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toInt()..Byte.MAX_VALUE.toInt()) this.toByte() else null\n}\n\ninternal fun Long.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toLong()..Byte.MAX_VALUE.toLong()) this.toByte() else null\n}\n\ninternal fun Short.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toShort()..Byte.MAX_VALUE.toShort()) this.toByte() else null\n}\n\ninternal fun Double.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toDouble()..Byte.MAX_VALUE.toDouble()) this.toInt().toByte() else null\n}\n\ninternal fun Float.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toFloat()..Byte.MAX_VALUE.toFloat()) this.toInt().toByte() else null\n}\n\ninternal fun Long.toIntExactOrNull(): Int? {\n    return if (this in Int.MIN_VALUE.toLong()..Int.MAX_VALUE.toLong()) this.toInt() else null\n}\n\ninternal fun Double.toIntExactOrNull(): Int? {\n    return if (this in Int.MIN_VALUE.toDouble()..Int.MAX_VALUE.toDouble()) this.toInt() else null\n}\n\ninternal fun Float.toIntExactOrNull(): Int? {\n    return if (this in Int.MIN_VALUE.toFloat()..Int.MAX_VALUE.toFloat()) this.toInt() else null\n}\n\ninternal fun Double.toLongExactOrNull(): Long? {\n    return if (this in Long.MIN_VALUE.toDouble()..Long.MAX_VALUE.toDouble()) this.toLong() else null\n}\n\ninternal fun Float.toLongExactOrNull(): Long? {\n    return if (this in Long.MIN_VALUE.toFloat()..Long.MAX_VALUE.toFloat()) this.toLong() else null\n}\n\ninternal fun Int.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toInt()..Short.MAX_VALUE.toInt()) this.toShort() else null\n}\n\ninternal fun Long.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toLong()..Short.MAX_VALUE.toLong()) this.toShort() else null\n}\n\ninternal fun Double.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toDouble()..Short.MAX_VALUE.toDouble()) this.toInt().toShort() else null\n}\n\ninternal fun Float.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toFloat()..Short.MAX_VALUE.toFloat()) this.toInt().toShort() else null\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Byte): IntRange {\n    return this .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Byte): LongRange {\n    return this .. (to.toLong() - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Byte): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Byte): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Char.until(to: Char): CharRange {\n    if (to <= '\\u0000') return CharRange.EMPTY\n    return this .. (to - 1).toChar()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Int): IntRange {\n    if (to <= Int.MIN_VALUE) return IntRange.EMPTY\n    return this .. (to - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Int): LongRange {\n    return this .. (to.toLong() - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Int): IntRange {\n    if (to <= Int.MIN_VALUE) return IntRange.EMPTY\n    return this.toInt() .. (to - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Int): IntRange {\n    if (to <= Int.MIN_VALUE) return IntRange.EMPTY\n    return this.toInt() .. (to - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this.toLong() .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this.toLong() .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this.toLong() .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Short): IntRange {\n    return this .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Short): LongRange {\n    return this .. (to.toLong() - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Short): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Short): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeastComparable\n */\npublic fun <T : Comparable<T>> T.coerceAtLeast(minimumValue: T): T {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Byte.coerceAtLeast(minimumValue: Byte): Byte {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Short.coerceAtLeast(minimumValue: Short): Short {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Int.coerceAtLeast(minimumValue: Int): Int {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Long.coerceAtLeast(minimumValue: Long): Long {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Float.coerceAtLeast(minimumValue: Float): Float {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Double.coerceAtLeast(minimumValue: Double): Double {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMostComparable\n */\npublic fun <T : Comparable<T>> T.coerceAtMost(maximumValue: T): T {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Byte.coerceAtMost(maximumValue: Byte): Byte {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Short.coerceAtMost(maximumValue: Short): Short {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Int.coerceAtMost(maximumValue: Int): Int {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Long.coerceAtMost(maximumValue: Long): Long {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Float.coerceAtMost(maximumValue: Float): Float {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Double.coerceAtMost(maximumValue: Double): Double {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceInComparable\n */\npublic fun <T : Comparable<T>> T.coerceIn(minimumValue: T?, maximumValue: T?): T {\n    if (minimumValue !== null && maximumValue !== null) {\n        if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n        if (this < minimumValue) return minimumValue\n        if (this > maximumValue) return maximumValue\n    }\n    else {\n        if (minimumValue !== null && this < minimumValue) return minimumValue\n        if (maximumValue !== null && this > maximumValue) return maximumValue\n    }\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Byte.coerceIn(minimumValue: Byte, maximumValue: Byte): Byte {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Short.coerceIn(minimumValue: Short, maximumValue: Short): Short {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Int.coerceIn(minimumValue: Int, maximumValue: Int): Int {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Long.coerceIn(minimumValue: Long, maximumValue: Long): Long {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Float.coerceIn(minimumValue: Float, maximumValue: Float): Float {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Double.coerceIn(minimumValue: Double, maximumValue: Double): Double {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceInFloatingPointRange\n */\n@SinceKotlin(\"1.1\")\npublic fun <T : Comparable<T>> T.coerceIn(range: ClosedFloatingPointRange<T>): T {\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        // this < start equiv to this <= start && !(this >= start)\n        range.lessThanOrEquals(this, range.start) && !range.lessThanOrEquals(range.start, this) -> range.start\n        // this > end equiv to this >= end && !(this <= end)\n        range.lessThanOrEquals(range.endInclusive, this) && !range.lessThanOrEquals(this, range.endInclusive) -> range.endInclusive\n        else -> this\n    }\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceInComparable\n */\npublic fun <T : Comparable<T>> T.coerceIn(range: ClosedRange<T>): T {\n    if (range is ClosedFloatingPointRange) {\n        return this.coerceIn<T>(range)\n    }\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        this < range.start -> range.start\n        this > range.endInclusive -> range.endInclusive\n        else -> this\n    }\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Int.coerceIn(range: ClosedRange<Int>): Int {\n    if (range is ClosedFloatingPointRange) {\n        return this.coerceIn<Int>(range)\n    }\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        this < range.start -> range.start\n        this > range.endInclusive -> range.endInclusive\n        else -> this\n    }\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Long.coerceIn(range: ClosedRange<Long>): Long {\n    if (range is ClosedFloatingPointRange) {\n        return this.coerceIn<Long>(range)\n    }\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        this < range.start -> range.start\n        this > range.endInclusive -> range.endInclusive\n        else -> this\n    }\n}\n\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\nimport kotlin.jvm.*\n\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@JvmInline\npublic value class UByte @kotlin.internal.IntrinsicConstEvaluation @PublishedApi internal constructor(@PublishedApi internal val data: Byte) : Comparable<UByte> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UByte can have.\n         */\n        public const val MIN_VALUE: UByte = UByte(0)\n\n        /**\n         * A constant holding the maximum value an instance of UByte can have.\n         */\n        public const val MAX_VALUE: UByte = UByte(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UByte in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 1\n\n        /**\n         * The number of bits used to represent an instance of UByte in a binary form.\n         */\n        public const val SIZE_BITS: Int = 8\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UByte): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.toUInt().compareTo(other)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = this.toUInt().plus(other)\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = this.toUInt().minus(other)\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = this.toUInt().times(other)\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = this.toUInt().div(other)\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.toUInt().rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.toUInt().rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = this.toUInt().rem(other)\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UByte): UInt = this.toUInt().floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UShort): UInt = this.toUInt().floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UInt): UInt = this.toUInt().floorDiv(other)\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: ULong): ULong = this.toULong().floorDiv(other)\n\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UByte): UByte = this.toUInt().mod(other.toUInt()).toUByte()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UShort): UShort = this.toUInt().mod(other.toUInt()).toUShort()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UInt): UInt = this.toUInt().mod(other)\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: ULong): ULong = this.toULong().mod(other)\n\n    /**\n     * Returns this value incremented by one.\n     *\n     * @sample samples.misc.Builtins.inc\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UByte = UByte(data.inc())\n\n    /**\n     * Returns this value decremented by one.\n     *\n     * @sample samples.misc.Builtins.dec\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UByte = UByte(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UByte): UIntRange = UIntRange(this.toUInt(), other.toUInt())\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UByte): UByte = UByte(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UByte): UByte = UByte(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UByte): UByte = UByte(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UByte = UByte(data.inv())\n\n    /**\n     * Converts this [UByte] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UByte`. Otherwise the result is negative.\n     *\n     * The resulting `Byte` value has the same binary representation as this `UByte` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data\n    /**\n     * Converts this [UByte] value to [Short].\n     *\n     * The resulting `Short` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Short` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 8 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort() and 0xFF\n    /**\n     * Converts this [UByte] value to [Int].\n     *\n     * The resulting `Int` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Int` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 24 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt() and 0xFF\n    /**\n     * Converts this [UByte] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Long` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 56 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFF\n\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = this\n    /**\n     * Converts this [UByte] value to [UShort].\n     *\n     * The resulting `UShort` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `UShort` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 8 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = UShort(data.toShort() and 0xFF)\n    /**\n     * Converts this [UByte] value to [UInt].\n     *\n     * The resulting `UInt` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `UInt` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 24 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = UInt(data.toInt() and 0xFF)\n    /**\n     * Converts this [UByte] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `ULong` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 56 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFF)\n\n    /**\n     * Converts this [UByte] value to [Float].\n     *\n     * The resulting `Float` value represents the same numerical value as this `UByte`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toInt().toFloat()\n    /**\n     * Converts this [UByte] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UByte`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = this.toInt().toDouble()\n\n    public override fun toString(): String = toInt().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UByte].\n *\n * If this value is positive, the resulting `UByte` value represents the same numerical value as this `Byte`.\n *\n * The resulting `UByte` value has the same binary representation as this `Byte` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUByte(): UByte = UByte(this)\n/**\n * Converts this [Short] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Short`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Short` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUByte(): UByte = UByte(this.toByte())\n/**\n * Converts this [Int] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Int`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Int` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUByte(): UByte = UByte(this.toByte())\n/**\n * Converts this [Long] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Long` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUByte(): UByte = UByte(this.toByte())\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\nimport kotlin.jvm.*\n\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@JvmInline\npublic value class UInt @kotlin.internal.IntrinsicConstEvaluation @PublishedApi internal constructor(@PublishedApi internal val data: Int) : Comparable<UInt> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UInt can have.\n         */\n        public const val MIN_VALUE: UInt = UInt(0)\n\n        /**\n         * A constant holding the maximum value an instance of UInt can have.\n         */\n        public const val MAX_VALUE: UInt = UInt(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UInt in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 4\n\n        /**\n         * The number of bits used to represent an instance of UInt in a binary form.\n         */\n        public const val SIZE_BITS: Int = 32\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.compareTo(other.toUInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.compareTo(other.toUInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UInt): Int = uintCompare(this.data, other.data)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = UInt(this.data.plus(other.data))\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = UInt(this.data.minus(other.data))\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = UInt(this.data.times(other.data))\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = uintDivide(this, other)\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = uintRemainder(this, other)\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UByte): UInt = this.floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UShort): UInt = this.floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UInt): UInt = div(other)\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: ULong): ULong = this.toULong().floorDiv(other)\n\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UByte): UByte = this.mod(other.toUInt()).toUByte()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UShort): UShort = this.mod(other.toUInt()).toUShort()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UInt): UInt = rem(other)\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: ULong): ULong = this.toULong().mod(other)\n\n    /**\n     * Returns this value incremented by one.\n     *\n     * @sample samples.misc.Builtins.inc\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UInt = UInt(data.inc())\n\n    /**\n     * Returns this value decremented by one.\n     *\n     * @sample samples.misc.Builtins.dec\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UInt = UInt(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UInt): UIntRange = UIntRange(this, other)\n\n    /**\n     * Shifts this value left by the [bitCount] number of bits.\n     *\n     * Note that only the five lowest-order bits of the [bitCount] are used as the shift distance.\n     * The shift distance actually used is therefore always in the range `0..31`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shl(bitCount: Int): UInt = UInt(data shl bitCount)\n\n    /**\n     * Shifts this value right by the [bitCount] number of bits, filling the leftmost bits with zeros.\n     *\n     * Note that only the five lowest-order bits of the [bitCount] are used as the shift distance.\n     * The shift distance actually used is therefore always in the range `0..31`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shr(bitCount: Int): UInt = UInt(data ushr bitCount)\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UInt): UInt = UInt(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UInt): UInt = UInt(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UInt): UInt = UInt(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UInt = UInt(data.inv())\n\n    /**\n     * Converts this [UInt] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `UInt` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [UInt] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `Short` value is represented by the least significant 16 bits of this `UInt` value.\n     * Note that the resulting `Short` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort()\n    /**\n     * Converts this [UInt] value to [Int].\n     *\n     * If this value is less than or equals to [Int.MAX_VALUE], the resulting `Int` value represents\n     * the same numerical value as this `UInt`. Otherwise the result is negative.\n     *\n     * The resulting `Int` value has the same binary representation as this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data\n    /**\n     * Converts this [UInt] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UInt`.\n     *\n     * The least significant 32 bits of the resulting `Long` value are the same as the bits of this `UInt` value,\n     * whereas the most significant 32 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFFFF_FFFF\n\n    /**\n     * Converts this [UInt] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /**\n     * Converts this [UInt] value to [UShort].\n     *\n     * If this value is less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `UShort` value is represented by the least significant 16 bits of this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = data.toUShort()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = this\n    /**\n     * Converts this [UInt] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UInt`.\n     *\n     * The least significant 32 bits of the resulting `ULong` value are the same as the bits of this `UInt` value,\n     * whereas the most significant 32 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFFFF_FFFF)\n\n    /**\n     * Converts this [UInt] value to [Float].\n     *\n     * The resulting value is the closest `Float` to this `UInt` value.\n     * In case when this `UInt` value is exactly between two `Float`s,\n     * the one with zero at least significant bit of mantissa is selected.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toDouble().toFloat()\n    /**\n     * Converts this [UInt] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UInt`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = uintToDouble(data)\n\n    public override fun toString(): String = toLong().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `UInt` value are the same as the bits of this `Byte` value,\n * whereas the most significant 24 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUInt(): UInt = UInt(this.toInt())\n/**\n * Converts this [Short] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Short`.\n *\n * The least significant 16 bits of the resulting `UInt` value are the same as the bits of this `Short` value,\n * whereas the most significant 16 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUInt(): UInt = UInt(this.toInt())\n/**\n * Converts this [Int] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Int`.\n *\n * The resulting `UInt` value has the same binary representation as this `Int` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUInt(): UInt = UInt(this)\n/**\n * Converts this [Long] value to [UInt].\n *\n * If this value is positive and less than or equals to [UInt.MAX_VALUE], the resulting `UInt` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UInt` value is represented by the least significant 32 bits of this `Long` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUInt(): UInt = UInt(this.toInt())\n\n/**\n * Converts this [Float] value to [UInt].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Float` value is negative or `NaN`, [UInt.MAX_VALUE] if it's bigger than `UInt.MAX_VALUE`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Float.toUInt(): UInt = doubleToUInt(this.toDouble())\n/**\n * Converts this [Double] value to [UInt].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Double` value is negative or `NaN`, [UInt.MAX_VALUE] if it's bigger than `UInt.MAX_VALUE`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Double.toUInt(): UInt = doubleToUInt(this)\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\nimport kotlin.jvm.*\n\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@JvmInline\npublic value class UShort @kotlin.internal.IntrinsicConstEvaluation @PublishedApi internal constructor(@PublishedApi internal val data: Short) : Comparable<UShort> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UShort can have.\n         */\n        public const val MIN_VALUE: UShort = UShort(0)\n\n        /**\n         * A constant holding the maximum value an instance of UShort can have.\n         */\n        public const val MAX_VALUE: UShort = UShort(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UShort in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 2\n\n        /**\n         * The number of bits used to represent an instance of UShort in a binary form.\n         */\n        public const val SIZE_BITS: Int = 16\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UShort): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.toUInt().compareTo(other)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = this.toUInt().plus(other)\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = this.toUInt().minus(other)\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = this.toUInt().times(other)\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = this.toUInt().div(other)\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.toUInt().rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.toUInt().rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = this.toUInt().rem(other)\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UByte): UInt = this.toUInt().floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UShort): UInt = this.toUInt().floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UInt): UInt = this.toUInt().floorDiv(other)\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: ULong): ULong = this.toULong().floorDiv(other)\n\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UByte): UByte = this.toUInt().mod(other.toUInt()).toUByte()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UShort): UShort = this.toUInt().mod(other.toUInt()).toUShort()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UInt): UInt = this.toUInt().mod(other)\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: ULong): ULong = this.toULong().mod(other)\n\n    /**\n     * Returns this value incremented by one.\n     *\n     * @sample samples.misc.Builtins.inc\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UShort = UShort(data.inc())\n\n    /**\n     * Returns this value decremented by one.\n     *\n     * @sample samples.misc.Builtins.dec\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UShort = UShort(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UShort): UIntRange = UIntRange(this.toUInt(), other.toUInt())\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UShort): UShort = UShort(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UShort): UShort = UShort(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UShort): UShort = UShort(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UShort = UShort(data.inv())\n\n    /**\n     * Converts this [UShort] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UShort`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `UShort` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [UShort] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `UShort`. Otherwise the result is negative.\n     *\n     * The resulting `Short` value has the same binary representation as this `UShort` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data\n    /**\n     * Converts this [UShort] value to [Int].\n     *\n     * The resulting `Int` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `Int` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 16 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt() and 0xFFFF\n    /**\n     * Converts this [UShort] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `Long` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 48 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFFFF\n\n    /**\n     * Converts this [UShort] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `UShort`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `UShort` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = this\n    /**\n     * Converts this [UShort] value to [UInt].\n     *\n     * The resulting `UInt` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `UInt` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 16 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = UInt(data.toInt() and 0xFFFF)\n    /**\n     * Converts this [UShort] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `ULong` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 48 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFFFF)\n\n    /**\n     * Converts this [UShort] value to [Float].\n     *\n     * The resulting `Float` value represents the same numerical value as this `UShort`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toInt().toFloat()\n    /**\n     * Converts this [UShort] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UShort`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = this.toInt().toDouble()\n\n    public override fun toString(): String = toInt().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UShort].\n *\n * If this value is positive, the resulting `UShort` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `UShort` value are the same as the bits of this `Byte` value,\n * whereas the most significant 8 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUShort(): UShort = UShort(this.toShort())\n/**\n * Converts this [Short] value to [UShort].\n *\n * If this value is positive, the resulting `UShort` value represents the same numerical value as this `Short`.\n *\n * The resulting `UShort` value has the same binary representation as this `Short` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUShort(): UShort = UShort(this)\n/**\n * Converts this [Int] value to [UShort].\n *\n * If this value is positive and less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n * the same numerical value as this `Int`.\n *\n * The resulting `UShort` value is represented by the least significant 16 bits of this `Int` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUShort(): UShort = UShort(this.toShort())\n/**\n * Converts this [Long] value to [UShort].\n *\n * If this value is positive and less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UShort` value is represented by the least significant 16 bits of this `Long` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUShort(): UShort = UShort(this.toShort())\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\nimport kotlin.random.Random\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * The returned list is serializable (JVM).\n *\n * @sample samples.collections.Builders.Lists.buildListSample\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION\")\npublic inline fun <E> buildList(@BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildListInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildListInternal(builderAction: MutableList<E>.() -> Unit): List<E>\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * The returned list is serializable (JVM).\n *\n * [capacity] is used to hint the expected number of elements added in the [builderAction].\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Lists.buildListSampleWithCapacity\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION\")\npublic inline fun <E> buildList(capacity: Int, @BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildListInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildListInternal(capacity: Int, builderAction: MutableList<E>.() -> Unit): List<E>\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable collection is either null or empty.\n * @sample samples.collections.Collections.Collections.collectionIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.isEmpty()\n}\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Returns this collection if it's not empty\n * or the result of calling [defaultValue] function if the collection is empty.\n *\n * @sample samples.collections.Collections.Collections.collectionIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : Collection<*>, C : R =\n    if (isEmpty()) defaultValue() else this\n\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\n\n/**\n * Returns a new list with the elements of this list randomly shuffled\n * using the specified [random] instance as the source of randomness.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Iterable<T>.shuffled(random: Random): List<T> = toMutableList().apply { shuffle(random) }\n\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which the given [comparison] function returns zero using the binary search algorithm.\n *\n * The list is expected to be sorted so that the signs of the [comparison] function's return values ascend on the list elements,\n * i.e. negative values come before zero and zeroes come before positive values.\n * Otherwise, the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that returns zero when called on the list element being searched.\n * On the elements coming before the target element, the function must return negative values;\n * on the elements coming after the target element, the function must return positive values.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkIndexOverflow(index: Int): Int\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkCountOverflow(count: Int): Int\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwIndexOverflow() { throw ArithmeticException(\"Index overflow has happened.\") }\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwCountOverflow() { throw ArithmeticException(\"Count overflow has happened.\") }\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\nprivate object EmptyMap : Map<Any?, Nothing>, Serializable {\n    private const val serialVersionUID: Long = 8246714829545688274\n\n    override fun equals(other: Any?): Boolean = other is Map<*, *> && other.isEmpty()\n    override fun hashCode(): Int = 0\n    override fun toString(): String = \"{}\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n\n    override fun containsKey(key: Any?): Boolean = false\n    override fun containsValue(value: Nothing): Boolean = false\n    override fun get(key: Any?): Nothing? = null\n    override val entries: Set<Map.Entry<Any?, Nothing>> get() = EmptySet\n    override val keys: Set<Any?> get() = EmptySet\n    override val values: Collection<Nothing> get() = EmptyList\n\n    private fun readResolve(): Any = EmptyMap\n}\n\n/**\n * Returns an empty read-only map of specified type.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\npublic fun <K, V> emptyMap(): Map<K, V> = @Suppress(\"UNCHECKED_CAST\") (EmptyMap as Map<K, V>)\n\n/**\n * Returns a new read-only map with the specified contents, given as a list of pairs\n * where the first value is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * The returned map is serializable (JVM).\n *\n * @sample samples.collections.Maps.Instantiation.mapFromPairs\n */\npublic fun <K, V> mapOf(vararg pairs: Pair<K, V>): Map<K, V> =\n    if (pairs.size > 0) pairs.toMap(LinkedHashMap(mapCapacity(pairs.size))) else emptyMap()\n\n/**\n * Returns an empty read-only map.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mapOf(): Map<K, V> = emptyMap()\n\n/**\n * Returns an empty new [MutableMap].\n *\n * The returned map preserves the entry iteration order.\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mutableMapOf(): MutableMap<K, V> = LinkedHashMap()\n\n/**\n * Returns a new [MutableMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.mutableMapFromPairs\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\npublic fun <K, V> mutableMapOf(vararg pairs: Pair<K, V>): MutableMap<K, V> =\n    LinkedHashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [HashMap].\n *\n * @sample samples.collections.Maps.Instantiation.emptyHashMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> hashMapOf(): HashMap<K, V> = HashMap<K, V>()\n\n/**\n * Returns a new [HashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * @sample samples.collections.Maps.Instantiation.hashMapFromPairs\n */\npublic fun <K, V> hashMapOf(vararg pairs: Pair<K, V>): HashMap<K, V> = HashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [LinkedHashMap].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> linkedMapOf(): LinkedHashMap<K, V> = LinkedHashMap<K, V>()\n\n/**\n * Returns a new [LinkedHashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.linkedMapFromPairs\n */\npublic fun <K, V> linkedMapOf(vararg pairs: Pair<K, V>): LinkedHashMap<K, V> = pairs.toMap(LinkedHashMap(mapCapacity(pairs.size)))\n\n/**\n * Builds a new read-only [Map] by populating a [MutableMap] using the given [builderAction]\n * and returning a read-only map with the same key-value pairs.\n *\n * The map passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * Entries of the map are iterated in the order they were added by the [builderAction].\n *\n * The returned map is serializable (JVM).\n *\n * @sample samples.collections.Builders.Maps.buildMapSample\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION\")\npublic inline fun <K, V> buildMap(@BuilderInference builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildMapInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal expect inline fun <K, V> buildMapInternal(builderAction: MutableMap<K, V>.() -> Unit): Map<K, V>\n\n/**\n * Builds a new read-only [Map] by populating a [MutableMap] using the given [builderAction]\n * and returning a read-only map with the same key-value pairs.\n *\n * The map passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of pairs added in the [builderAction].\n *\n * Entries of the map are iterated in the order they were added by the [builderAction].\n *\n * The returned map is serializable (JVM).\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Maps.buildMapSample\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION\")\npublic inline fun <K, V> buildMap(capacity: Int, @BuilderInference builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildMapInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal expect inline fun <K, V> buildMapInternal(capacity: Int, builderAction: MutableMap<K, V>.() -> Unit): Map<K, V>\n\n/**\n * Calculate the initial capacity of a map.\n */\n@PublishedApi\ninternal expect fun mapCapacity(expectedSize: Int): Int\n\n/**\n * Returns `true` if this map is not empty.\n * @sample samples.collections.Maps.Usage.mapIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable map is either null or empty.\n * @sample samples.collections.Maps.Usage.mapIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || isEmpty()\n}\n\n/**\n * Returns the [Map] if its not `null`, or the empty [Map] otherwise.\n *\n * @sample samples.collections.Maps.Usage.mapOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>?.orEmpty(): Map<K, V> = this ?: emptyMap()\n\n/**\n * Returns this map if it's not empty\n * or the result of calling [defaultValue] function if the map is empty.\n *\n * @sample samples.collections.Maps.Usage.mapIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <M, R> M.ifEmpty(defaultValue: () -> R): R where M : Map<*, *>, M : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Checks if the map contains the given key.\n *\n * This method allows to use the `x in map` syntax for checking whether an object is contained in the map.\n *\n * @sample samples.collections.Maps.Usage.containsKey\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.contains(key: K): Boolean = containsKey(key)\n\n/**\n * Returns the value corresponding to the given [key], or `null` if such a key is not present in the map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.get(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, V>).get(key)\n\n/**\n * Allows to use the index operator for storing values in a mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.set(key: K, value: V): Unit {\n    put(key, value)\n}\n\n/**\n * Returns `true` if the map contains the specified [key].\n *\n * Allows to overcome type-safety restriction of `containsKey` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K> Map<out K, *>.containsKey(key: K): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, *>).containsKey(key)\n\n/**\n * Returns `true` if the map maps one or more keys to the specified [value].\n *\n * Allows to overcome type-safety restriction of `containsValue` that requires to pass a value of type `V`.\n *\n * @sample samples.collections.Maps.Usage.containsValue\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <K, @kotlin.internal.OnlyInputTypes V> Map<K, V>.containsValue(value: V): Boolean = this.containsValue(value)\n\n\n/**\n * Removes the specified key and its corresponding value from this map.\n *\n * @return the previous value associated with the key, or `null` if the key was not present in the map.\n\n * Allows to overcome type-safety restriction of `remove` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K, V> MutableMap<out K, V>.remove(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableMap<K, V>).remove(key)\n\n/**\n * Returns the key component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component1(): K = key\n\n/**\n * Returns the value component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component2(): V = value\n\n/**\n * Converts entry to [Pair] with key being first component and value being second.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map.Entry<K, V>.toPair(): Pair<K, V> = Pair(key, value)\n\n/**\n * Returns the value for the given key, or the result of the [defaultValue] function if there was no entry for the given key.\n *\n * @sample samples.collections.Maps.Usage.getOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>.getOrElse(key: K, defaultValue: () -> V): V = get(key) ?: defaultValue()\n\n\ninternal inline fun <K, V> Map<K, V>.getOrElseNullable(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    if (value == null && !containsKey(key)) {\n        return defaultValue()\n    } else {\n        @Suppress(\"UNCHECKED_CAST\")\n        return value as V\n    }\n}\n\n/**\n * Returns the value for the given [key] or throws an exception if there is no such key in the map.\n *\n * If the map was created by [withDefault], resorts to its `defaultValue` provider function\n * instead of throwing an exception.\n *\n * @throws NoSuchElementException when the map doesn't contain a value for the specified key and\n * no implicit default value was provided for that map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<K, V>.getValue(key: K): V = getOrImplicitDefault(key)\n\n/**\n * Returns the value for the given key. If the key is not found in the map, calls the [defaultValue] function,\n * puts its result into the map under the given key and returns it.\n *\n * Note that the operation is not guaranteed to be atomic if the map is being modified concurrently.\n *\n * @sample samples.collections.Maps.Usage.getOrPut\n */\npublic inline fun <K, V> MutableMap<K, V>.getOrPut(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    return if (value == null) {\n        val answer = defaultValue()\n        put(key, answer)\n        answer\n    } else {\n        value\n    }\n}\n\n/**\n * Returns an [Iterator] over the entries in the [Map].\n *\n * @sample samples.collections.Maps.Usage.forOverEntries\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map<out K, V>.iterator(): Iterator<Map.Entry<K, V>> = entries.iterator()\n\n/**\n * Returns a [MutableIterator] over the mutable entries in the [MutableMap].\n *\n */\n@kotlin.jvm.JvmName(\"mutableIterator\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.iterator(): MutableIterator<MutableMap.MutableEntry<K, V>> = entries.iterator()\n\n/**\n * Populates the given [destination] map with entries having the keys of this map and the values obtained\n * by applying the [transform] function to each entry in this [Map].\n */\npublic inline fun <K, V, R, M : MutableMap<in K, in R>> Map<out K, V>.mapValuesTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, { it.key }, transform)\n}\n\n/**\n * Populates the given [destination] map with entries having the keys obtained\n * by applying the [transform] function to each entry in this [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n */\npublic inline fun <K, V, R, M : MutableMap<in R, in V>> Map<out K, V>.mapKeysTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, transform, { it.value })\n}\n\n/**\n * Puts all the given [pairs] into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Array<out Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given collection into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Iterable<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given sequence into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Sequence<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Returns a new map with entries having the keys of this map and the values obtained by applying the [transform]\n * function to each entry in this [Map].\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapValues\n */\npublic inline fun <K, V, R> Map<out K, V>.mapValues(transform: (Map.Entry<K, V>) -> R): Map<K, R> {\n    return mapValuesTo(LinkedHashMap<K, R>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a new Map with entries having the keys obtained by applying the [transform] function to each entry in this\n * [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapKeys\n */\npublic inline fun <K, V, R> Map<out K, V>.mapKeys(transform: (Map.Entry<K, V>) -> R): Map<R, V> {\n    return mapKeysTo(LinkedHashMap<R, V>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a map containing all key-value pairs with keys matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterKeys\n */\npublic inline fun <K, V> Map<out K, V>.filterKeys(predicate: (K) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.key)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n/**\n * Returns a map containing all key-value pairs with values matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n *  @sample samples.collections.Maps.Filtering.filterValues\n */\npublic inline fun <K, V> Map<out K, V>.filterValues(predicate: (V) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.value)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n\n/**\n * Appends all entries matching the given [predicate] into the mutable map given as [destination] parameter.\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filter\n */\npublic inline fun <K, V> Map<out K, V>.filter(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Appends all entries not matching the given [predicate] into the given [destination].\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterNotTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterNotTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (!predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs not matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterNot\n */\npublic inline fun <K, V> Map<out K, V>.filterNot(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterNotTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Returns a new map containing all key-value pairs from the given collection of pairs.\n *\n * The returned map preserves the entry iteration order of the original collection.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Iterable<Pair<K, V>>.toMap(): Map<K, V> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyMap()\n            1 -> mapOf(if (this is List) this[0] else iterator().next())\n            else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n        }\n    }\n    return toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given collection of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Iterable<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given array of pairs.\n *\n * The returned map preserves the entry iteration order of the original array.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Array<out Pair<K, V>>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> mapOf(this[0])\n    else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n}\n\n/**\n *  Populates and returns the [destination] mutable map with key-value pairs from the given array of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Array<out Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given sequence of pairs.\n *\n * The returned map preserves the entry iteration order of the original sequence.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Sequence<Pair<K, V>>.toMap(): Map<K, V> = toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given sequence of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Sequence<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new read-only map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMap()\n    else -> toMutableMap()\n}\n\n/**\n * Returns a new mutable map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMutableMap(): MutableMap<K, V> = LinkedHashMap(this)\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Creates a new read-only map by replacing or adding an entry to this map from a given key-value [pair].\n *\n * The returned map preserves the entry iteration order of the original map.\n * The [pair] is iterated in the end if it has a unique key.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pair: Pair<K, V>): Map<K, V> =\n    if (this.isEmpty()) mapOf(pair) else LinkedHashMap(this).apply { put(pair.first, pair.second) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given collection of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] collection.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Iterable<Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given array of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] array.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Array<out Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given sequence of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] sequence.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Sequence<Pair<K, V>>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(pairs) }.optimizeReadOnlyMap()\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from another [map].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those entries of another [map] that are missing in this map are iterated in the end in the order of that [map].\n */\npublic operator fun <K, V> Map<out K, V>.plus(map: Map<out K, V>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(map) }\n\n\n/**\n * Appends or replaces the given [pair] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pair: Pair<K, V>) {\n    put(pair.first, pair.second)\n}\n\n/**\n * Appends or replaces all pairs from the given collection of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Iterable<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given array of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Array<out Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given sequence of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Sequence<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all entries from the given [map] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(map: Map<K, V>) {\n    putAll(map)\n}\n\n/**\n * Returns a map containing all entries of the original map except the entry with the given [key].\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(key: K): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(key) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] collection.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Iterable<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] array.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Array<out K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] sequence.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Sequence<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Removes the entry with the given [key] from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(key: K) {\n    remove(key)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] collection from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Iterable<K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] array from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Array<out K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries from the keys of which are contained in the given [keys] sequence from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Sequence<K>) {\n    this.keys.removeAll(keys)\n}\n\n\n// do not expose for now @PublishedApi\ninternal fun <K, V> Map<K, V>.optimizeReadOnlyMap() = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMapOrSelf()\n    else -> this\n}\n","/*\n * Copyright 2010-2015 JetBrains s.r.o.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage kotlin\n\n/**\n * The type with only one value: the `Unit` object. This type corresponds to the `void` type in Java.\n */\npublic object Unit {\n    override fun toString() = \"kotlin.Unit\"\n}\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\n/**\n * A range of values of type `Char`.\n */\n@OptIn(ExperimentalStdlibApi::class)\npublic class CharRange(start: Char, endInclusive: Char) : CharProgression(start, endInclusive, 1), ClosedRange<Char>, OpenEndRange<Char> {\n    override val start: Char get() = first\n    override val endInclusive: Char get() = last\n    \n    @Deprecated(\"Can throw an exception when it's impossible to represent the value with Char type, for example, when the range includes MAX_VALUE. It's recommended to use 'endInclusive' property that doesn't throw.\")\n    @SinceKotlin(\"1.7\")\n    @ExperimentalStdlibApi\n    override val endExclusive: Char get() {\n        if (last == Char.MAX_VALUE) error(\"Cannot return the exclusive upper bound of a range that includes MAX_VALUE.\")\n        return last + 1\n    }\n\n    override fun contains(value: Char): Boolean = first <= value && value <= last\n\n    /** \n     * Checks whether the range is empty.\n     *\n     * The range is empty if its start value is greater than the end value.\n     */\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is CharRange && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * first.code + last.code)\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type Char. */\n        public val EMPTY: CharRange = CharRange(1.toChar(), 0.toChar())\n    }\n}\n\n/**\n * A range of values of type `Int`.\n */\n@OptIn(ExperimentalStdlibApi::class)\npublic class IntRange(start: Int, endInclusive: Int) : IntProgression(start, endInclusive, 1), ClosedRange<Int>, OpenEndRange<Int> {\n    override val start: Int get() = first\n    override val endInclusive: Int get() = last\n    \n    @Deprecated(\"Can throw an exception when it's impossible to represent the value with Int type, for example, when the range includes MAX_VALUE. It's recommended to use 'endInclusive' property that doesn't throw.\")\n    @SinceKotlin(\"1.7\")\n    @ExperimentalStdlibApi\n    override val endExclusive: Int get() {\n        if (last == Int.MAX_VALUE) error(\"Cannot return the exclusive upper bound of a range that includes MAX_VALUE.\")\n        return last + 1\n    }\n\n    override fun contains(value: Int): Boolean = first <= value && value <= last\n\n    /** \n     * Checks whether the range is empty.\n     *\n     * The range is empty if its start value is greater than the end value.\n     */\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is IntRange && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * first + last)\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type Int. */\n        public val EMPTY: IntRange = IntRange(1, 0)\n    }\n}\n\n/**\n * A range of values of type `Long`.\n */\n@OptIn(ExperimentalStdlibApi::class)\npublic class LongRange(start: Long, endInclusive: Long) : LongProgression(start, endInclusive, 1), ClosedRange<Long>, OpenEndRange<Long> {\n    override val start: Long get() = first\n    override val endInclusive: Long get() = last\n    \n    @Deprecated(\"Can throw an exception when it's impossible to represent the value with Long type, for example, when the range includes MAX_VALUE. It's recommended to use 'endInclusive' property that doesn't throw.\")\n    @SinceKotlin(\"1.7\")\n    @ExperimentalStdlibApi\n    override val endExclusive: Long get() {\n        if (last == Long.MAX_VALUE) error(\"Cannot return the exclusive upper bound of a range that includes MAX_VALUE.\")\n        return last + 1\n    }\n\n    override fun contains(value: Long): Boolean = first <= value && value <= last\n\n    /** \n     * Checks whether the range is empty.\n     *\n     * The range is empty if its start value is greater than the end value.\n     */\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is LongRange && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (first xor (first ushr 32)) + (last xor (last ushr 32))).toInt()\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type Long. */\n        public val EMPTY: LongRange = LongRange(1, 0)\n    }\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n@file:Suppress(\"PLATFORM_CLASS_MAPPED_TO_KOTLIN\")\n\npackage kotlin.text\n\n/**\n * Parses the string as a signed [Byte] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toByteOrNull(): Byte? = toByteOrNull(radix = 10)\n\n/**\n * Parses the string as a signed [Byte] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toByteOrNull(radix: Int): Byte? {\n    val int = this.toIntOrNull(radix) ?: return null\n    if (int < Byte.MIN_VALUE || int > Byte.MAX_VALUE) return null\n    return int.toByte()\n}\n\n/**\n * Parses the string as a [Short] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toShortOrNull(): Short? = toShortOrNull(radix = 10)\n\n/**\n * Parses the string as a [Short] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toShortOrNull(radix: Int): Short? {\n    val int = this.toIntOrNull(radix) ?: return null\n    if (int < Short.MIN_VALUE || int > Short.MAX_VALUE) return null\n    return int.toShort()\n}\n\n/**\n * Parses the string as an [Int] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toIntOrNull(): Int? = toIntOrNull(radix = 10)\n\n/**\n * Parses the string as an [Int] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toIntOrNull(radix: Int): Int? {\n    checkRadix(radix)\n\n    val length = this.length\n    if (length == 0) return null\n\n    val start: Int\n    val isNegative: Boolean\n    val limit: Int\n\n    val firstChar = this[0]\n    if (firstChar < '0') {  // Possible leading sign\n        if (length == 1) return null  // non-digit (possible sign) only, no digits after\n\n        start = 1\n\n        if (firstChar == '-') {\n            isNegative = true\n            limit = Int.MIN_VALUE\n        } else if (firstChar == '+') {\n            isNegative = false\n            limit = -Int.MAX_VALUE\n        } else\n            return null\n    } else {\n        start = 0\n        isNegative = false\n        limit = -Int.MAX_VALUE\n    }\n\n\n    val limitForMaxRadix = (-Int.MAX_VALUE) / 36\n\n    var limitBeforeMul = limitForMaxRadix\n    var result = 0\n    for (i in start until length) {\n        val digit = digitOf(this[i], radix)\n\n        if (digit < 0) return null\n        if (result < limitBeforeMul) {\n            if (limitBeforeMul == limitForMaxRadix) {\n                limitBeforeMul = limit / radix\n\n                if (result < limitBeforeMul) {\n                    return null\n                }\n            } else {\n                return null\n            }\n        }\n\n        result *= radix\n\n        if (result < limit + digit) return null\n\n        result -= digit\n    }\n\n    return if (isNegative) result else -result\n}\n\n/**\n * Parses the string as a [Long] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toLongOrNull(): Long? = toLongOrNull(radix = 10)\n\n/**\n * Parses the string as a [Long] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toLongOrNull(radix: Int): Long? {\n    checkRadix(radix)\n\n    val length = this.length\n    if (length == 0) return null\n\n    val start: Int\n    val isNegative: Boolean\n    val limit: Long\n\n    val firstChar = this[0]\n    if (firstChar < '0') {  // Possible leading sign\n        if (length == 1) return null  // non-digit (possible sign) only, no digits after\n\n        start = 1\n\n        if (firstChar == '-') {\n            isNegative = true\n            limit = Long.MIN_VALUE\n        } else if (firstChar == '+') {\n            isNegative = false\n            limit = -Long.MAX_VALUE\n        } else\n            return null\n    } else {\n        start = 0\n        isNegative = false\n        limit = -Long.MAX_VALUE\n    }\n\n\n    val limitForMaxRadix = (-Long.MAX_VALUE) / 36\n\n    var limitBeforeMul = limitForMaxRadix\n    var result = 0L\n    for (i in start until length) {\n        val digit = digitOf(this[i], radix)\n\n        if (digit < 0) return null\n        if (result < limitBeforeMul) {\n            if (limitBeforeMul == limitForMaxRadix) {\n                limitBeforeMul = limit / radix\n\n                if (result < limitBeforeMul) {\n                    return null\n                }\n            } else {\n                return null\n            }\n        }\n\n        result *= radix\n\n        if (result < limit + digit) return null\n\n        result -= digit\n    }\n\n    return if (isNegative) result else -result\n}\n\n\ninternal fun numberFormatError(input: String): Nothing = throw NumberFormatException(\"Invalid number format: '$input'\")\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.time\n\nimport kotlin.contracts.*\nimport kotlin.jvm.JvmInline\nimport kotlin.math.*\n\n/**\n * Represents the amount of time one instant of time is away from another instant.\n *\n * A negative duration is possible in a situation when the second instant is earlier than the first one.\n *\n * The type can store duration values up to ±146 years with nanosecond precision,\n * and up to ±146 million years with millisecond precision.\n * If a duration-returning operation provided in `kotlin.time` produces a duration value that doesn't fit into the above range,\n * the returned `Duration` is infinite.\n *\n * An infinite duration value [Duration.INFINITE] can be used to represent infinite timeouts.\n *\n * To construct a duration use either the extension function [toDuration],\n * or the extension properties [hours], [minutes], [seconds], and so on,\n * available on [Int], [Long], and [Double] numeric types.\n *\n * To get the value of this duration expressed in a particular [duration units][DurationUnit]\n * use the functions [toInt], [toLong], and [toDouble]\n * or the properties [inWholeHours], [inWholeMinutes], [inWholeSeconds], [inWholeNanoseconds], and so on.\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalTime::class)\n@JvmInline\npublic value class Duration internal constructor(private val rawValue: Long) : Comparable<Duration> {\n\n    private val value: Long get() = rawValue shr 1\n    private inline val unitDiscriminator: Int get() = rawValue.toInt() and 1\n    private fun isInNanos() = unitDiscriminator == 0\n    private fun isInMillis() = unitDiscriminator == 1\n    private val storageUnit get() = if (isInNanos()) DurationUnit.NANOSECONDS else DurationUnit.MILLISECONDS\n\n    init {\n        if (durationAssertionsEnabled) {\n            if (isInNanos()) {\n                if (value !in -MAX_NANOS..MAX_NANOS) throw AssertionError(\"$value ns is out of nanoseconds range\")\n            } else {\n                if (value !in -MAX_MILLIS..MAX_MILLIS) throw AssertionError(\"$value ms is out of milliseconds range\")\n                if (value in -MAX_NANOS_IN_MILLIS..MAX_NANOS_IN_MILLIS) throw AssertionError(\"$value ms is denormalized\")\n            }\n        }\n    }\n\n    companion object {\n        /** The duration equal to exactly 0 seconds. */\n        public val ZERO: Duration = Duration(0L)\n\n        /** The duration whose value is positive infinity. It is useful for representing timeouts that should never expire. */\n        public val INFINITE: Duration = durationOfMillis(MAX_MILLIS)\n        internal val NEG_INFINITE: Duration = durationOfMillis(-MAX_MILLIS)\n\n        /** Converts the given time duration [value] expressed in the specified [sourceUnit] into the specified [targetUnit]. */\n        @ExperimentalTime\n        public fun convert(value: Double, sourceUnit: DurationUnit, targetUnit: DurationUnit): Double =\n            convertDurationUnit(value, sourceUnit, targetUnit)\n\n        // Duration construction extension properties in Duration companion scope\n\n        /** Returns a [Duration] equal to this [Int] number of nanoseconds. */\n        @kotlin.internal.InlineOnly\n        public inline val Int.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n        /** Returns a [Duration] equal to this [Long] number of nanoseconds. */\n        @kotlin.internal.InlineOnly\n        public inline val Long.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n        /**\n         * Returns a [Duration] equal to this [Double] number of nanoseconds.\n         *\n         * Depending on its magnitude, the value is rounded to an integer number of nanoseconds or milliseconds.\n         *\n         * @throws IllegalArgumentException if this [Double] value is `NaN`.\n         */\n        @kotlin.internal.InlineOnly\n        public inline val Double.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n\n        /** Returns a [Duration] equal to this [Int] number of microseconds. */\n        @kotlin.internal.InlineOnly\n        public inline val Int.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n        /** Returns a [Duration] equal to this [Long] number of microseconds. */\n        @kotlin.internal.InlineOnly\n        public inline val Long.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n        /**\n         * Returns a [Duration] equal to this [Double] number of microseconds.\n         *\n         * Depending on its magnitude, the value is rounded to an integer number of nanoseconds or milliseconds.\n         *\n         * @throws IllegalArgumentException if this [Double] value is `NaN`.\n         */\n        @kotlin.internal.InlineOnly\n        public inline val Double.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n\n        /** Returns a [Duration] equal to this [Int] number of milliseconds. */\n        @kotlin.internal.InlineOnly\n        public inline val Int.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n        /** Returns a [Duration] equal to this [Long] number of milliseconds. */\n        @kotlin.internal.InlineOnly\n        public inline val Long.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n        /**\n         * Returns a [Duration] equal to this [Double] number of milliseconds.\n         *\n         * Depending on its magnitude, the value is rounded to an integer number of nanoseconds or milliseconds.\n         *\n         * @throws IllegalArgumentException if this [Double] value is `NaN`.\n         */\n        @kotlin.internal.InlineOnly\n        public inline val Double.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n\n        /** Returns a [Duration] equal to this [Int] number of seconds. */\n        @kotlin.internal.InlineOnly\n        public inline val Int.seconds get() = toDuration(DurationUnit.SECONDS)\n\n        /** Returns a [Duration] equal to this [Long] number of seconds. */\n        @kotlin.internal.InlineOnly\n        public inline val Long.seconds get() = toDuration(DurationUnit.SECONDS)\n\n        /**\n         * Returns a [Duration] equal to this [Double] number of seconds.\n         *\n         * Depending on its magnitude, the value is rounded to an integer number of nanoseconds or milliseconds.\n         *\n         * @throws IllegalArgumentException if this [Double] value is `NaN`.\n         */\n        @kotlin.internal.InlineOnly\n        public inline val Double.seconds get() = toDuration(DurationUnit.SECONDS)\n\n\n        /** Returns a [Duration] equal to this [Int] number of minutes. */\n        @kotlin.internal.InlineOnly\n        public inline val Int.minutes get() = toDuration(DurationUnit.MINUTES)\n\n        /** Returns a [Duration] equal to this [Long] number of minutes. */\n        @kotlin.internal.InlineOnly\n        public inline val Long.minutes get() = toDuration(DurationUnit.MINUTES)\n\n        /**\n         * Returns a [Duration] equal to this [Double] number of minutes.\n         *\n         * Depending on its magnitude, the value is rounded to an integer number of nanoseconds or milliseconds.\n         *\n         * @throws IllegalArgumentException if this [Double] value is `NaN`.\n         */\n        @kotlin.internal.InlineOnly\n        public inline val Double.minutes get() = toDuration(DurationUnit.MINUTES)\n\n\n        /** Returns a [Duration] equal to this [Int] number of hours. */\n        @kotlin.internal.InlineOnly\n        public inline val Int.hours get() = toDuration(DurationUnit.HOURS)\n\n        /** Returns a [Duration] equal to this [Long] number of hours. */\n        @kotlin.internal.InlineOnly\n        public inline val Long.hours get() = toDuration(DurationUnit.HOURS)\n\n        /**\n         * Returns a [Duration] equal to this [Double] number of hours.\n         *\n         * Depending on its magnitude, the value is rounded to an integer number of nanoseconds or milliseconds.\n         *\n         * @throws IllegalArgumentException if this [Double] value is `NaN`.\n         */\n        @kotlin.internal.InlineOnly\n        public inline val Double.hours get() = toDuration(DurationUnit.HOURS)\n\n\n        /** Returns a [Duration] equal to this [Int] number of days. */\n        @kotlin.internal.InlineOnly\n        public inline val Int.days get() = toDuration(DurationUnit.DAYS)\n\n        /** Returns a [Duration] equal to this [Long] number of days. */\n        @kotlin.internal.InlineOnly\n        public inline val Long.days get() = toDuration(DurationUnit.DAYS)\n\n        /**\n         * Returns a [Duration] equal to this [Double] number of days.\n         *\n         * Depending on its magnitude, the value is rounded to an integer number of nanoseconds or milliseconds.\n         *\n         * @throws IllegalArgumentException if this [Double] value is `NaN`.\n         */\n        @kotlin.internal.InlineOnly\n        public inline val Double.days get() = toDuration(DurationUnit.DAYS)\n\n\n        // deprecated static factory functions\n\n        /** Returns a [Duration] representing the specified [value] number of nanoseconds. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Int.nanoseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.nanoseconds\", \"kotlin.time.Duration.Companion.nanoseconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun nanoseconds(value: Int): Duration = value.toDuration(DurationUnit.NANOSECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of nanoseconds. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Long.nanoseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.nanoseconds\", \"kotlin.time.Duration.Companion.nanoseconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun nanoseconds(value: Long): Duration = value.toDuration(DurationUnit.NANOSECONDS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of nanoseconds.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Double.nanoseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.nanoseconds\", \"kotlin.time.Duration.Companion.nanoseconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun nanoseconds(value: Double): Duration = value.toDuration(DurationUnit.NANOSECONDS)\n\n\n        /** Returns a [Duration] representing the specified [value] number of microseconds. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Int.microseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.microseconds\", \"kotlin.time.Duration.Companion.microseconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun microseconds(value: Int): Duration = value.toDuration(DurationUnit.MICROSECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of microseconds. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Long.microseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.microseconds\", \"kotlin.time.Duration.Companion.microseconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun microseconds(value: Long): Duration = value.toDuration(DurationUnit.MICROSECONDS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of microseconds.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Double.microseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.microseconds\", \"kotlin.time.Duration.Companion.microseconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun microseconds(value: Double): Duration = value.toDuration(DurationUnit.MICROSECONDS)\n\n\n        /** Returns a [Duration] representing the specified [value] number of milliseconds. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Int.milliseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.milliseconds\", \"kotlin.time.Duration.Companion.milliseconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun milliseconds(value: Int): Duration = value.toDuration(DurationUnit.MILLISECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of milliseconds. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Long.milliseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.milliseconds\", \"kotlin.time.Duration.Companion.milliseconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun milliseconds(value: Long): Duration = value.toDuration(DurationUnit.MILLISECONDS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of milliseconds.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Double.milliseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.milliseconds\", \"kotlin.time.Duration.Companion.milliseconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun milliseconds(value: Double): Duration = value.toDuration(DurationUnit.MILLISECONDS)\n\n\n        /** Returns a [Duration] representing the specified [value] number of seconds. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Int.seconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.seconds\", \"kotlin.time.Duration.Companion.seconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun seconds(value: Int): Duration = value.toDuration(DurationUnit.SECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of seconds. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Long.seconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.seconds\", \"kotlin.time.Duration.Companion.seconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun seconds(value: Long): Duration = value.toDuration(DurationUnit.SECONDS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of seconds.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Double.seconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.seconds\", \"kotlin.time.Duration.Companion.seconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun seconds(value: Double): Duration = value.toDuration(DurationUnit.SECONDS)\n\n\n        /** Returns a [Duration] representing the specified [value] number of minutes. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Int.minutes' extension property from Duration.Companion instead.\", ReplaceWith(\"value.minutes\", \"kotlin.time.Duration.Companion.minutes\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun minutes(value: Int): Duration = value.toDuration(DurationUnit.MINUTES)\n\n        /** Returns a [Duration] representing the specified [value] number of minutes. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Long.minutes' extension property from Duration.Companion instead.\", ReplaceWith(\"value.minutes\", \"kotlin.time.Duration.Companion.minutes\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun minutes(value: Long): Duration = value.toDuration(DurationUnit.MINUTES)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of minutes.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Double.minutes' extension property from Duration.Companion instead.\", ReplaceWith(\"value.minutes\", \"kotlin.time.Duration.Companion.minutes\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun minutes(value: Double): Duration = value.toDuration(DurationUnit.MINUTES)\n\n\n        /** Returns a [Duration] representing the specified [value] number of hours. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Int.hours' extension property from Duration.Companion instead.\", ReplaceWith(\"value.hours\", \"kotlin.time.Duration.Companion.hours\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun hours(value: Int): Duration = value.toDuration(DurationUnit.HOURS)\n\n        /** Returns a [Duration] representing the specified [value] number of hours. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Long.hours' extension property from Duration.Companion instead.\", ReplaceWith(\"value.hours\", \"kotlin.time.Duration.Companion.hours\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun hours(value: Long): Duration = value.toDuration(DurationUnit.HOURS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of hours.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Double.hours' extension property from Duration.Companion instead.\", ReplaceWith(\"value.hours\", \"kotlin.time.Duration.Companion.hours\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun hours(value: Double): Duration = value.toDuration(DurationUnit.HOURS)\n\n\n        /** Returns a [Duration] representing the specified [value] number of days. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Int.days' extension property from Duration.Companion instead.\", ReplaceWith(\"value.days\", \"kotlin.time.Duration.Companion.days\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun days(value: Int): Duration = value.toDuration(DurationUnit.DAYS)\n\n        /** Returns a [Duration] representing the specified [value] number of days. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Long.days' extension property from Duration.Companion instead.\", ReplaceWith(\"value.days\", \"kotlin.time.Duration.Companion.days\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun days(value: Long): Duration = value.toDuration(DurationUnit.DAYS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of days.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Double.days' extension property from Duration.Companion instead.\", ReplaceWith(\"value.days\", \"kotlin.time.Duration.Companion.days\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun days(value: Double): Duration = value.toDuration(DurationUnit.DAYS)\n\n        /**\n         * Parses a string that represents a duration and returns the parsed [Duration] value.\n         *\n         * The following formats are accepted:\n         *\n         * - ISO-8601 Duration format, e.g. `P1DT2H3M4.058S`, see [toIsoString] and [parseIsoString].\n         * - The format of string returned by the default [Duration.toString] and `toString` in a specific unit,\n         *   e.g. `10s`, `1h 30m` or `-(1h 30m)`.\n         *\n         * @throws IllegalArgumentException if the string doesn't represent a duration in any of the supported formats.\n         * @sample samples.time.Durations.parse\n         */\n        public fun parse(value: String): Duration = try {\n            parseDuration(value, strictIso = false)\n        } catch (e: IllegalArgumentException) {\n            throw IllegalArgumentException(\"Invalid duration string format: '$value'.\", e)\n        }\n\n        /**\n         * Parses a string that represents a duration in a restricted ISO-8601 composite representation\n         * and returns the parsed [Duration] value.\n         * Composite representation is a relaxed version of ISO-8601 duration format that supports\n         * negative durations and negative values of individual components.\n         *\n         * The following restrictions are imposed:\n         *\n         * - The only allowed non-time designator is days (`D`). `Y` (years), `W` (weeks), and `M` (months) are not supported.\n         * - Day is considered to be exactly 24 hours (24-hour clock time scale).\n         * - Alternative week-based representation `[\"P\"][number][\"W\"]` is not supported.\n         *\n         * @throws IllegalArgumentException if the string doesn't represent a duration in ISO-8601 format.\n         * @sample samples.time.Durations.parseIsoString\n         */\n        public fun parseIsoString(value: String): Duration = try {\n            parseDuration(value, strictIso = true)\n        } catch (e: IllegalArgumentException) {\n            throw IllegalArgumentException(\"Invalid ISO duration string format: '$value'.\", e)\n        }\n\n        /**\n         * Parses a string that represents a duration and returns the parsed [Duration] value,\n         * or `null` if the string doesn't represent a duration in any of the supported formats.\n         *\n         * The following formats are accepted:\n         *\n         * - Restricted ISO-8601 duration composite representation, e.g. `P1DT2H3M4.058S`, see [toIsoString] and [parseIsoString].\n         * - The format of string returned by the default [Duration.toString] and `toString` in a specific unit,\n         *   e.g. `10s`, `1h 30m` or `-(1h 30m)`.\n         *   @sample samples.time.Durations.parse\n         */\n        public fun parseOrNull(value: String): Duration? = try {\n            parseDuration(value, strictIso = false)\n        } catch (e: IllegalArgumentException) {\n            null\n        }\n\n        /**\n         * Parses a string that represents a duration in restricted ISO-8601 composite representation\n         * and returns the parsed [Duration] value or `null` if the string doesn't represent a duration in the format\n         * acceptable by [parseIsoString].\n         *\n         * @sample samples.time.Durations.parseIsoString\n         */\n        public fun parseIsoStringOrNull(value: String): Duration? = try {\n            parseDuration(value, strictIso = true)\n        } catch (e: IllegalArgumentException) {\n            null\n        }\n    }\n\n    // arithmetic operators\n\n    /** Returns the negative of this value. */\n    public operator fun unaryMinus(): Duration = durationOf(-value, unitDiscriminator)\n\n    /**\n     * Returns a duration whose value is the sum of this and [other] duration values.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when adding infinite durations of different sign.\n     */\n    public operator fun plus(other: Duration): Duration {\n        when {\n            this.isInfinite() -> {\n                if (other.isFinite() || (this.rawValue xor other.rawValue >= 0))\n                    return this\n                else\n                    throw IllegalArgumentException(\"Summing infinite durations of different signs yields an undefined result.\")\n            }\n            other.isInfinite() -> return other\n        }\n\n        return when {\n            this.unitDiscriminator == other.unitDiscriminator -> {\n                val result = this.value + other.value // never overflows long, but can overflow long63\n                when {\n                    isInNanos() ->\n                        durationOfNanosNormalized(result)\n                    else ->\n                        durationOfMillisNormalized(result)\n                }\n            }\n            this.isInMillis() ->\n                addValuesMixedRanges(this.value, other.value)\n            else ->\n                addValuesMixedRanges(other.value, this.value)\n        }\n    }\n\n    private fun addValuesMixedRanges(thisMillis: Long, otherNanos: Long): Duration {\n        val otherMillis = nanosToMillis(otherNanos)\n        val resultMillis = thisMillis + otherMillis\n        return if (resultMillis in -MAX_NANOS_IN_MILLIS..MAX_NANOS_IN_MILLIS) {\n            val otherNanoRemainder = otherNanos - millisToNanos(otherMillis)\n            durationOfNanos(millisToNanos(resultMillis) + otherNanoRemainder)\n        } else {\n            durationOfMillis(resultMillis.coerceIn(-MAX_MILLIS, MAX_MILLIS))\n        }\n    }\n\n    /**\n     * Returns a duration whose value is the difference between this and [other] duration values.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when subtracting infinite durations of the same sign.\n     */\n    public operator fun minus(other: Duration): Duration = this + (-other)\n\n    /**\n     * Returns a duration whose value is this duration value multiplied by the given [scale] number.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when multiplying an infinite duration by zero.\n     */\n    public operator fun times(scale: Int): Duration {\n        if (isInfinite()) {\n            return when {\n                scale == 0 -> throw IllegalArgumentException(\"Multiplying infinite duration by zero yields an undefined result.\")\n                scale > 0 -> this\n                else -> -this\n            }\n        }\n        if (scale == 0) return ZERO\n\n        val value = value\n        val result = value * scale\n        return if (isInNanos()) {\n            if (value in (MAX_NANOS / Int.MIN_VALUE)..(-MAX_NANOS / Int.MIN_VALUE)) {\n                // can't overflow nanos range for any scale\n                durationOfNanos(result)\n            } else {\n                if (result / scale == value) {\n                    durationOfNanosNormalized(result)\n                } else {\n                    val millis = nanosToMillis(value)\n                    val remNanos = value - millisToNanos(millis)\n                    val resultMillis = millis * scale\n                    val totalMillis = resultMillis + nanosToMillis(remNanos * scale)\n                    if (resultMillis / scale == millis && totalMillis xor resultMillis >= 0) {\n                        durationOfMillis(totalMillis.coerceIn(-MAX_MILLIS..MAX_MILLIS))\n                    } else {\n                        if (value.sign * scale.sign > 0) INFINITE else NEG_INFINITE\n                    }\n                }\n            }\n        } else {\n            if (result / scale == value) {\n                durationOfMillis(result.coerceIn(-MAX_MILLIS..MAX_MILLIS))\n            } else {\n                if (value.sign * scale.sign > 0) INFINITE else NEG_INFINITE\n            }\n        }\n    }\n\n    /**\n     * Returns a duration whose value is this duration value multiplied by the given [scale] number.\n     *\n     * The operation may involve rounding when the result cannot be represented exactly with a [Double] number.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when multiplying an infinite duration by zero.\n     */\n    public operator fun times(scale: Double): Duration {\n        val intScale = scale.roundToInt()\n        if (intScale.toDouble() == scale) {\n            return times(intScale)\n        }\n\n        val unit = storageUnit\n        val result = toDouble(unit) * scale\n        return result.toDuration(unit)\n    }\n\n    /**\n     * Returns a duration whose value is this duration value divided by the given [scale] number.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when dividing zero duration by zero.\n     */\n    public operator fun div(scale: Int): Duration {\n        if (scale == 0) {\n            return when {\n                isPositive() -> INFINITE\n                isNegative() -> NEG_INFINITE\n                else -> throw IllegalArgumentException(\"Dividing zero duration by zero yields an undefined result.\")\n            }\n        }\n        if (isInNanos()) {\n            return durationOfNanos(value / scale)\n        } else {\n            if (isInfinite())\n                return this * scale.sign\n\n            val result = value / scale\n\n            if (result in -MAX_NANOS_IN_MILLIS..MAX_NANOS_IN_MILLIS) {\n                val rem = millisToNanos(value - (result * scale)) / scale\n                return durationOfNanos(millisToNanos(result) + rem)\n            }\n            return durationOfMillis(result)\n        }\n    }\n\n    /**\n     * Returns a duration whose value is this duration value divided by the given [scale] number.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when dividing an infinite duration by infinity or zero duration by zero.\n     */\n    public operator fun div(scale: Double): Duration {\n        val intScale = scale.roundToInt()\n        if (intScale.toDouble() == scale && intScale != 0) {\n            return div(intScale)\n        }\n\n        val unit = storageUnit\n        val result = toDouble(unit) / scale\n        return result.toDuration(unit)\n    }\n\n    /** Returns a number that is the ratio of this and [other] duration values. */\n    public operator fun div(other: Duration): Double {\n        val coarserUnit = maxOf(this.storageUnit, other.storageUnit)\n        return this.toDouble(coarserUnit) / other.toDouble(coarserUnit)\n    }\n\n    /** Returns true, if the duration value is less than zero. */\n    public fun isNegative(): Boolean = rawValue < 0\n\n    /** Returns true, if the duration value is greater than zero. */\n    public fun isPositive(): Boolean = rawValue > 0\n\n    /** Returns true, if the duration value is infinite. */\n    public fun isInfinite(): Boolean = rawValue == INFINITE.rawValue || rawValue == NEG_INFINITE.rawValue\n\n    /** Returns true, if the duration value is finite. */\n    public fun isFinite(): Boolean = !isInfinite()\n\n    /** Returns the absolute value of this value. The returned value is always non-negative. */\n    public val absoluteValue: Duration get() = if (isNegative()) -this else this\n\n    override fun compareTo(other: Duration): Int {\n        val compareBits = this.rawValue xor other.rawValue\n        if (compareBits < 0 || compareBits.toInt() and 1 == 0) // different signs or same sign/same range\n            return this.rawValue.compareTo(other.rawValue)\n        // same sign/different ranges\n        val r = this.unitDiscriminator - other.unitDiscriminator // compare ranges\n        return if (isNegative()) -r else r\n    }\n\n\n    // splitting to components\n\n    /**\n     * Splits this duration into days, hours, minutes, seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration, and its absolute value is less than 60;\n     * - `minutes` represents the whole number of minutes in this duration, and its absolute value is less than 60;\n     * - `hours` represents the whole number of hours in this duration, and its absolute value is less than 24;\n     * - `days` represents the whole number of days in this duration.\n     *\n     *   Infinite durations are represented as either [Long.MAX_VALUE] days, or [Long.MIN_VALUE] days (depending on the sign of infinity),\n     *   and zeroes in the lower components.\n     */\n    public inline fun <T> toComponents(action: (days: Long, hours: Int, minutes: Int, seconds: Int, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(inWholeDays, hoursComponent, minutesComponent, secondsComponent, nanosecondsComponent)\n    }\n\n    /**\n     * Splits this duration into hours, minutes, seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration, and its absolute value is less than 60;\n     * - `minutes` represents the whole number of minutes in this duration, and its absolute value is less than 60;\n     * - `hours` represents the whole number of hours in this duration.\n     *\n     *   Infinite durations are represented as either [Long.MAX_VALUE] hours, or [Long.MIN_VALUE] hours (depending on the sign of infinity),\n     *   and zeroes in the lower components.\n     */\n    public inline fun <T> toComponents(action: (hours: Long, minutes: Int, seconds: Int, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(inWholeHours, minutesComponent, secondsComponent, nanosecondsComponent)\n    }\n\n    /**\n     * Splits this duration into minutes, seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration, and its absolute value is less than 60;\n     * - `minutes` represents the whole number of minutes in this duration.\n     *\n     *   Infinite durations are represented as either [Long.MAX_VALUE] minutes, or [Long.MIN_VALUE] minutes (depending on the sign of infinity),\n     *   and zeroes in the lower components.\n     */\n    public inline fun <T> toComponents(action: (minutes: Long, seconds: Int, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(inWholeMinutes, secondsComponent, nanosecondsComponent)\n    }\n\n    /**\n     * Splits this duration into seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration.\n     *\n     *   Infinite durations are represented as either [Long.MAX_VALUE] seconds, or [Long.MIN_VALUE] seconds (depending on the sign of infinity),\n     *   and zero nanoseconds.\n     */\n    public inline fun <T> toComponents(action: (seconds: Long, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(inWholeSeconds, nanosecondsComponent)\n    }\n\n    @PublishedApi\n    internal val hoursComponent: Int\n        get() = if (isInfinite()) 0 else (inWholeHours % 24).toInt()\n\n    @PublishedApi\n    internal val minutesComponent: Int\n        get() = if (isInfinite()) 0 else (inWholeMinutes % 60).toInt()\n\n    @PublishedApi\n    internal val secondsComponent: Int\n        get() = if (isInfinite()) 0 else (inWholeSeconds % 60).toInt()\n\n    @PublishedApi\n    internal val nanosecondsComponent: Int\n        get() = when {\n            isInfinite() -> 0\n            isInMillis() -> millisToNanos(value % 1_000).toInt()\n            else -> (value % 1_000_000_000).toInt()\n        }\n\n\n    // conversion to units\n\n    /**\n     * Returns the value of this duration expressed as a [Double] number of the specified [unit].\n     *\n     * The operation may involve rounding when the result cannot be represented exactly with a [Double] number.\n     *\n     * An infinite duration value is converted either to [Double.POSITIVE_INFINITY] or [Double.NEGATIVE_INFINITY] depending on its sign.\n     */\n    public fun toDouble(unit: DurationUnit): Double {\n        return when (rawValue) {\n            INFINITE.rawValue -> Double.POSITIVE_INFINITY\n            NEG_INFINITE.rawValue -> Double.NEGATIVE_INFINITY\n            else -> {\n                // TODO: whether it's ok to convert to Double before scaling\n                convertDurationUnit(value.toDouble(), storageUnit, unit)\n            }\n        }\n    }\n\n    /**\n     * Returns the value of this duration expressed as a [Long] number of the specified [unit].\n     *\n     * If the result doesn't fit in the range of [Long] type, it is coerced into that range:\n     * - [Long.MIN_VALUE] is returned if it's less than `Long.MIN_VALUE`,\n     * - [Long.MAX_VALUE] is returned if it's greater than `Long.MAX_VALUE`.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    public fun toLong(unit: DurationUnit): Long {\n        return when (rawValue) {\n            INFINITE.rawValue -> Long.MAX_VALUE\n            NEG_INFINITE.rawValue -> Long.MIN_VALUE\n            else -> convertDurationUnit(value, storageUnit, unit)\n        }\n    }\n\n    /**\n     * Returns the value of this duration expressed as an [Int] number of the specified [unit].\n     *\n     * If the result doesn't fit in the range of [Int] type, it is coerced into that range:\n     * - [Int.MIN_VALUE] is returned if it's less than `Int.MIN_VALUE`,\n     * - [Int.MAX_VALUE] is returned if it's greater than `Int.MAX_VALUE`.\n     *\n     * An infinite duration value is converted either to [Int.MAX_VALUE] or [Int.MIN_VALUE] depending on its sign.\n     */\n    public fun toInt(unit: DurationUnit): Int =\n        toLong(unit).coerceIn(Int.MIN_VALUE.toLong(), Int.MAX_VALUE.toLong()).toInt()\n\n    /** The value of this duration expressed as a [Double] number of days. */\n    @ExperimentalTime\n    @Deprecated(\"Use inWholeDays property instead or convert toDouble(DAYS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.DAYS)\"))\n    public val inDays: Double get() = toDouble(DurationUnit.DAYS)\n\n    /** The value of this duration expressed as a [Double] number of hours. */\n    @ExperimentalTime\n    @Deprecated(\"Use inWholeHours property instead or convert toDouble(HOURS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.HOURS)\"))\n    public val inHours: Double get() = toDouble(DurationUnit.HOURS)\n\n    /** The value of this duration expressed as a [Double] number of minutes. */\n    @ExperimentalTime\n    @Deprecated(\"Use inWholeMinutes property instead or convert toDouble(MINUTES) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.MINUTES)\"))\n    public val inMinutes: Double get() = toDouble(DurationUnit.MINUTES)\n\n    /** The value of this duration expressed as a [Double] number of seconds. */\n    @ExperimentalTime\n    @Deprecated(\"Use inWholeSeconds property instead or convert toDouble(SECONDS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.SECONDS)\"))\n    public val inSeconds: Double get() = toDouble(DurationUnit.SECONDS)\n\n    /** The value of this duration expressed as a [Double] number of milliseconds. */\n    @ExperimentalTime\n    @Deprecated(\"Use inWholeMilliseconds property instead or convert toDouble(MILLISECONDS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.MILLISECONDS)\"))\n    public val inMilliseconds: Double get() = toDouble(DurationUnit.MILLISECONDS)\n\n    /** The value of this duration expressed as a [Double] number of microseconds. */\n    @ExperimentalTime\n    @Deprecated(\"Use inWholeMicroseconds property instead or convert toDouble(MICROSECONDS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.MICROSECONDS)\"))\n    public val inMicroseconds: Double get() = toDouble(DurationUnit.MICROSECONDS)\n\n    /** The value of this duration expressed as a [Double] number of nanoseconds. */\n    @ExperimentalTime\n    @Deprecated(\"Use inWholeNanoseconds property instead or convert toDouble(NANOSECONDS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.NANOSECONDS)\"))\n    public val inNanoseconds: Double get() = toDouble(DurationUnit.NANOSECONDS)\n\n\n    /**\n     * The value of this duration expressed as a [Long] number of days.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    public val inWholeDays: Long\n        get() = toLong(DurationUnit.DAYS)\n\n    /**\n     * The value of this duration expressed as a [Long] number of hours.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    public val inWholeHours: Long\n        get() = toLong(DurationUnit.HOURS)\n\n    /**\n     * The value of this duration expressed as a [Long] number of minutes.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    public val inWholeMinutes: Long\n        get() = toLong(DurationUnit.MINUTES)\n\n    /**\n     * The value of this duration expressed as a [Long] number of seconds.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    public val inWholeSeconds: Long\n        get() = toLong(DurationUnit.SECONDS)\n\n    /**\n     * The value of this duration expressed as a [Long] number of milliseconds.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    public val inWholeMilliseconds: Long\n        get() {\n            return if (isInMillis() && isFinite()) value else toLong(DurationUnit.MILLISECONDS)\n        }\n\n    /**\n     * The value of this duration expressed as a [Long] number of microseconds.\n     *\n     * If the result doesn't fit in the range of [Long] type, it is coerced into that range:\n     * - [Long.MIN_VALUE] is returned if it's less than `Long.MIN_VALUE`,\n     * - [Long.MAX_VALUE] is returned if it's greater than `Long.MAX_VALUE`.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    public val inWholeMicroseconds: Long\n        get() = toLong(DurationUnit.MICROSECONDS)\n\n    /**\n     * The value of this duration expressed as a [Long] number of nanoseconds.\n     *\n     * If the result doesn't fit in the range of [Long] type, it is coerced into that range:\n     * - [Long.MIN_VALUE] is returned if it's less than `Long.MIN_VALUE`,\n     * - [Long.MAX_VALUE] is returned if it's greater than `Long.MAX_VALUE`.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    public val inWholeNanoseconds: Long\n        get() {\n            val value = value\n            return when {\n                isInNanos() -> value\n                value > Long.MAX_VALUE / NANOS_IN_MILLIS -> Long.MAX_VALUE\n                value < Long.MIN_VALUE / NANOS_IN_MILLIS -> Long.MIN_VALUE\n                else -> millisToNanos(value)\n            }\n        }\n\n    // shortcuts\n\n    /**\n     * Returns the value of this duration expressed as a [Long] number of nanoseconds.\n     *\n     * If the value doesn't fit in the range of [Long] type, it is coerced into that range, see the conversion [Double.toLong] for details.\n     *\n     * The range of durations that can be expressed as a `Long` number of nanoseconds is approximately ±292 years.\n     */\n    @ExperimentalTime\n    @Deprecated(\"Use inWholeNanoseconds property instead.\", ReplaceWith(\"this.inWholeNanoseconds\"))\n    public fun toLongNanoseconds(): Long = inWholeNanoseconds\n\n    /**\n     * Returns the value of this duration expressed as a [Long] number of milliseconds.\n     *\n     * The value is coerced to the range of [Long] type, if it doesn't fit in that range, see the conversion [Double.toLong] for details.\n     *\n     * The range of durations that can be expressed as a `Long` number of milliseconds is approximately ±292 million years.\n     */\n    @ExperimentalTime\n    @Deprecated(\"Use inWholeMilliseconds property instead.\", ReplaceWith(\"this.inWholeMilliseconds\"))\n    public fun toLongMilliseconds(): Long = inWholeMilliseconds\n\n    /**\n     * Returns a string representation of this duration value\n     * expressed as a combination of numeric components, each in its own unit.\n     *\n     * Each component is a number followed by the unit abbreviated name: `d`, `h`, `m`, `s`:\n     * `5h`, `1d 12h`, `1h 0m 30.340s`.\n     * The last component, usually seconds, can be a number with a fractional part.\n     *\n     * If the duration is less than a second, it is represented as a single number\n     * with one of sub-second units: `ms` (milliseconds), `us` (microseconds), or `ns` (nanoseconds):\n     * `140.884ms`, `500us`, `24ns`.\n     *\n     * A negative duration is prefixed with `-` sign and, if it consists of multiple components, surrounded with parentheses:\n     * `-12m` and `-(1h 30m)`.\n     *\n     * Special cases:\n     *  - an infinite duration is formatted as `\"Infinity\"` or `\"-Infinity\"` without a unit.\n     *\n     * It's recommended to use [toIsoString] that uses more strict ISO-8601 format instead of this `toString`\n     * when you want to convert a duration to a string in cases of serialization, interchange, etc.\n     *\n     * @sample samples.time.Durations.toStringDefault\n     */\n    override fun toString(): String = when (rawValue) {\n        0L -> \"0s\"\n        INFINITE.rawValue -> \"Infinity\"\n        NEG_INFINITE.rawValue -> \"-Infinity\"\n        else -> {\n            val isNegative = isNegative()\n            buildString {\n                if (isNegative) append('-')\n                absoluteValue.toComponents { days, hours, minutes, seconds, nanoseconds ->\n                    val hasDays = days != 0L\n                    val hasHours = hours != 0\n                    val hasMinutes = minutes != 0\n                    val hasSeconds = seconds != 0 || nanoseconds != 0\n                    var components = 0\n                    if (hasDays) {\n                        append(days).append('d')\n                        components++\n                    }\n                    if (hasHours || (hasDays && (hasMinutes || hasSeconds))) {\n                        if (components++ > 0) append(' ')\n                        append(hours).append('h')\n                    }\n                    if (hasMinutes || (hasSeconds && (hasHours || hasDays))) {\n                        if (components++ > 0) append(' ')\n                        append(minutes).append('m')\n                    }\n                    if (hasSeconds) {\n                        if (components++ > 0) append(' ')\n                        when {\n                            seconds != 0 || hasDays || hasHours || hasMinutes ->\n                                appendFractional(seconds, nanoseconds, 9, \"s\", isoZeroes = false)\n                            nanoseconds >= 1_000_000 ->\n                                appendFractional(nanoseconds / 1_000_000, nanoseconds % 1_000_000, 6, \"ms\", isoZeroes = false)\n                            nanoseconds >= 1_000 ->\n                                appendFractional(nanoseconds / 1_000, nanoseconds % 1_000, 3, \"us\", isoZeroes = false)\n                            else ->\n                                append(nanoseconds).append(\"ns\")\n                        }\n                    }\n                    if (isNegative && components > 1) insert(1, '(').append(')')\n                }\n            }\n        }\n    }\n\n    private fun StringBuilder.appendFractional(whole: Int, fractional: Int, fractionalSize: Int, unit: String, isoZeroes: Boolean) {\n        append(whole)\n        if (fractional != 0) {\n            append('.')\n            val fracString = fractional.toString().padStart(fractionalSize, '0')\n            val nonZeroDigits = fracString.indexOfLast { it != '0' } + 1\n            when {\n                !isoZeroes && nonZeroDigits < 3 -> appendRange(fracString, 0, nonZeroDigits)\n                else -> appendRange(fracString, 0, ((nonZeroDigits + 2) / 3) * 3)\n            }\n        }\n        append(unit)\n    }\n\n    /**\n     * Returns a string representation of this duration value expressed in the given [unit]\n     * and formatted with the specified [decimals] number of digits after decimal point.\n     *\n     * Special cases:\n     *  - an infinite duration is formatted as `\"Infinity\"` or `\"-Infinity\"` without a unit.\n     *\n     * @param decimals the number of digits after decimal point to show. The value must be non-negative.\n     * No more than 12 decimals will be shown, even if a larger number is requested.\n     *\n     * @return the value of duration in the specified [unit] followed by that unit abbreviated name: `d`, `h`, `m`, `s`, `ms`, `us`, or `ns`.\n     *\n     * @throws IllegalArgumentException if [decimals] is less than zero.\n     *\n     * @sample samples.time.Durations.toStringDecimals\n     */\n    public fun toString(unit: DurationUnit, decimals: Int = 0): String {\n        require(decimals >= 0) { \"decimals must be not negative, but was $decimals\" }\n        val number = toDouble(unit)\n        if (number.isInfinite()) return number.toString()\n        return formatToExactDecimals(number, decimals.coerceAtMost(12)) + unit.shortName()\n    }\n\n\n    /**\n     * Returns an ISO-8601 based string representation of this duration.\n     *\n     * The returned value is presented in the format `PThHmMs.fS`, where `h`, `m`, `s` are the integer components of this duration (see [toComponents])\n     * and `f` is a fractional part of second. Depending on the roundness of the value the fractional part can be formatted with either\n     * 0, 3, 6, or 9 decimal digits.\n     *\n     * The infinite duration is represented as `\"PT9999999999999H\"` which is larger than any possible finite duration in Kotlin.\n     *\n     * Negative durations are indicated with the sign `-` in the beginning of the returned string, for example, `\"-PT5M30S\"`.\n     *\n     * @sample samples.time.Durations.toIsoString\n     */\n    public fun toIsoString(): String = buildString {\n        if (isNegative()) append('-')\n        append(\"PT\")\n        this@Duration.absoluteValue.toComponents { hours, minutes, seconds, nanoseconds ->\n            @Suppress(\"NAME_SHADOWING\")\n            var hours = hours\n            if (isInfinite()) {\n                // use large enough value instead of Long.MAX_VALUE\n                hours = 9_999_999_999_999\n            }\n            val hasHours = hours != 0L\n            val hasSeconds = seconds != 0 || nanoseconds != 0\n            val hasMinutes = minutes != 0 || (hasSeconds && hasHours)\n            if (hasHours) {\n                append(hours).append('H')\n            }\n            if (hasMinutes) {\n                append(minutes).append('M')\n            }\n            if (hasSeconds || (!hasHours && !hasMinutes)) {\n                appendFractional(seconds, nanoseconds, 9, \"S\", isoZeroes = true)\n            }\n        }\n    }\n\n}\n\n// constructing from number of units\n// extension functions\n\n/** Returns a [Duration] equal to this [Int] number of the specified [unit]. */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalTime::class)\npublic fun Int.toDuration(unit: DurationUnit): Duration {\n    return if (unit <= DurationUnit.SECONDS) {\n        durationOfNanos(convertDurationUnitOverflow(this.toLong(), unit, DurationUnit.NANOSECONDS))\n    } else\n        toLong().toDuration(unit)\n}\n\n/** Returns a [Duration] equal to this [Long] number of the specified [unit]. */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalTime::class)\npublic fun Long.toDuration(unit: DurationUnit): Duration {\n    val maxNsInUnit = convertDurationUnitOverflow(MAX_NANOS, DurationUnit.NANOSECONDS, unit)\n    if (this in -maxNsInUnit..maxNsInUnit) {\n        return durationOfNanos(convertDurationUnitOverflow(this, unit, DurationUnit.NANOSECONDS))\n    } else {\n        val millis = convertDurationUnit(this, unit, DurationUnit.MILLISECONDS)\n        return durationOfMillis(millis.coerceIn(-MAX_MILLIS, MAX_MILLIS))\n    }\n}\n\n/**\n * Returns a [Duration] equal to this [Double] number of the specified [unit].\n *\n * Depending on its magnitude, the value is rounded to an integer number of nanoseconds or milliseconds.\n *\n * @throws IllegalArgumentException if this `Double` value is `NaN`.\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalTime::class)\npublic fun Double.toDuration(unit: DurationUnit): Duration {\n    val valueInNs = convertDurationUnit(this, unit, DurationUnit.NANOSECONDS)\n    require(!valueInNs.isNaN()) { \"Duration value cannot be NaN.\" }\n    val nanos = valueInNs.roundToLong()\n    return if (nanos in -MAX_NANOS..MAX_NANOS) {\n        durationOfNanos(nanos)\n    } else {\n        val millis = convertDurationUnit(this, unit, DurationUnit.MILLISECONDS).roundToLong()\n        durationOfMillisNormalized(millis)\n    }\n}\n\n// constructing from number of units\n// deprecated extension properties\n\n/** Returns a [Duration] equal to this [Int] number of nanoseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Int.nanoseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.nanoseconds\", \"kotlin.time.Duration.Companion.nanoseconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Int.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of nanoseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Long.nanoseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.nanoseconds\", \"kotlin.time.Duration.Companion.nanoseconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Long.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of nanoseconds.\n *\n * @throws IllegalArgumentException if this [Double] value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Double.nanoseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.nanoseconds\", \"kotlin.time.Duration.Companion.nanoseconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Double.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n\n/** Returns a [Duration] equal to this [Int] number of microseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Int.microseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.microseconds\", \"kotlin.time.Duration.Companion.microseconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Int.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of microseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Long.microseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.microseconds\", \"kotlin.time.Duration.Companion.microseconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Long.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of microseconds.\n *\n * @throws IllegalArgumentException if this [Double] value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Double.microseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.microseconds\", \"kotlin.time.Duration.Companion.microseconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Double.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n\n/** Returns a [Duration] equal to this [Int] number of milliseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Int.milliseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.milliseconds\", \"kotlin.time.Duration.Companion.milliseconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Int.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of milliseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Long.milliseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.milliseconds\", \"kotlin.time.Duration.Companion.milliseconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Long.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of milliseconds.\n *\n * @throws IllegalArgumentException if this [Double] value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Double.milliseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.milliseconds\", \"kotlin.time.Duration.Companion.milliseconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Double.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n\n/** Returns a [Duration] equal to this [Int] number of seconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Int.seconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.seconds\", \"kotlin.time.Duration.Companion.seconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Int.seconds get() = toDuration(DurationUnit.SECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of seconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Long.seconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.seconds\", \"kotlin.time.Duration.Companion.seconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Long.seconds get() = toDuration(DurationUnit.SECONDS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of seconds.\n *\n * @throws IllegalArgumentException if this [Double] value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Double.seconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.seconds\", \"kotlin.time.Duration.Companion.seconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Double.seconds get() = toDuration(DurationUnit.SECONDS)\n\n\n/** Returns a [Duration] equal to this [Int] number of minutes. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Int.minutes' extension property from Duration.Companion instead.\", ReplaceWith(\"this.minutes\", \"kotlin.time.Duration.Companion.minutes\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Int.minutes get() = toDuration(DurationUnit.MINUTES)\n\n/** Returns a [Duration] equal to this [Long] number of minutes. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Long.minutes' extension property from Duration.Companion instead.\", ReplaceWith(\"this.minutes\", \"kotlin.time.Duration.Companion.minutes\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Long.minutes get() = toDuration(DurationUnit.MINUTES)\n\n/**\n * Returns a [Duration] equal to this [Double] number of minutes.\n *\n * @throws IllegalArgumentException if this [Double] value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Double.minutes' extension property from Duration.Companion instead.\", ReplaceWith(\"this.minutes\", \"kotlin.time.Duration.Companion.minutes\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Double.minutes get() = toDuration(DurationUnit.MINUTES)\n\n\n/** Returns a [Duration] equal to this [Int] number of hours. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Int.hours' extension property from Duration.Companion instead.\", ReplaceWith(\"this.hours\", \"kotlin.time.Duration.Companion.hours\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Int.hours get() = toDuration(DurationUnit.HOURS)\n\n/** Returns a [Duration] equal to this [Long] number of hours. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Long.hours' extension property from Duration.Companion instead.\", ReplaceWith(\"this.hours\", \"kotlin.time.Duration.Companion.hours\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Long.hours get() = toDuration(DurationUnit.HOURS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of hours.\n *\n * @throws IllegalArgumentException if this [Double] value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Double.hours' extension property from Duration.Companion instead.\", ReplaceWith(\"this.hours\", \"kotlin.time.Duration.Companion.hours\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Double.hours get() = toDuration(DurationUnit.HOURS)\n\n\n/** Returns a [Duration] equal to this [Int] number of days. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Int.days' extension property from Duration.Companion instead.\", ReplaceWith(\"this.days\", \"kotlin.time.Duration.Companion.days\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Int.days get() = toDuration(DurationUnit.DAYS)\n\n/** Returns a [Duration] equal to this [Long] number of days. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Long.days' extension property from Duration.Companion instead.\", ReplaceWith(\"this.days\", \"kotlin.time.Duration.Companion.days\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Long.days get() = toDuration(DurationUnit.DAYS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of days.\n *\n * @throws IllegalArgumentException if this [Double] value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Double.days' extension property from Duration.Companion instead.\", ReplaceWith(\"this.days\", \"kotlin.time.Duration.Companion.days\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Double.days get() = toDuration(DurationUnit.DAYS)\n\n\n/** Returns a duration whose value is the specified [duration] value multiplied by this number. */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalTime::class)\n@kotlin.internal.InlineOnly\npublic inline operator fun Int.times(duration: Duration): Duration = duration * this\n\n/**\n * Returns a duration whose value is the specified [duration] value multiplied by this number.\n *\n * The operation may involve rounding when the result cannot be represented exactly with a [Double] number.\n *\n * @throws IllegalArgumentException if the operation results in a `NaN` value.\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalTime::class)\n@kotlin.internal.InlineOnly\npublic inline operator fun Double.times(duration: Duration): Duration = duration * this\n\n\n\nprivate fun parseDuration(value: String, strictIso: Boolean): Duration {\n    var length = value.length\n    if (length == 0) throw IllegalArgumentException(\"The string is empty\")\n    var index = 0\n    var result = Duration.ZERO\n    val infinityString = \"Infinity\"\n    when (value[index]) {\n        '+', '-' -> index++\n    }\n    val hasSign = index > 0\n    val isNegative = hasSign && value.startsWith('-')\n    when {\n        length <= index ->\n            throw IllegalArgumentException(\"No components\")\n        value[index] == 'P' -> {\n            if (++index == length) throw IllegalArgumentException()\n            val nonDigitSymbols = \"+-.\"\n            var isTimeComponent = false\n            var prevUnit: DurationUnit? = null\n            while (index < length) {\n                if (value[index] == 'T') {\n                    if (isTimeComponent || ++index == length) throw IllegalArgumentException()\n                    isTimeComponent = true\n                    continue\n                }\n                val component = value.substringWhile(index) { it in '0'..'9' || it in nonDigitSymbols }\n                if (component.isEmpty()) throw IllegalArgumentException()\n                index += component.length\n                val unitChar = value.getOrElse(index) { throw IllegalArgumentException(\"Missing unit for value $component\") }\n                index++\n                val unit = durationUnitByIsoChar(unitChar, isTimeComponent)\n                if (prevUnit != null && prevUnit <= unit) throw IllegalArgumentException(\"Unexpected order of duration components\")\n                prevUnit = unit\n                val dotIndex = component.indexOf('.')\n                if (unit == DurationUnit.SECONDS && dotIndex > 0) {\n                    val whole = component.substring(0, dotIndex)\n                    result += parseOverLongIsoComponent(whole).toDuration(unit)\n                    result += component.substring(dotIndex).toDouble().toDuration(unit)\n                } else {\n                    result += parseOverLongIsoComponent(component).toDuration(unit)\n                }\n            }\n        }\n        strictIso ->\n            throw IllegalArgumentException()\n        value.regionMatches(index, infinityString, 0, length = maxOf(length - index, infinityString.length), ignoreCase = true) -> {\n            result = Duration.INFINITE\n        }\n        else -> {\n            // parse default string format\n            var prevUnit: DurationUnit? = null\n            var afterFirst = false\n            var allowSpaces = !hasSign\n            if (hasSign && value[index] == '(' && value.last() == ')') {\n                allowSpaces = true\n                if (++index == --length) throw IllegalArgumentException(\"No components\")\n            }\n            while (index < length) {\n                if (afterFirst && allowSpaces) {\n                    index = value.skipWhile(index) { it == ' ' }\n                }\n                afterFirst = true\n                val component = value.substringWhile(index) { it in '0'..'9' || it == '.' }\n                if (component.isEmpty()) throw IllegalArgumentException()\n                index += component.length\n                val unitName = value.substringWhile(index) { it in 'a'..'z' }\n                index += unitName.length\n                val unit = durationUnitByShortName(unitName)\n                if (prevUnit != null && prevUnit <= unit) throw IllegalArgumentException(\"Unexpected order of duration components\")\n                prevUnit = unit\n                val dotIndex = component.indexOf('.')\n                if (dotIndex > 0) {\n                    val whole = component.substring(0, dotIndex)\n                    result += whole.toLong().toDuration(unit)\n                    result += component.substring(dotIndex).toDouble().toDuration(unit)\n                    if (index < length) throw IllegalArgumentException(\"Fractional component must be last\")\n                } else {\n                    result += component.toLong().toDuration(unit)\n                }\n            }\n        }\n    }\n    return if (isNegative) -result else result\n}\n\n\nprivate fun parseOverLongIsoComponent(value: String): Long {\n    val length = value.length\n    var startIndex = 0\n    if (length > 0 && value[0] in \"+-\") startIndex++\n    if ((length - startIndex) > 16 && (startIndex..value.lastIndex).all { value[it] in '0'..'9' }) {\n        // all chars are digits, but more than ceiling(log10(MAX_MILLIS / 1000)) of them\n        return if (value[0] == '-') Long.MIN_VALUE else Long.MAX_VALUE\n    }\n    // TODO: replace with just toLong after min JDK becomes 8\n    return if (value.startsWith(\"+\")) value.drop(1).toLong() else value.toLong()\n}\n\n\n\nprivate inline fun String.substringWhile(startIndex: Int, predicate: (Char) -> Boolean): String =\n    substring(startIndex, skipWhile(startIndex, predicate))\n\nprivate inline fun String.skipWhile(startIndex: Int, predicate: (Char) -> Boolean): Int {\n    var i = startIndex\n    while (i < length && predicate(this[i])) i++\n    return i\n}\n\n\n\n\n\n// The ranges are chosen so that they are:\n// - symmetric relative to zero: this greatly simplifies operations with sign, e.g. unaryMinus and minus.\n// - non-overlapping, but adjacent: the first value that doesn't fit in nanos range, can be exactly represented in millis.\n\ninternal const val NANOS_IN_MILLIS = 1_000_000\n// maximum number duration can store in nanosecond range\ninternal const val MAX_NANOS = Long.MAX_VALUE / 2 / NANOS_IN_MILLIS * NANOS_IN_MILLIS - 1 // ends in ..._999_999\n// maximum number duration can store in millisecond range, also encodes an infinite value\ninternal const val MAX_MILLIS = Long.MAX_VALUE / 2\n// MAX_NANOS expressed in milliseconds\nprivate const val MAX_NANOS_IN_MILLIS = MAX_NANOS / NANOS_IN_MILLIS\n\nprivate fun nanosToMillis(nanos: Long): Long = nanos / NANOS_IN_MILLIS\nprivate fun millisToNanos(millis: Long): Long = millis * NANOS_IN_MILLIS\n\nprivate fun durationOfNanos(normalNanos: Long) = Duration(normalNanos shl 1)\nprivate fun durationOfMillis(normalMillis: Long) = Duration((normalMillis shl 1) + 1)\nprivate fun durationOf(normalValue: Long, unitDiscriminator: Int) = Duration((normalValue shl 1) + unitDiscriminator)\nprivate fun durationOfNanosNormalized(nanos: Long) =\n    if (nanos in -MAX_NANOS..MAX_NANOS) {\n        durationOfNanos(nanos)\n    } else {\n        durationOfMillis(nanosToMillis(nanos))\n    }\n\nprivate fun durationOfMillisNormalized(millis: Long) =\n    if (millis in -MAX_NANOS_IN_MILLIS..MAX_NANOS_IN_MILLIS) {\n        durationOfNanos(millisToNanos(millis))\n    } else {\n        durationOfMillis(millis.coerceIn(-MAX_MILLIS, MAX_MILLIS))\n    }\n\ninternal expect val durationAssertionsEnabled: Boolean\n\ninternal expect fun formatToExactDecimals(value: Double, decimals: Int): String\ninternal expect fun formatUpToDecimals(value: Double, decimals: Int): String\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:kotlin.jvm.JvmName(\"UnsignedKt\")\npackage kotlin\n\n@PublishedApi\ninternal fun uintCompare(v1: Int, v2: Int): Int = (v1 xor Int.MIN_VALUE).compareTo(v2 xor Int.MIN_VALUE)\n@PublishedApi\ninternal fun ulongCompare(v1: Long, v2: Long): Int = (v1 xor Long.MIN_VALUE).compareTo(v2 xor Long.MIN_VALUE)\n\n@PublishedApi\ninternal fun uintDivide(v1: UInt, v2: UInt): UInt = (v1.toLong() / v2.toLong()).toUInt()\n@PublishedApi\ninternal fun uintRemainder(v1: UInt, v2: UInt): UInt = (v1.toLong() % v2.toLong()).toUInt()\n\n// Division and remainder are based on Guava's UnsignedLongs implementation\n// Copyright 2011 The Guava Authors\n\n@PublishedApi\ninternal fun ulongDivide(v1: ULong, v2: ULong): ULong {\n    val dividend = v1.toLong()\n    val divisor = v2.toLong()\n    if (divisor < 0) { // i.e., divisor >= 2^63:\n        return if (v1 < v2) ULong(0) else ULong(1)\n    }\n\n    // Optimization - use signed division if both dividend and divisor < 2^63\n    if (dividend >= 0) {\n        return ULong(dividend / divisor)\n    }\n\n    // Otherwise, approximate the quotient, check, and correct if necessary.\n    val quotient = ((dividend ushr 1) / divisor) shl 1\n    val rem = dividend - quotient * divisor\n    return ULong(quotient + if (ULong(rem) >= ULong(divisor)) 1 else 0)\n\n}\n\n@PublishedApi\ninternal fun ulongRemainder(v1: ULong, v2: ULong): ULong {\n    val dividend = v1.toLong()\n    val divisor = v2.toLong()\n    if (divisor < 0) { // i.e., divisor >= 2^63:\n        return if (v1 < v2) {\n            v1 // dividend < divisor\n        } else {\n            v1 - v2 // dividend >= divisor\n        }\n    }\n\n    // Optimization - use signed modulus if both dividend and divisor < 2^63\n    if (dividend >= 0) {\n        return ULong(dividend % divisor)\n    }\n\n    // Otherwise, approximate the quotient, check, and correct if necessary.\n    val quotient = ((dividend ushr 1) / divisor) shl 1\n    val rem = dividend - quotient * divisor\n    return ULong(rem - if (ULong(rem) >= ULong(divisor)) divisor else 0)\n}\n\n@PublishedApi\ninternal fun doubleToUInt(v: Double): UInt = when {\n    v.isNaN() -> 0u\n    v <= UInt.MIN_VALUE.toDouble() -> UInt.MIN_VALUE\n    v >= UInt.MAX_VALUE.toDouble() -> UInt.MAX_VALUE\n    v <= Int.MAX_VALUE -> v.toInt().toUInt()\n    else -> (v - Int.MAX_VALUE).toInt().toUInt() + Int.MAX_VALUE.toUInt()      // Int.MAX_VALUE < v < UInt.MAX_VALUE\n}\n\n@PublishedApi\ninternal fun doubleToULong(v: Double): ULong = when {\n    v.isNaN() -> 0u\n    v <= ULong.MIN_VALUE.toDouble() -> ULong.MIN_VALUE\n    v >= ULong.MAX_VALUE.toDouble() -> ULong.MAX_VALUE\n    v < Long.MAX_VALUE -> v.toLong().toULong()\n\n    // Real values from Long.MAX_VALUE to (Long.MAX_VALUE + 1) are not representable in Double, so don't handle them.\n    else -> (v - 9223372036854775808.0).toLong().toULong() + 9223372036854775808uL      // Long.MAX_VALUE + 1 < v < ULong.MAX_VALUE\n}\n\n\n@PublishedApi\ninternal fun uintToDouble(v: Int): Double = (v and Int.MAX_VALUE).toDouble() + (v ushr 31 shl 30).toDouble() * 2\n\n@PublishedApi\ninternal fun ulongToDouble(v: Long): Double = (v ushr 11).toDouble() * 2048 + (v and 2047)\n\n\ninternal fun ulongToString(v: Long): String = ulongToString(v, 10)\n\ninternal fun ulongToString(v: Long, base: Int): String {\n    if (v >= 0) return v.toString(base)\n\n    var quotient = ((v ushr 1) / base) shl 1\n    var rem = v - quotient * base\n    if (rem >= base) {\n        rem -= base\n        quotient += 1\n    }\n    return quotient.toString(base) + rem.toString(base)\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED\n\n@SinceKotlin(\"1.3\")\n@JsName(\"CoroutineImpl\")\ninternal abstract class CoroutineImpl(private val resultContinuation: Continuation<Any?>) : Continuation<Any?> {\n    protected var state = 0\n    protected var exceptionState = 0\n    protected var result: Any? = null\n    protected var exception: Throwable? = null\n    protected var finallyPath: Array<Int>? = null\n\n    public override val context: CoroutineContext = resultContinuation.context\n\n    private var intercepted_: Continuation<Any?>? = null\n\n    public fun intercepted(): Continuation<Any?> =\n        intercepted_\n            ?: (context[ContinuationInterceptor]?.interceptContinuation(this) ?: this)\n                .also { intercepted_ = it }\n\n    override fun resumeWith(result: Result<Any?>) {\n        var current = this\n        var currentResult: Any? = result.getOrNull()\n        var currentException: Throwable? = result.exceptionOrNull()\n\n        // This loop unrolls recursion in current.resumeWith(param) to make saner and shorter stack traces on resume\n        while (true) {\n            with(current) {\n                val completion = resultContinuation\n\n                // Set result and exception fields in the current continuation\n                if (currentException == null) {\n                    this.result = currentResult\n                } else {\n                    state = exceptionState\n                    exception = currentException\n                }\n\n                try {\n                    val outcome = doResume()\n                    if (outcome === COROUTINE_SUSPENDED) return\n                    currentResult = outcome\n                    currentException = null\n                } catch (exception: dynamic) { // Catch all exceptions\n                    currentResult = null\n                    currentException = exception.unsafeCast<Throwable>()\n                }\n\n                releaseIntercepted() // this state machine instance is terminating\n\n                if (completion is CoroutineImpl) {\n                    // unrolling recursion via loop\n                    current = completion\n                } else {\n                    // top-level completion reached -- invoke and return\n                    currentException?.let {\n                        completion.resumeWithException(it)\n                    } ?: completion.resume(currentResult)\n                    return\n                }\n            }\n        }\n    }\n\n    private fun releaseIntercepted() {\n        val intercepted = intercepted_\n        if (intercepted != null && intercepted !== this) {\n            context[ContinuationInterceptor]!!.releaseInterceptedContinuation(intercepted)\n        }\n        this.intercepted_ = CompletedContinuation // just in case\n    }\n\n    protected abstract fun doResume(): Any?\n}\n\ninternal object CompletedContinuation : Continuation<Any?> {\n    override val context: CoroutineContext\n        get() = error(\"This continuation is already complete\")\n\n    override fun resumeWith(result: Result<Any?>) {\n        error(\"This continuation is already complete\")\n    }\n\n    override fun toString(): String = \"This continuation is already complete\"\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:Suppress(\"UNCHECKED_CAST\", \"RedundantVisibilityModifier\")\n\npackage kotlin\n\nimport kotlin.contracts.*\nimport kotlin.internal.InlineOnly\nimport kotlin.jvm.JvmField\nimport kotlin.jvm.JvmInline\nimport kotlin.jvm.JvmName\n\n/**\n * A discriminated union that encapsulates a successful outcome with a value of type [T]\n * or a failure with an arbitrary [Throwable] exception.\n */\n@SinceKotlin(\"1.3\")\n@JvmInline\npublic value class Result<out T> @PublishedApi internal constructor(\n    @PublishedApi\n    internal val value: Any?\n) : Serializable {\n    // discovery\n\n    /**\n     * Returns `true` if this instance represents a successful outcome.\n     * In this case [isFailure] returns `false`.\n     */\n    public val isSuccess: Boolean get() = value !is Failure\n\n    /**\n     * Returns `true` if this instance represents a failed outcome.\n     * In this case [isSuccess] returns `false`.\n     */\n    public val isFailure: Boolean get() = value is Failure\n\n    // value & exception retrieval\n\n    /**\n     * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or `null`\n     * if it is [failure][Result.isFailure].\n     *\n     * This function is a shorthand for `getOrElse { null }` (see [getOrElse]) or\n     * `fold(onSuccess = { it }, onFailure = { null })` (see [fold]).\n     */\n    @InlineOnly\n    public inline fun getOrNull(): T? =\n        when {\n            isFailure -> null\n            else -> value as T\n        }\n\n    /**\n     * Returns the encapsulated [Throwable] exception if this instance represents [failure][isFailure] or `null`\n     * if it is [success][isSuccess].\n     *\n     * This function is a shorthand for `fold(onSuccess = { null }, onFailure = { it })` (see [fold]).\n     */\n    public fun exceptionOrNull(): Throwable? =\n        when (value) {\n            is Failure -> value.exception\n            else -> null\n        }\n\n    /**\n     * Returns a string `Success(v)` if this instance represents [success][Result.isSuccess]\n     * where `v` is a string representation of the value or a string `Failure(x)` if\n     * it is [failure][isFailure] where `x` is a string representation of the exception.\n     */\n    public override fun toString(): String =\n        when (value) {\n            is Failure -> value.toString() // \"Failure($exception)\"\n            else -> \"Success($value)\"\n        }\n\n    // companion with constructors\n\n    /**\n     * Companion object for [Result] class that contains its constructor functions\n     * [success] and [failure].\n     */\n    public companion object {\n        /**\n         * Returns an instance that encapsulates the given [value] as successful value.\n         */\n        @Suppress(\"INAPPLICABLE_JVM_NAME\")\n        @InlineOnly\n        @JvmName(\"success\")\n        public inline fun <T> success(value: T): Result<T> =\n            Result(value)\n\n        /**\n         * Returns an instance that encapsulates the given [Throwable] [exception] as failure.\n         */\n        @Suppress(\"INAPPLICABLE_JVM_NAME\")\n        @InlineOnly\n        @JvmName(\"failure\")\n        public inline fun <T> failure(exception: Throwable): Result<T> =\n            Result(createFailure(exception))\n    }\n\n    internal class Failure(\n        @JvmField\n        val exception: Throwable\n    ) : Serializable {\n        override fun equals(other: Any?): Boolean = other is Failure && exception == other.exception\n        override fun hashCode(): Int = exception.hashCode()\n        override fun toString(): String = \"Failure($exception)\"\n    }\n}\n\n/**\n * Creates an instance of internal marker [Result.Failure] class to\n * make sure that this class is not exposed in ABI.\n */\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun createFailure(exception: Throwable): Any =\n    Result.Failure(exception)\n\n/**\n * Throws exception if the result is failure. This internal function minimizes\n * inlined bytecode for [getOrThrow] and makes sure that in the future we can\n * add some exception-augmenting logic here (if needed).\n */\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun Result<*>.throwOnFailure() {\n    if (value is Result.Failure) throw value.exception\n}\n\n/**\n * Calls the specified function [block] and returns its encapsulated result if invocation was successful,\n * catching any [Throwable] exception that was thrown from the [block] function execution and encapsulating it as a failure.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R> runCatching(block: () -> R): Result<R> {\n    return try {\n        Result.success(block())\n    } catch (e: Throwable) {\n        Result.failure(e)\n    }\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its encapsulated result if invocation was successful,\n * catching any [Throwable] exception that was thrown from the [block] function execution and encapsulating it as a failure.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T, R> T.runCatching(block: T.() -> R): Result<R> {\n    return try {\n        Result.success(block())\n    } catch (e: Throwable) {\n        Result.failure(e)\n    }\n}\n\n// -- extensions ---\n\n/**\n * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or throws the encapsulated [Throwable] exception\n * if it is [failure][Result.isFailure].\n *\n * This function is a shorthand for `getOrElse { throw it }` (see [getOrElse]).\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T> Result<T>.getOrThrow(): T {\n    throwOnFailure()\n    return value as T\n}\n\n/**\n * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or the\n * result of [onFailure] function for the encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [onFailure] function.\n *\n * This function is a shorthand for `fold(onSuccess = { it }, onFailure = onFailure)` (see [fold]).\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.getOrElse(onFailure: (exception: Throwable) -> R): R {\n    contract {\n        callsInPlace(onFailure, InvocationKind.AT_MOST_ONCE)\n    }\n    return when (val exception = exceptionOrNull()) {\n        null -> value as T\n        else -> onFailure(exception)\n    }\n}\n\n/**\n * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or the\n * [defaultValue] if it is [failure][Result.isFailure].\n *\n * This function is a shorthand for `getOrElse { defaultValue }` (see [getOrElse]).\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.getOrDefault(defaultValue: R): R {\n    if (isFailure) return defaultValue\n    return value as T\n}\n\n/**\n * Returns the result of [onSuccess] for the encapsulated value if this instance represents [success][Result.isSuccess]\n * or the result of [onFailure] function for the encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [onSuccess] or by [onFailure] function.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T> Result<T>.fold(\n    onSuccess: (value: T) -> R,\n    onFailure: (exception: Throwable) -> R\n): R {\n    contract {\n        callsInPlace(onSuccess, InvocationKind.AT_MOST_ONCE)\n        callsInPlace(onFailure, InvocationKind.AT_MOST_ONCE)\n    }\n    return when (val exception = exceptionOrNull()) {\n        null -> onSuccess(value as T)\n        else -> onFailure(exception)\n    }\n}\n\n// transformation\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated value\n * if this instance represents [success][Result.isSuccess] or the\n * original encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [transform] function.\n * See [mapCatching] for an alternative that encapsulates exceptions.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T> Result<T>.map(transform: (value: T) -> R): Result<R> {\n    contract {\n        callsInPlace(transform, InvocationKind.AT_MOST_ONCE)\n    }\n    return when {\n        isSuccess -> Result.success(transform(value as T))\n        else -> Result(value)\n    }\n}\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated value\n * if this instance represents [success][Result.isSuccess] or the\n * original encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * This function catches any [Throwable] exception thrown by [transform] function and encapsulates it as a failure.\n * See [map] for an alternative that rethrows exceptions from `transform` function.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T> Result<T>.mapCatching(transform: (value: T) -> R): Result<R> {\n    return when {\n        isSuccess -> runCatching { transform(value as T) }\n        else -> Result(value)\n    }\n}\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated [Throwable] exception\n * if this instance represents [failure][Result.isFailure] or the\n * original encapsulated value if it is [success][Result.isSuccess].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [transform] function.\n * See [recoverCatching] for an alternative that encapsulates exceptions.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.recover(transform: (exception: Throwable) -> R): Result<R> {\n    contract {\n        callsInPlace(transform, InvocationKind.AT_MOST_ONCE)\n    }\n    return when (val exception = exceptionOrNull()) {\n        null -> this\n        else -> Result.success(transform(exception))\n    }\n}\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated [Throwable] exception\n * if this instance represents [failure][Result.isFailure] or the\n * original encapsulated value if it is [success][Result.isSuccess].\n *\n * This function catches any [Throwable] exception thrown by [transform] function and encapsulates it as a failure.\n * See [recover] for an alternative that rethrows exceptions.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.recoverCatching(transform: (exception: Throwable) -> R): Result<R> {\n    return when (val exception = exceptionOrNull()) {\n        null -> this\n        else -> runCatching { transform(exception) }\n    }\n}\n\n// \"peek\" onto value/exception and pipe\n\n/**\n * Performs the given [action] on the encapsulated [Throwable] exception if this instance represents [failure][Result.isFailure].\n * Returns the original `Result` unchanged.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T> Result<T>.onFailure(action: (exception: Throwable) -> Unit): Result<T> {\n    contract {\n        callsInPlace(action, InvocationKind.AT_MOST_ONCE)\n    }\n    exceptionOrNull()?.let { action(it) }\n    return this\n}\n\n/**\n * Performs the given [action] on the encapsulated value if this instance represents [success][Result.isSuccess].\n * Returns the original `Result` unchanged.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T> Result<T>.onSuccess(action: (value: T) -> Unit): Result<T> {\n    contract {\n        callsInPlace(action, InvocationKind.AT_MOST_ONCE)\n    }\n    if (isSuccess) action(value as T)\n    return this\n}\n\n// -------------------\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.contracts.*\nimport kotlin.coroutines.intrinsics.*\nimport kotlin.internal.InlineOnly\n\n/**\n * Interface representing a continuation after a suspension point that returns a value of type `T`.\n */\n@SinceKotlin(\"1.3\")\npublic interface Continuation<in T> {\n    /**\n     * The context of the coroutine that corresponds to this continuation.\n     */\n    public val context: CoroutineContext\n\n    /**\n     * Resumes the execution of the corresponding coroutine passing a successful or failed [result] as the\n     * return value of the last suspension point.\n     */\n    public fun resumeWith(result: Result<T>)\n}\n\n/**\n * Classes and interfaces marked with this annotation are restricted when used as receivers for extension\n * `suspend` functions. These `suspend` extensions can only invoke other member or extension `suspend` functions on this particular\n * receiver and are restricted from calling arbitrary suspension functions.\n */\n@SinceKotlin(\"1.3\")\n@Target(AnnotationTarget.CLASS)\n@Retention(AnnotationRetention.BINARY)\npublic annotation class RestrictsSuspension\n\n/**\n * Resumes the execution of the corresponding coroutine passing [value] as the return value of the last suspension point.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun <T> Continuation<T>.resume(value: T): Unit =\n    resumeWith(Result.success(value))\n\n/**\n * Resumes the execution of the corresponding coroutine so that the [exception] is re-thrown right after the\n * last suspension point.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun <T> Continuation<T>.resumeWithException(exception: Throwable): Unit =\n    resumeWith(Result.failure(exception))\n\n\n/**\n * Creates a [Continuation] instance with the given [context] and implementation of [resumeWith] method.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun <T> Continuation(\n    context: CoroutineContext,\n    crossinline resumeWith: (Result<T>) -> Unit\n): Continuation<T> =\n    object : Continuation<T> {\n        override val context: CoroutineContext\n            get() = context\n\n        override fun resumeWith(result: Result<T>) =\n            resumeWith(result)\n    }\n\n/**\n * Creates a coroutine without a receiver and with result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n * Subsequent invocation of any resume function on the resulting continuation will produce an [IllegalStateException].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <T> (suspend () -> T).createCoroutine(\n    completion: Continuation<T>\n): Continuation<Unit> =\n    SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED)\n\n/**\n * Creates a coroutine with receiver type [R] and result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n * Subsequent invocation of any resume function on the resulting continuation will produce an [IllegalStateException].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <R, T> (suspend R.() -> T).createCoroutine(\n    receiver: R,\n    completion: Continuation<T>\n): Continuation<Unit> =\n    SafeContinuation(createCoroutineUnintercepted(receiver, completion).intercepted(), COROUTINE_SUSPENDED)\n\n/**\n * Starts a coroutine without a receiver and with result type [T].\n * This function creates and starts a new, fresh instance of suspendable computation every time it is invoked.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <T> (suspend () -> T).startCoroutine(\n    completion: Continuation<T>\n) {\n    createCoroutineUnintercepted(completion).intercepted().resume(Unit)\n}\n\n/**\n * Starts a coroutine with receiver type [R] and result type [T].\n * This function creates and starts a new, fresh instance of suspendable computation every time it is invoked.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <R, T> (suspend R.() -> T).startCoroutine(\n    receiver: R,\n    completion: Continuation<T>\n) {\n    createCoroutineUnintercepted(receiver, completion).intercepted().resume(Unit)\n}\n\n/**\n * Obtains the current continuation instance inside suspend functions and suspends\n * the currently running coroutine.\n *\n * In this function both [Continuation.resume] and [Continuation.resumeWithException] can be used either synchronously in\n * the same stack-frame where the suspension function is run or asynchronously later in the same thread or\n * from a different thread of execution. Subsequent invocation of any resume function will produce an [IllegalStateException].\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic suspend inline fun <T> suspendCoroutine(crossinline block: (Continuation<T>) -> Unit): T {\n    contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }\n    return suspendCoroutineUninterceptedOrReturn { c: Continuation<T> ->\n        val safe = SafeContinuation(c.intercepted())\n        block(safe)\n        safe.getOrThrow()\n    }\n}\n\n/**\n * Returns the context of the current coroutine.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"WRONG_MODIFIER_TARGET\")\n@InlineOnly\npublic suspend inline val coroutineContext: CoroutineContext\n    get() {\n        throw NotImplementedError(\"Implemented as intrinsic\")\n    }\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n// NOTE: Do not author your exceptions as they are written in this file, instead use this template:\n/*\npublic open class MyException : Exception {\n    constructor() : super()\n    constructor(message: String?) : super(message)\n    constructor(message: String?, cause: Throwable?) : super(message, cause)\n    constructor(cause: Throwable?) : super(cause)\n}\n*/\n\n\n// TODO: remove primary constructors, make all secondary KT-22055\n\n@Suppress(\"USELESS_ELVIS_RIGHT_IS_NULL\")\npublic actual open class Error actual constructor(message: String?, cause: Throwable?) : Throwable(message, cause ?: null) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\n@Suppress(\"USELESS_ELVIS_RIGHT_IS_NULL\")\npublic actual open class Exception actual constructor(message: String?, cause: Throwable?) : Throwable(message, cause ?: null) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class RuntimeException actual constructor(message: String?, cause: Throwable?) : Exception(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class IllegalArgumentException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class IllegalStateException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class IndexOutOfBoundsException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\npublic actual open class ConcurrentModificationException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class UnsupportedOperationException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\n\npublic actual open class NumberFormatException actual constructor(message: String?) : IllegalArgumentException(message) {\n    actual constructor() : this(null)\n}\n\n\npublic actual open class NullPointerException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\npublic actual open class ClassCastException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\npublic actual open class AssertionError\n@SinceKotlin(\"1.4\")\nconstructor(message: String?, cause: Throwable?) : Error(message, cause) {\n    actual constructor() : this(null)\n    constructor(message: String?) : this(message, null)\n    actual constructor(message: Any?) : this(message.toString(), message as? Throwable)\n}\n\npublic actual open class NoSuchElementException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\n@SinceKotlin(\"1.3\")\npublic actual open class ArithmeticException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\npublic actual open class NoWhenBranchMatchedException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class UninitializedPropertyAccessException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.io\n\ninternal abstract class BaseOutput {\n    open fun println() {\n        print(\"\\n\")\n    }\n\n    open fun println(message: Any?) {\n        print(message)\n        println()\n    }\n\n    abstract fun print(message: Any?)\n\n    open fun flush() {}\n}\n\n/** JsName used to make the declaration available outside of module to test it */\n@JsName(\"NodeJsOutput\")\ninternal class NodeJsOutput(val outputStream: dynamic) : BaseOutput() {\n    override fun print(message: Any?) {\n        // TODO: Using local variable because of bug in block decomposition lowering in IR backend\n        val messageString = String(message)\n        outputStream.write(messageString)\n    }\n}\n\n/** JsName used to make the declaration available outside of module to test it */\n@JsName(\"OutputToConsoleLog\")\ninternal class OutputToConsoleLog : BaseOutput() {\n    override fun print(message: Any?) {\n        console.log(message)\n    }\n\n    override fun println(message: Any?) {\n        console.log(message)\n    }\n\n    override fun println() {\n        console.log(\"\")\n    }\n}\n\n/** JsName used to make the declaration available outside of module to test it and use at try.kotl.in */\n@JsName(\"BufferedOutput\")\ninternal open class BufferedOutput : BaseOutput() {\n    var buffer = \"\"\n\n    override fun print(message: Any?) {\n        buffer += String(message)\n    }\n\n    override fun flush() {\n        buffer = \"\"\n    }\n}\n\n/** JsName used to make the declaration available outside of module to test it */\n@JsName(\"BufferedOutputToConsoleLog\")\ninternal class BufferedOutputToConsoleLog : BufferedOutput() {\n    override fun print(message: Any?) {\n        var s = String(message)\n        val i = s.nativeLastIndexOf(\"\\n\", 0)\n        if (i >= 0) {\n            buffer += s.substring(0, i)\n            flush()\n            s = s.substring(i + 1)\n        }\n        buffer += s\n    }\n\n    override fun flush() {\n        console.log(buffer)\n        buffer = \"\"\n    }\n}\n\n/** JsName used to make the declaration available outside of module to test it and use at try.kotl.in */\n@JsName(\"output\")\ninternal var output = run {\n    val isNode: Boolean = js(\"typeof process !== 'undefined' && process.versions && !!process.versions.node\")\n    if (isNode) NodeJsOutput(js(\"process.stdout\")) else BufferedOutputToConsoleLog()\n}\n\n@kotlin.internal.InlineOnly\nprivate inline fun String(value: Any?): String = js(\"String\")(value)\n\n/** Prints the line separator to the standard output stream. */\npublic actual fun println() {\n    output.println()\n}\n\n/** Prints the given [message] and the line separator to the standard output stream. */\npublic actual fun println(message: Any?) {\n    output.println(message)\n}\n\n/** Prints the given [message] to the standard output stream. */\npublic actual fun print(message: Any?) {\n    output.print(message)\n}\n\n@SinceKotlin(\"1.6\")\npublic actual fun readln(): String = throw UnsupportedOperationException(\"readln is not supported in Kotlin/JS\")\n\n@SinceKotlin(\"1.6\")\npublic actual fun readlnOrNull(): String? = throw UnsupportedOperationException(\"readlnOrNull is not supported in Kotlin/JS\")","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.coroutines.intrinsics.CoroutineSingletons.*\nimport kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal actual class SafeContinuation<in T>\ninternal actual constructor(\n    private val delegate: Continuation<T>,\n    initialResult: Any?\n) : Continuation<T> {\n    @PublishedApi\n    internal actual constructor(delegate: Continuation<T>) : this(delegate, UNDECIDED)\n\n    public actual override val context: CoroutineContext\n        get() = delegate.context\n\n    private var result: Any? = initialResult\n\n    public actual override fun resumeWith(result: Result<T>) {\n        val cur = this.result\n        when {\n            cur === UNDECIDED -> {\n                this.result = result.value\n            }\n            cur === COROUTINE_SUSPENDED -> {\n                this.result = RESUMED\n                delegate.resumeWith(result)\n            }\n            else -> throw IllegalStateException(\"Already resumed\")\n        }\n    }\n\n    @PublishedApi\n    internal actual fun getOrThrow(): Any? {\n        if (result === UNDECIDED) {\n            result = COROUTINE_SUSPENDED\n            return COROUTINE_SUSPENDED\n        }\n        val result = this.result\n        return when {\n            result === RESUMED -> COROUTINE_SUSPENDED // already called continuation, indicate COROUTINE_SUSPENDED upstream\n            result is Result.Failure -> throw result.exception\n            else -> result // either COROUTINE_SUSPENDED or data\n        }\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// a package is omitted to get declarations directly under the module\n\n@JsName(\"throwNPE\")\ninternal fun throwNPE(message: String) {\n    throw NullPointerException(message)\n}\n\n@JsName(\"throwCCE\")\ninternal fun throwCCE() {\n    throw ClassCastException(\"Illegal cast\")\n}\n\n@JsName(\"throwISE\")\ninternal fun throwISE(message: String) {\n    throw IllegalStateException(message)\n}\n\n@JsName(\"throwUPAE\")\ninternal fun throwUPAE(propertyName: String) {\n    throw UninitializedPropertyAccessException(\"lateinit property ${propertyName} has not been initialized\")\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n */\n@Deprecated(\"Use lowercaseChar() instead.\", ReplaceWith(\"lowercaseChar()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.toLowerCase(): Char = lowercaseChar()\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [lowercase] function.\n * If this character has no mapping equivalent, the character itself is returned.\n *\n * @sample samples.text.Chars.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.lowercaseChar(): Char = lowercase()[0]\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\u0130'.lowercase()` returns `\"\\u0069\\u0307\"`,\n * where `'\\u0130'` is the LATIN CAPITAL LETTER I WITH DOT ABOVE character (`İ`).\n * If this character has no lower case mapping, the result of `toString()` of this char is returned.\n *\n * @sample samples.text.Chars.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.lowercase(): String = toString().asDynamic().toLowerCase().unsafeCast<String>()\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n */\n@Deprecated(\"Use uppercaseChar() instead.\", ReplaceWith(\"uppercaseChar()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.toUpperCase(): Char = uppercaseChar()\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [uppercase] function.\n * If this character has no mapping equivalent, the character itself is returned.\n *\n * @sample samples.text.Chars.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Char.uppercaseChar(): Char {\n    val uppercase = uppercase()\n    return if (uppercase.length > 1) this else uppercase[0]\n}\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\uFB00'.uppercase()` returns `\"\\u0046\\u0046\"`,\n * where `'\\uFB00'` is the LATIN SMALL LIGATURE FF character (`ﬀ`).\n * If this character has no upper case mapping, the result of `toString()` of this char is returned.\n *\n * @sample samples.text.Chars.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.uppercase(): String = toString().asDynamic().toUpperCase().unsafeCast<String>()\n\n/**\n * Converts this character to title case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [titlecase] function.\n * If this character has no mapping equivalent, the result of calling [uppercaseChar] is returned.\n *\n * @sample samples.text.Chars.titlecase\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.titlecaseChar(): Char = titlecaseCharImpl()\n\n/**\n * Returns `true` if this character is a Unicode high-surrogate code unit (also known as leading-surrogate code unit).\n */\npublic actual fun Char.isHighSurrogate(): Boolean = this in Char.MIN_HIGH_SURROGATE..Char.MAX_HIGH_SURROGATE\n\n/**\n * Returns `true` if this character is a Unicode low-surrogate code unit (also known as trailing-surrogate code unit).\n */\npublic actual fun Char.isLowSurrogate(): Boolean = this in Char.MIN_LOW_SURROGATE..Char.MAX_LOW_SURROGATE\n\n/**\n * Returns the Unicode general category of this character.\n */\n@SinceKotlin(\"1.5\")\npublic actual val Char.category: CharCategory\n    get() = CharCategory.valueOf(getCategoryValue())\n\n/**\n * Returns `true` if this character (Unicode code point) is defined in Unicode.\n *\n * A character is considered to be defined in Unicode if its [category] is not [CharCategory.UNASSIGNED].\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isDefined(): Boolean {\n    if (this < '\\u0080') {\n        return true\n    }\n    return getCategoryValue() != CharCategory.UNASSIGNED.value\n}\n\n/**\n * Returns `true` if this character is a letter.\n *\n * A character is considered to be a letter if its [category] is [CharCategory.UPPERCASE_LETTER],\n * [CharCategory.LOWERCASE_LETTER], [CharCategory.TITLECASE_LETTER], [CharCategory.MODIFIER_LETTER], or [CharCategory.OTHER_LETTER].\n *\n * @sample samples.text.Chars.isLetter\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isLetter(): Boolean {\n    if (this in 'a'..'z' || this in 'A'..'Z') {\n        return true\n    }\n    if (this < '\\u0080') {\n        return false\n    }\n    return isLetterImpl()\n}\n\n/**\n * Returns `true` if this character is a letter or digit.\n *\n * @see isLetter\n * @see isDigit\n *\n * @sample samples.text.Chars.isLetterOrDigit\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isLetterOrDigit(): Boolean {\n    if (this in 'a'..'z' || this in 'A'..'Z' || this in '0'..'9') {\n        return true\n    }\n    if (this < '\\u0080') {\n        return false\n    }\n\n    return isDigitImpl() || isLetterImpl()\n}\n\n/**\n * Returns `true` if this character is a digit.\n *\n * A character is considered to be a digit if its [category] is [CharCategory.DECIMAL_DIGIT_NUMBER].\n *\n * @sample samples.text.Chars.isDigit\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isDigit(): Boolean {\n    if (this in '0'..'9') {\n        return true\n    }\n    if (this < '\\u0080') {\n        return false\n    }\n    return isDigitImpl()\n}\n\n/**\n * Returns `true` if this character is upper case.\n *\n * A character is considered to be an upper case character if its [category] is [CharCategory.UPPERCASE_LETTER],\n * or it has contributory property `Other_Uppercase` as defined by the Unicode Standard.\n *\n * @sample samples.text.Chars.isUpperCase\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isUpperCase(): Boolean {\n    if (this in 'A'..'Z') {\n        return true\n    }\n    if (this < '\\u0080') {\n        return false\n    }\n    return isUpperCaseImpl()\n}\n\n/**\n * Returns `true` if this character is lower case.\n *\n * A character is considered to be a lower case character if its [category] is [CharCategory.LOWERCASE_LETTER],\n * or it has contributory property `Other_Lowercase` as defined by the Unicode Standard.\n *\n * @sample samples.text.Chars.isLowerCase\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isLowerCase(): Boolean {\n    if (this in 'a'..'z') {\n        return true\n    }\n    if (this < '\\u0080') {\n        return false\n    }\n    return isLowerCaseImpl()\n}\n\n/**\n * Returns `true` if this character is a title case letter.\n *\n * A character is considered to be a title case letter if its [category] is [CharCategory.TITLECASE_LETTER].\n *\n * @sample samples.text.Chars.isTitleCase\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isTitleCase(): Boolean {\n    if (this < '\\u0080') {\n        return false\n    }\n    return getCategoryValue() == CharCategory.TITLECASE_LETTER.value\n}\n\n/**\n * Returns `true` if this character is an ISO control character.\n *\n * A character is considered to be an ISO control character if its [category] is [CharCategory.CONTROL],\n * meaning the Char is in the range `'\\u0000'..'\\u001F'` or in the range `'\\u007F'..'\\u009F'`.\n *\n * @sample samples.text.Chars.isISOControl\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isISOControl(): Boolean {\n    return this <= '\\u001F' || this in '\\u007F'..'\\u009F'\n}\n\n/**\n * Determines whether a character is whitespace according to the Unicode standard.\n * Returns `true` if the character is whitespace.\n *\n * @sample samples.text.Chars.isWhitespace\n */\npublic actual fun Char.isWhitespace(): Boolean = isWhitespaceImpl()","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n/**\n * Converts the characters in the specified array to a string.\n */\n@SinceKotlin(\"1.2\")\n@Deprecated(\"Use CharArray.concatToString() instead\", ReplaceWith(\"chars.concatToString()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic actual fun String(chars: CharArray): String {\n    var result = \"\"\n    for (char in chars) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Converts the characters from a portion of the specified array to a string.\n *\n * @throws IndexOutOfBoundsException if either [offset] or [length] are less than zero\n * or `offset + length` is out of [chars] array bounds.\n */\n@SinceKotlin(\"1.2\")\n@Deprecated(\"Use CharArray.concatToString(startIndex, endIndex) instead\", ReplaceWith(\"chars.concatToString(offset, offset + length)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic actual fun String(chars: CharArray, offset: Int, length: Int): String {\n    if (offset < 0 || length < 0 || chars.size - offset < length)\n        throw IndexOutOfBoundsException(\"size: ${chars.size}; offset: $offset; length: $length\")\n    var result = \"\"\n    for (index in offset until offset + length) {\n        result += chars[index]\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] into a String.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun CharArray.concatToString(): String {\n    var result = \"\"\n    for (char in this) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] or its subrange into a String.\n *\n * @param startIndex the beginning (inclusive) of the subrange of characters, 0 by default.\n * @param endIndex the end (exclusive) of the subrange of characters, size of this array by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharArray.concatToString(startIndex: Int = 0, endIndex: Int = this.size): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    var result = \"\"\n    for (index in startIndex until endIndex) {\n        result += this[index]\n    }\n    return result\n}\n\n/**\n * Returns a [CharArray] containing characters of this string.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun String.toCharArray(): CharArray {\n    return CharArray(length) { get(it) }\n}\n\n/**\n * Returns a [CharArray] containing characters of this string or its substring.\n *\n * @param startIndex the beginning (inclusive) of the substring, 0 by default.\n * @param endIndex the end (exclusive) of the substring, length of this string by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.toCharArray(startIndex: Int = 0, endIndex: Int = this.length): CharArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return CharArray(endIndex - startIndex) { get(startIndex + it) }\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array.\n *\n * Malformed byte sequences are replaced by the replacement char `\\uFFFD`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun ByteArray.decodeToString(): String {\n    return decodeUtf8(this, 0, size, false)\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array or its subrange.\n *\n * @param startIndex the beginning (inclusive) of the subrange to decode, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to decode, size of this array by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed byte sequence or replace it by the replacement char `\\uFFFD`.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if the byte array contains malformed UTF-8 byte sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ByteArray.decodeToString(\n    startIndex: Int = 0,\n    endIndex: Int = this.size,\n    throwOnInvalidSequence: Boolean = false\n): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    return decodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Encodes this string to an array of bytes in UTF-8 encoding.\n *\n * Any malformed char sequence is replaced by the replacement byte sequence.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun String.encodeToByteArray(): ByteArray {\n    return encodeUtf8(this, 0, length, false)\n}\n\n/**\n * Encodes this string or its substring to an array of bytes in UTF-8 encoding.\n *\n * @param startIndex the beginning (inclusive) of the substring to encode, 0 by default.\n * @param endIndex the end (exclusive) of the substring to encode, length of this string by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed char sequence or replace.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if this string contains malformed char sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.encodeToByteArray(\n    startIndex: Int = 0,\n    endIndex: Int = this.length,\n    throwOnInvalidSequence: Boolean = false\n): ByteArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return encodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n */\n@Deprecated(\"Use uppercase() instead.\", ReplaceWith(\"uppercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toUpperCase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun String.uppercase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n */\n@Deprecated(\"Use lowercase() instead.\", ReplaceWith(\"lowercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toLowerCase(): String = asDynamic().toLowerCase()\n\n/**\n * Returns a copy of this string converted to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun String.lowercase(): String = asDynamic().toLowerCase()\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeIndexOf(str: String, fromIndex: Int): Int = asDynamic().indexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeLastIndexOf(str: String, fromIndex: Int): Int = asDynamic().lastIndexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\n@kotlin.js.JsPolyfill(\"\"\"\nif (typeof String.prototype.startsWith === \"undefined\") {\n    Object.defineProperty(String.prototype, \"startsWith\", {\n        value: function (searchString, position) {\n            position = position || 0;\n            return this.lastIndexOf(searchString, position) === position;\n        }\n    });\n}\n\"\"\")\ninternal inline fun String.nativeStartsWith(s: String, position: Int): Boolean = asDynamic().startsWith(s, position)\n\n@kotlin.internal.InlineOnly\n@kotlin.js.JsPolyfill(\"\"\"\nif (typeof String.prototype.endsWith === \"undefined\") {\n    Object.defineProperty(String.prototype, \"endsWith\", {\n        value: function (searchString, position) {\n            var subjectString = this.toString();\n            if (position === undefined || position > subjectString.length) {\n                position = subjectString.length;\n            }\n            position -= searchString.length;\n            var lastIndex = subjectString.indexOf(searchString, position);\n            return lastIndex !== -1 && lastIndex === position;\n        }\n    });\n}\n\"\"\")\ninternal inline fun String.nativeEndsWith(s: String): Boolean = asDynamic().endsWith(s)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int): String = asDynamic().substring(startIndex)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int, endIndex: Int): String = asDynamic().substring(startIndex, endIndex)\n\n@Deprecated(\"Use String.plus() instead\", ReplaceWith(\"this + str\"))\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\n@kotlin.internal.InlineOnly\npublic inline fun String.concat(str: String): String = asDynamic().concat(str)\n\n@Deprecated(\"Use Regex.findAll() instead or invoke matches() on String dynamically: this.asDynamic().match(regex)\")\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\n@kotlin.internal.InlineOnly\npublic inline fun String.match(regex: String): Array<String>? = asDynamic().match(regex)\n\n//native public fun String.trim(): String\n//TODO: String.replace to implement effective trimLeading and trimTrailing\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeReplace(pattern: RegExp, replacement: String): String = asDynamic().replace(pattern, replacement)\n\n/**\n * Compares two strings lexicographically, optionally ignoring case differences.\n *\n * If [ignoreCase] is true, the result of `Char.uppercaseChar().lowercaseChar()` on each character is compared.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.compareTo(other: String, ignoreCase: Boolean = false): Int {\n    if (ignoreCase) {\n        val n1 = this.length\n        val n2 = other.length\n        val min = minOf(n1, n2)\n        if (min == 0) return n1 - n2\n        for (index in 0 until min) {\n            var thisChar = this[index]\n            var otherChar = other[index]\n\n            if (thisChar != otherChar) {\n                thisChar = thisChar.uppercaseChar()\n                otherChar = otherChar.uppercaseChar()\n\n                if (thisChar != otherChar) {\n                    thisChar = thisChar.lowercaseChar()\n                    otherChar = otherChar.lowercaseChar()\n\n                    if (thisChar != otherChar) {\n                        return thisChar.compareTo(otherChar)\n                    }\n                }\n            }\n        }\n        return n1 - n2\n    } else {\n        return compareTo(other)\n    }\n}\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other],\n * i.e. both char sequences contain the same number of the same characters in the same order.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic actual infix fun CharSequence?.contentEquals(other: CharSequence?): Boolean = contentEqualsImpl(other)\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other], optionally ignoring case difference.\n *\n * @param ignoreCase `true` to ignore character case when comparing contents.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic actual fun CharSequence?.contentEquals(other: CharSequence?, ignoreCase: Boolean): Boolean {\n    return if (ignoreCase)\n        this.contentEqualsIgnoreCaseImpl(other)\n    else\n        this.contentEqualsImpl(other)\n}\n\n\nprivate val STRING_CASE_INSENSITIVE_ORDER = Comparator<String> { a, b -> a.compareTo(b, ignoreCase = true) }\n\n@SinceKotlin(\"1.2\")\npublic actual val String.Companion.CASE_INSENSITIVE_ORDER: Comparator<String>\n    get() = STRING_CASE_INSENSITIVE_ORDER\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.comparisons\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.js.*\n\n/**\n * Returns the greater of two values.\n * \n * If values are equal, returns the first one.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, b: T): T {\n    return if (a >= b) a else b\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Byte, b: Byte): Byte {\n    return maxOf(a.toInt(), b.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Short, b: Short): Short {\n    return maxOf(a.toInt(), b.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Int, b: Int): Int {\n    return JsMath.max(a, b)\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun maxOf(a: Long, b: Long): Long {\n    return if (a >= b) a else b\n}\n\n/**\n * Returns the greater of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Float, b: Float): Float {\n    return JsMath.max(a, b)\n}\n\n/**\n * Returns the greater of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Double, b: Double): Double {\n    return JsMath.max(a, b)\n}\n\n/**\n * Returns the greater of three values.\n * \n * If there are multiple equal maximal values, returns the first of them.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, b: T, c: T): T {\n    return maxOf(a, maxOf(b, c))\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Byte, b: Byte, c: Byte): Byte {\n    return JsMath.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Short, b: Short, c: Short): Short {\n    return JsMath.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Int, b: Int, c: Int): Int {\n    return JsMath.max(a, b, c)\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Long, b: Long, c: Long): Long {\n    return maxOf(a, maxOf(b, c))\n}\n\n/**\n * Returns the greater of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Float, b: Float, c: Float): Float {\n    return JsMath.max(a, b, c)\n}\n\n/**\n * Returns the greater of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Double, b: Double, c: Double): Double {\n    return JsMath.max(a, b, c)\n}\n\n/**\n * Returns the greater of the given values.\n * \n * If there are multiple equal maximal values, returns the first of them.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, vararg other: T): T {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Byte, vararg other: Byte): Byte {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Short, vararg other: Short): Short {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Int, vararg other: Int): Int {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Long, vararg other: Long): Long {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Float, vararg other: Float): Float {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Double, vararg other: Double): Double {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the smaller of two values.\n * \n * If values are equal, returns the first one.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> minOf(a: T, b: T): T {\n    return if (a <= b) a else b\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Byte, b: Byte): Byte {\n    return minOf(a.toInt(), b.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Short, b: Short): Short {\n    return minOf(a.toInt(), b.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Int, b: Int): Int {\n    return JsMath.min(a, b)\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun minOf(a: Long, b: Long): Long {\n    return if (a <= b) a else b\n}\n\n/**\n * Returns the smaller of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Float, b: Float): Float {\n    return JsMath.min(a, b)\n}\n\n/**\n * Returns the smaller of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Double, b: Double): Double {\n    return JsMath.min(a, b)\n}\n\n/**\n * Returns the smaller of three values.\n * \n * If there are multiple equal minimal values, returns the first of them.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> minOf(a: T, b: T, c: T): T {\n    return minOf(a, minOf(b, c))\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Byte, b: Byte, c: Byte): Byte {\n    return JsMath.min(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Short, b: Short, c: Short): Short {\n    return JsMath.min(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Int, b: Int, c: Int): Int {\n    return JsMath.min(a, b, c)\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Long, b: Long, c: Long): Long {\n    return minOf(a, minOf(b, c))\n}\n\n/**\n * Returns the smaller of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Float, b: Float, c: Float): Float {\n    return JsMath.min(a, b, c)\n}\n\n/**\n * Returns the smaller of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Double, b: Double, c: Double): Double {\n    return JsMath.min(a, b, c)\n}\n\n/**\n * Returns the smaller of the given values.\n * \n * If there are multiple equal minimal values, returns the first of them.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun <T : Comparable<T>> minOf(a: T, vararg other: T): T {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Byte, vararg other: Byte): Byte {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Short, vararg other: Short): Short {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Int, vararg other: Int): Int {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Long, vararg other: Long): Long {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Float, vararg other: Float): Float {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Double, vararg other: Double): Double {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.collections\n\n/** An iterator over a sequence of values of type `Byte`. */\npublic abstract class ByteIterator : Iterator<Byte> {\n    override final fun next() = nextByte()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextByte(): Byte\n}\n\n/** An iterator over a sequence of values of type `Char`. */\npublic abstract class CharIterator : Iterator<Char> {\n    override final fun next() = nextChar()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextChar(): Char\n}\n\n/** An iterator over a sequence of values of type `Short`. */\npublic abstract class ShortIterator : Iterator<Short> {\n    override final fun next() = nextShort()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextShort(): Short\n}\n\n/** An iterator over a sequence of values of type `Int`. */\npublic abstract class IntIterator : Iterator<Int> {\n    override final fun next() = nextInt()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextInt(): Int\n}\n\n/** An iterator over a sequence of values of type `Long`. */\npublic abstract class LongIterator : Iterator<Long> {\n    override final fun next() = nextLong()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextLong(): Long\n}\n\n/** An iterator over a sequence of values of type `Float`. */\npublic abstract class FloatIterator : Iterator<Float> {\n    override final fun next() = nextFloat()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextFloat(): Float\n}\n\n/** An iterator over a sequence of values of type `Double`. */\npublic abstract class DoubleIterator : Iterator<Double> {\n    override final fun next() = nextDouble()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextDouble(): Double\n}\n\n/** An iterator over a sequence of values of type `Boolean`. */\npublic abstract class BooleanIterator : Iterator<Boolean> {\n    override final fun next() = nextBoolean()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextBoolean(): Boolean\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\n/**\n * Marks coroutine context element that intercepts coroutine continuations.\n * The coroutines framework uses [ContinuationInterceptor.Key] to retrieve the interceptor and\n * intercepts all coroutine continuations with [interceptContinuation] invocations.\n *\n * [ContinuationInterceptor] behaves like a [polymorphic element][AbstractCoroutineContextKey], meaning that\n * its implementation delegates [get][CoroutineContext.Element.get] and [minusKey][CoroutineContext.Element.minusKey]\n * to [getPolymorphicElement] and [minusPolymorphicKey] respectively.\n * [ContinuationInterceptor] subtypes can be extracted from the coroutine context using either [ContinuationInterceptor.Key]\n * or subtype key if it extends [AbstractCoroutineContextKey].\n */\n@SinceKotlin(\"1.3\")\npublic interface ContinuationInterceptor : CoroutineContext.Element {\n    /**\n     * The key that defines *the* context interceptor.\n     */\n    companion object Key : CoroutineContext.Key<ContinuationInterceptor>\n\n    /**\n     * Returns continuation that wraps the original [continuation], thus intercepting all resumptions.\n     * This function is invoked by coroutines framework when needed and the resulting continuations are\n     * cached internally per each instance of the original [continuation].\n     *\n     * This function may simply return original [continuation] if it does not want to intercept this particular continuation.\n     *\n     * When the original [continuation] completes, coroutine framework invokes [releaseInterceptedContinuation]\n     * with the resulting continuation if it was intercepted, that is if `interceptContinuation` had previously\n     * returned a different continuation instance.\n     */\n    public fun <T> interceptContinuation(continuation: Continuation<T>): Continuation<T>\n\n    /**\n     * Invoked for the continuation instance returned by [interceptContinuation] when the original\n     * continuation completes and will not be used anymore. This function is invoked only if [interceptContinuation]\n     * had returned a different continuation instance from the one it was invoked with.\n     *\n     * Default implementation does nothing.\n     *\n     * @param continuation Continuation instance returned by this interceptor's [interceptContinuation] invocation.\n     */\n    public fun releaseInterceptedContinuation(continuation: Continuation<*>) {\n        /* do nothing by default */\n    }\n\n    public override operator fun <E : CoroutineContext.Element> get(key: CoroutineContext.Key<E>): E? {\n        // getPolymorphicKey specialized for ContinuationInterceptor key\n        @OptIn(ExperimentalStdlibApi::class)\n        if (key is AbstractCoroutineContextKey<*, *>) {\n            @Suppress(\"UNCHECKED_CAST\")\n            return if (key.isSubKey(this.key)) key.tryCast(this) as? E else null\n        }\n        @Suppress(\"UNCHECKED_CAST\")\n        return if (ContinuationInterceptor === key) this as E else null\n    }\n\n\n    public override fun minusKey(key: CoroutineContext.Key<*>): CoroutineContext {\n        // minusPolymorphicKey specialized for ContinuationInterceptor key\n        @OptIn(ExperimentalStdlibApi::class)\n        if (key is AbstractCoroutineContextKey<*, *>) {\n            return if (key.isSubKey(this.key) && key.tryCast(this) != null) EmptyCoroutineContext else this\n        }\n        return if (ContinuationInterceptor === key) EmptyCoroutineContext else this\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\n/**\n * Persistent context for the coroutine. It is an indexed set of [Element] instances.\n * An indexed set is a mix between a set and a map.\n * Every element in this set has a unique [Key].\n */\n@SinceKotlin(\"1.3\")\npublic interface CoroutineContext {\n    /**\n     * Returns the element with the given [key] from this context or `null`.\n     */\n    public operator fun <E : Element> get(key: Key<E>): E?\n\n    /**\n     * Accumulates entries of this context starting with [initial] value and applying [operation]\n     * from left to right to current accumulator value and each element of this context.\n     */\n    public fun <R> fold(initial: R, operation: (R, Element) -> R): R\n\n    /**\n     * Returns a context containing elements from this context and elements from  other [context].\n     * The elements from this context with the same key as in the other one are dropped.\n     */\n    public operator fun plus(context: CoroutineContext): CoroutineContext =\n        if (context === EmptyCoroutineContext) this else // fast path -- avoid lambda creation\n            context.fold(this) { acc, element ->\n                val removed = acc.minusKey(element.key)\n                if (removed === EmptyCoroutineContext) element else {\n                    // make sure interceptor is always last in the context (and thus is fast to get when present)\n                    val interceptor = removed[ContinuationInterceptor]\n                    if (interceptor == null) CombinedContext(removed, element) else {\n                        val left = removed.minusKey(ContinuationInterceptor)\n                        if (left === EmptyCoroutineContext) CombinedContext(element, interceptor) else\n                            CombinedContext(CombinedContext(left, element), interceptor)\n                    }\n                }\n            }\n\n    /**\n     * Returns a context containing elements from this context, but without an element with\n     * the specified [key].\n     */\n    public fun minusKey(key: Key<*>): CoroutineContext\n\n    /**\n     * Key for the elements of [CoroutineContext]. [E] is a type of element with this key.\n     */\n    public interface Key<E : Element>\n\n    /**\n     * An element of the [CoroutineContext]. An element of the coroutine context is a singleton context by itself.\n     */\n    public interface Element : CoroutineContext {\n        /**\n         * A key of this coroutine context element.\n         */\n        public val key: Key<*>\n\n        public override operator fun <E : Element> get(key: Key<E>): E? =\n            @Suppress(\"UNCHECKED_CAST\")\n            if (this.key == key) this as E else null\n\n        public override fun <R> fold(initial: R, operation: (R, Element) -> R): R =\n            operation(initial, this)\n\n        public override fun minusKey(key: Key<*>): CoroutineContext =\n            if (this.key == key) EmptyCoroutineContext else this\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.coroutines.CoroutineContext.Element\nimport kotlin.coroutines.CoroutineContext.Key\n\n/**\n * Base class for [CoroutineContext.Element] implementations.\n */\n@SinceKotlin(\"1.3\")\npublic abstract class AbstractCoroutineContextElement(public override val key: Key<*>) : Element\n\n/**\n * Base class for [CoroutineContext.Key] associated with polymorphic [CoroutineContext.Element] implementation.\n * Polymorphic element implementation implies delegating its [get][Element.get] and [minusKey][Element.minusKey]\n * to [getPolymorphicElement] and [minusPolymorphicKey] respectively.\n *\n * Polymorphic elements can be extracted from the coroutine context using both element key and its supertype key.\n * Example of polymorphic elements:\n * ```\n * open class BaseElement : CoroutineContext.Element {\n *     companion object Key : CoroutineContext.Key<BaseElement>\n *     override val key: CoroutineContext.Key<*> get() = Key\n *     // It is important to use getPolymorphicKey and minusPolymorphicKey\n *     override fun <E : CoroutineContext.Element> get(key: CoroutineContext.Key<E>): E? = getPolymorphicElement(key)\n *     override fun minusKey(key: CoroutineContext.Key<*>): CoroutineContext = minusPolymorphicKey(key)\n * }\n *\n * class DerivedElement : BaseElement() {\n *     companion object Key : AbstractCoroutineContextKey<BaseElement, DerivedElement>(BaseElement, { it as? DerivedElement })\n * }\n * // Now it is possible to query both `BaseElement` and `DerivedElement`\n * someContext[BaseElement] // Returns BaseElement?, non-null both for BaseElement and DerivedElement instances\n * someContext[DerivedElement] // Returns DerivedElement?, non-null only for DerivedElement instance\n * ```\n * @param B base class of a polymorphic element\n * @param baseKey an instance of base key\n * @param E element type associated with the current key\n * @param safeCast a function that can safely cast abstract [CoroutineContext.Element] to the concrete [E] type\n *                 and return the element if it is a subtype of [E] or `null` otherwise.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic abstract class AbstractCoroutineContextKey<B : Element, E : B>(\n    baseKey: Key<B>,\n    private val safeCast: (element: Element) -> E?\n) : Key<E> {\n    private val topmostKey: Key<*> = if (baseKey is AbstractCoroutineContextKey<*, *>) baseKey.topmostKey else baseKey\n\n    internal fun tryCast(element: Element): E? = safeCast(element)\n    internal fun isSubKey(key: Key<*>): Boolean = key === this || topmostKey === key\n}\n\n/**\n * Returns the current element if it is associated with the given [key] in a polymorphic manner or `null` otherwise.\n * This method returns non-null value if either [Element.key] is equal to the given [key] or if the [key] is associated\n * with [Element.key] via [AbstractCoroutineContextKey].\n * See [AbstractCoroutineContextKey] for the example of usage.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun <E : Element> Element.getPolymorphicElement(key: Key<E>): E? {\n    if (key is AbstractCoroutineContextKey<*, *>) {\n        @Suppress(\"UNCHECKED_CAST\")\n        return if (key.isSubKey(this.key)) key.tryCast(this) as? E else null\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return if (this.key === key) this as E else null\n}\n\n/**\n * Returns empty coroutine context if the element is associated with the given [key] in a polymorphic manner\n * or `null` otherwise.\n * This method returns empty context if either [Element.key] is equal to the given [key] or if the [key] is associated\n * with [Element.key] via [AbstractCoroutineContextKey].\n * See [AbstractCoroutineContextKey] for the example of usage.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun Element.minusPolymorphicKey(key: Key<*>): CoroutineContext {\n    if (key is AbstractCoroutineContextKey<*, *>) {\n        return if (key.isSubKey(this.key) && key.tryCast(this) != null) EmptyCoroutineContext else this\n    }\n    return if (this.key === key) EmptyCoroutineContext else this\n}\n\n/**\n * An empty coroutine context.\n */\n@SinceKotlin(\"1.3\")\npublic object EmptyCoroutineContext : CoroutineContext, Serializable {\n    private const val serialVersionUID: Long = 0\n    private fun readResolve(): Any = EmptyCoroutineContext\n\n    public override fun <E : Element> get(key: Key<E>): E? = null\n    public override fun <R> fold(initial: R, operation: (R, Element) -> R): R = initial\n    public override fun plus(context: CoroutineContext): CoroutineContext = context\n    public override fun minusKey(key: Key<*>): CoroutineContext = this\n    public override fun hashCode(): Int = 0\n    public override fun toString(): String = \"EmptyCoroutineContext\"\n}\n\n//--------------------- internal impl ---------------------\n\n// this class is not exposed, but is hidden inside implementations\n// this is a left-biased list, so that `plus` works naturally\n@SinceKotlin(\"1.3\")\ninternal class CombinedContext(\n    private val left: CoroutineContext,\n    private val element: Element\n) : CoroutineContext, Serializable {\n\n    override fun <E : Element> get(key: Key<E>): E? {\n        var cur = this\n        while (true) {\n            cur.element[key]?.let { return it }\n            val next = cur.left\n            if (next is CombinedContext) {\n                cur = next\n            } else {\n                return next[key]\n            }\n        }\n    }\n\n    public override fun <R> fold(initial: R, operation: (R, Element) -> R): R =\n        operation(left.fold(initial, operation), element)\n\n    public override fun minusKey(key: Key<*>): CoroutineContext {\n        element[key]?.let { return left }\n        val newLeft = left.minusKey(key)\n        return when {\n            newLeft === left -> this\n            newLeft === EmptyCoroutineContext -> element\n            else -> CombinedContext(newLeft, element)\n        }\n    }\n\n    private fun size(): Int {\n        var cur = this\n        var size = 2\n        while (true) {\n            cur = cur.left as? CombinedContext ?: return size\n            size++\n        }\n    }\n\n    private fun contains(element: Element): Boolean =\n        get(element.key) == element\n\n    private fun containsAll(context: CombinedContext): Boolean {\n        var cur = context\n        while (true) {\n            if (!contains(cur.element)) return false\n            val next = cur.left\n            if (next is CombinedContext) {\n                cur = next\n            } else {\n                return contains(next as Element)\n            }\n        }\n    }\n\n    override fun equals(other: Any?): Boolean =\n        this === other || other is CombinedContext && other.size() == size() && other.containsAll(this)\n\n    override fun hashCode(): Int = left.hashCode() + element.hashCode()\n\n    override fun toString(): String =\n        \"[\" + fold(\"\") { acc, element ->\n            if (acc.isEmpty()) element.toString() else \"$acc, $element\"\n        } + \"]\"\n\n    private fun writeReplace(): Any {\n        val n = size()\n        val elements = arrayOfNulls<CoroutineContext>(n)\n        var index = 0\n        fold(Unit) { _, element -> elements[index++] = element }\n        check(index == n)\n        @Suppress(\"UNCHECKED_CAST\")\n        return Serialized(elements as Array<CoroutineContext>)\n    }\n\n    private class Serialized(val elements: Array<CoroutineContext>) : Serializable {\n        companion object {\n            private const val serialVersionUID: Long = 0L\n        }\n\n        private fun readResolve(): Any = elements.fold(EmptyCoroutineContext, CoroutineContext::plus)\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"PreconditionsKt\")\n\npackage kotlin\n\nimport kotlin.contracts.contract\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    require(value) { \"Failed requirement.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is null. Otherwise returns the not null value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return requireNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failRequireNotNullWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    } else {\n        return value\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    check(value) { \"Check failed.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return checkNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage]  if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    } else {\n        return value\n    }\n}\n\n\n/**\n * Throws an [IllegalStateException] with the given [message].\n *\n * @sample samples.misc.Preconditions.failWithError\n */\n@kotlin.internal.InlineOnly\npublic inline fun error(message: Any): Nothing = throw IllegalStateException(message.toString())\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"IntrinsicsKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin.coroutines.intrinsics\n\nimport kotlin.contracts.*\nimport kotlin.coroutines.*\nimport kotlin.internal.InlineOnly\n\n/**\n * Obtains the current continuation instance inside suspend functions and either suspends\n * currently running coroutine or returns result immediately without suspension.\n *\n * If the [block] returns the special [COROUTINE_SUSPENDED] value, it means that suspend function did suspend the execution and will\n * not return any result immediately. In this case, the [Continuation] provided to the [block] shall be\n * resumed by invoking [Continuation.resumeWith] at some moment in the\n * future when the result becomes available to resume the computation.\n *\n * Otherwise, the return value of the [block] must have a type assignable to [T] and represents the result of this suspend function.\n * It means that the execution was not suspended and the [Continuation] provided to the [block] shall not be invoked.\n * As the result type of the [block] is declared as `Any?` and cannot be correctly type-checked,\n * its proper return type remains on the conscience of the suspend function's author.\n *\n * Invocation of [Continuation.resumeWith] resumes coroutine directly in the invoker's thread without going through the\n * [ContinuationInterceptor] that might be present in the coroutine's [CoroutineContext].\n * It is the invoker's responsibility to ensure that a proper invocation context is established.\n * [Continuation.intercepted] can be used to acquire the intercepted continuation.\n *\n * Note that it is not recommended to call either [Continuation.resume] nor [Continuation.resumeWithException] functions synchronously\n * in the same stackframe where suspension function is run. Use [suspendCoroutine] as a safer way to obtain current\n * continuation instance.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\n@Suppress(\"UNUSED_PARAMETER\", \"RedundantSuspendModifier\")\npublic suspend inline fun <T> suspendCoroutineUninterceptedOrReturn(crossinline block: (Continuation<T>) -> Any?): T {\n    contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }\n    throw NotImplementedError(\"Implementation of suspendCoroutineUninterceptedOrReturn is intrinsic\")\n}\n\n/**\n * This value is used as a return value of [suspendCoroutineUninterceptedOrReturn] `block` argument to state that\n * the execution was suspended and will not return any result immediately.\n *\n * **Note: this value should not be used in general code.** Using it outside of the context of\n * `suspendCoroutineUninterceptedOrReturn` function return value  (including, but not limited to,\n * storing this value in other properties, returning it from other functions, etc)\n * can lead to unspecified behavior of the code.\n */\n// It is implemented as property with getter to avoid ProGuard <clinit> problem with multifile IntrinsicsKt class\n@SinceKotlin(\"1.3\")\npublic val COROUTINE_SUSPENDED: Any get() = CoroutineSingletons.COROUTINE_SUSPENDED\n\n// Using enum here ensures two important properties:\n//  1. It makes SafeContinuation serializable with all kinds of serialization frameworks (since all of them natively support enums)\n//  2. It improves debugging experience, since you clearly see toString() value of those objects and what package they come from\n@SinceKotlin(\"1.3\")\n@PublishedApi // This class is Published API via serialized representation of SafeContinuation, don't rename/move\ninternal enum class CoroutineSingletons { COROUTINE_SUSPENDED, UNDECIDED, RESUMED }\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.internal\n\n// a mod b (in arithmetical sense)\nprivate fun mod(a: Int, b: Int): Int {\n    val mod = a % b\n    return if (mod >= 0) mod else mod + b\n}\n\nprivate fun mod(a: Long, b: Long): Long {\n    val mod = a % b\n    return if (mod >= 0) mod else mod + b\n}\n\n// (a - b) mod c\nprivate fun differenceModulo(a: Int, b: Int, c: Int): Int {\n    return mod(mod(a, c) - mod(b, c), c)\n}\n\nprivate fun differenceModulo(a: Long, b: Long, c: Long): Long {\n    return mod(mod(a, c) - mod(b, c), c)\n}\n\n/**\n * Calculates the final element of a bounded arithmetic progression, i.e. the last element of the progression which is in the range\n * from [start] to [end] in case of a positive [step], or from [end] to [start] in case of a negative\n * [step].\n *\n * No validation on passed parameters is performed. The given parameters should satisfy the condition:\n *\n * - either `step > 0` and `start <= end`,\n * - or `step < 0` and `start >= end`.\n *\n * @param start first element of the progression\n * @param end ending bound for the progression\n * @param step increment, or difference of successive elements in the progression\n * @return the final element of the progression\n * @suppress\n */\n@PublishedApi\ninternal fun getProgressionLastElement(start: Int, end: Int, step: Int): Int = when {\n    step > 0 -> if (start >= end) end else end - differenceModulo(end, start, step)\n    step < 0 -> if (start <= end) end else end + differenceModulo(start, end, -step)\n    else -> throw kotlin.IllegalArgumentException(\"Step is zero.\")\n}\n\n/**\n * Calculates the final element of a bounded arithmetic progression, i.e. the last element of the progression which is in the range\n * from [start] to [end] in case of a positive [step], or from [end] to [start] in case of a negative\n * [step].\n *\n * No validation on passed parameters is performed. The given parameters should satisfy the condition:\n *\n * - either `step > 0` and `start <= end`,\n * - or `step < 0` and `start >= end`.\n *\n * @param start first element of the progression\n * @param end ending bound for the progression\n * @param step increment, or difference of successive elements in the progression\n * @return the final element of the progression\n * @suppress\n */\n@PublishedApi\ninternal fun getProgressionLastElement(start: Long, end: Long, step: Long): Long = when {\n    step > 0 -> if (start >= end) end else end - differenceModulo(end, start, step)\n    step < 0 -> if (start <= end) end else end + differenceModulo(start, end, -step)\n    else -> throw kotlin.IllegalArgumentException(\"Step is zero.\")\n}\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\n/**\n * An iterator over a progression of values of type `Char`.\n * @property step the number by which the value is incremented on each step.\n */\ninternal class CharProgressionIterator(first: Char, last: Char, val step: Int) : CharIterator() {\n    private val finalElement: Int = last.code\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private var next: Int = if (hasNext) first.code else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun nextChar(): Char {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        }\n        else {\n            next += step\n        }\n        return value.toChar()\n    }\n}\n\n/**\n * An iterator over a progression of values of type `Int`.\n * @property step the number by which the value is incremented on each step.\n */\ninternal class IntProgressionIterator(first: Int, last: Int, val step: Int) : IntIterator() {\n    private val finalElement: Int = last\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private var next: Int = if (hasNext) first else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun nextInt(): Int {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        }\n        else {\n            next += step\n        }\n        return value\n    }\n}\n\n/**\n * An iterator over a progression of values of type `Long`.\n * @property step the number by which the value is incremented on each step.\n */\ninternal class LongProgressionIterator(first: Long, last: Long, val step: Long) : LongIterator() {\n    private val finalElement: Long = last\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private var next: Long = if (hasNext) first else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun nextLong(): Long {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        }\n        else {\n            next += step\n        }\n        return value\n    }\n}\n\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\nimport kotlin.internal.getProgressionLastElement\n\n/**\n * A progression of values of type `Char`.\n */\npublic open class CharProgression\n    internal constructor\n    (\n            start: Char,\n            endInclusive: Char,\n            step: Int\n    ) : Iterable<Char> {\n    init {\n        if (step == 0) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Int.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Int.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: Char = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: Char = getProgressionLastElement(start.code, endInclusive.code, step).toChar()\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Int = step\n\n    override fun iterator(): CharIterator = CharProgressionIterator(first, last, step)\n\n    /**\n     * Checks if the progression is empty.\n     *\n     * Progression with a positive step is empty if its first element is greater than the last element.\n     * Progression with a negative step is empty if its first element is less than the last element.\n     */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is CharProgression && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * first.code + last.code) + step)\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates CharProgression within the specified bounds of a closed range.\n         *\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Int.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: Char, rangeEnd: Char, step: Int): CharProgression = CharProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n/**\n * A progression of values of type `Int`.\n */\npublic open class IntProgression\n    internal constructor\n    (\n            start: Int,\n            endInclusive: Int,\n            step: Int\n    ) : Iterable<Int> {\n    init {\n        if (step == 0) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Int.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Int.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: Int = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: Int = getProgressionLastElement(start, endInclusive, step)\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Int = step\n\n    override fun iterator(): IntIterator = IntProgressionIterator(first, last, step)\n\n    /**\n     * Checks if the progression is empty.\n     *\n     * Progression with a positive step is empty if its first element is greater than the last element.\n     * Progression with a negative step is empty if its first element is less than the last element.\n     */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is IntProgression && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * first + last) + step)\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates IntProgression within the specified bounds of a closed range.\n         *\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Int.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: Int, rangeEnd: Int, step: Int): IntProgression = IntProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n/**\n * A progression of values of type `Long`.\n */\npublic open class LongProgression\n    internal constructor\n    (\n            start: Long,\n            endInclusive: Long,\n            step: Long\n    ) : Iterable<Long> {\n    init {\n        if (step == 0L) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Long.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Long.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: Long = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: Long = getProgressionLastElement(start, endInclusive, step)\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Long = step\n\n    override fun iterator(): LongIterator = LongProgressionIterator(first, last, step)\n\n    /**\n     * Checks if the progression is empty.\n     *\n     * Progression with a positive step is empty if its first element is greater than the last element.\n     * Progression with a negative step is empty if its first element is less than the last element.\n     */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is LongProgression && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * (first xor (first ushr 32)) + (last xor (last ushr 32))) + (step xor (step ushr 32))).toInt()\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates LongProgression within the specified bounds of a closed range.\n         *\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Long.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: Long, rangeEnd: Long, step: Long): LongProgression = LongProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"RangesKt\")\n\npackage kotlin.ranges\n\n/**\n * Represents a range of [Comparable] values.\n */\nprivate open class ComparableRange<T : Comparable<T>>(\n    override val start: T,\n    override val endInclusive: T\n) : ClosedRange<T> {\n\n    override fun equals(other: Any?): Boolean {\n        return other is ComparableRange<*> && (isEmpty() && other.isEmpty() ||\n                start == other.start && endInclusive == other.endInclusive)\n    }\n\n    override fun hashCode(): Int {\n        return if (isEmpty()) -1 else 31 * start.hashCode() + endInclusive.hashCode()\n    }\n\n    override fun toString(): String = \"$start..$endInclusive\"\n}\n\n/**\n * Creates a range from this [Comparable] value to the specified [that] value.\n *\n * This value needs to be smaller than or equal to [that] value, otherwise the returned range will be empty.\n * @sample samples.ranges.Ranges.rangeFromComparable\n */\npublic operator fun <T : Comparable<T>> T.rangeTo(that: T): ClosedRange<T> = ComparableRange(this, that)\n\n/**\n * Represents a range of [Comparable] values.\n */\n@OptIn(ExperimentalStdlibApi::class)\nprivate open class ComparableOpenEndRange<T : Comparable<T>>(\n    override val start: T,\n    override val endExclusive: T\n) : OpenEndRange<T> {\n\n    override fun equals(other: Any?): Boolean {\n        return other is ComparableOpenEndRange<*> && (isEmpty() && other.isEmpty() ||\n                start == other.start && endExclusive == other.endExclusive)\n    }\n\n    override fun hashCode(): Int {\n        return if (isEmpty()) -1 else 31 * start.hashCode() + endExclusive.hashCode()\n    }\n\n    override fun toString(): String = \"$start..<$endExclusive\"\n}\n\n/**\n * Creates an open-ended range from this [Comparable] value to the specified [that] value.\n *\n * This value needs to be smaller than [that] value, otherwise the returned range will be empty.\n * @sample samples.ranges.Ranges.rangeFromComparable\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\npublic operator fun <T : Comparable<T>> T.rangeUntil(that: T): OpenEndRange<T> = ComparableOpenEndRange(this, that)\n\n\n/**\n * Represents a range of floating point numbers.\n * Extends [ClosedRange] interface providing custom operation [lessThanOrEquals] for comparing values of range domain type.\n *\n * This interface is implemented by floating point ranges returned by [Float.rangeTo] and [Double.rangeTo] operators to\n * achieve IEEE-754 comparison order instead of total order of floating point numbers.\n */\n@SinceKotlin(\"1.1\")\npublic interface ClosedFloatingPointRange<T : Comparable<T>> : ClosedRange<T> {\n    override fun contains(value: T): Boolean = lessThanOrEquals(start, value) && lessThanOrEquals(value, endInclusive)\n    override fun isEmpty(): Boolean = !lessThanOrEquals(start, endInclusive)\n\n    /**\n     * Compares two values of range domain type and returns true if first is less than or equal to second.\n     */\n    fun lessThanOrEquals(a: T, b: T): Boolean\n}\n\n\n/**\n * A closed range of values of type `Double`.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n */\nprivate class ClosedDoubleRange(\n    start: Double,\n    endInclusive: Double\n) : ClosedFloatingPointRange<Double> {\n    private val _start = start\n    private val _endInclusive = endInclusive\n    override val start: Double get() = _start\n    override val endInclusive: Double get() = _endInclusive\n\n    override fun lessThanOrEquals(a: Double, b: Double): Boolean = a <= b\n\n    override fun contains(value: Double): Boolean = value >= _start && value <= _endInclusive\n    override fun isEmpty(): Boolean = !(_start <= _endInclusive)\n\n    override fun equals(other: Any?): Boolean {\n        return other is ClosedDoubleRange && (isEmpty() && other.isEmpty() ||\n                _start == other._start && _endInclusive == other._endInclusive)\n    }\n\n    override fun hashCode(): Int {\n        return if (isEmpty()) -1 else 31 * _start.hashCode() + _endInclusive.hashCode()\n    }\n\n    override fun toString(): String = \"$_start..$_endInclusive\"\n}\n\n/**\n * Creates a range from this [Double] value to the specified [that] value.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n * @sample samples.ranges.Ranges.rangeFromDouble\n */\n@SinceKotlin(\"1.1\")\npublic operator fun Double.rangeTo(that: Double): ClosedFloatingPointRange<Double> = ClosedDoubleRange(this, that)\n\n/**\n * An open-ended range of values of type `Double`.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n */\n@OptIn(ExperimentalStdlibApi::class)\nprivate class OpenEndDoubleRange(\n    start: Double,\n    endExclusive: Double\n) : OpenEndRange<Double> {\n    private val _start = start\n    private val _endExclusive = endExclusive\n    override val start: Double get() = _start\n    override val endExclusive: Double get() = _endExclusive\n\n    private fun lessThanOrEquals(a: Double, b: Double): Boolean = a <= b\n\n    override fun contains(value: Double): Boolean = value >= _start && value < _endExclusive\n    override fun isEmpty(): Boolean = !(_start < _endExclusive)\n\n    override fun equals(other: Any?): Boolean {\n        return other is OpenEndDoubleRange && (isEmpty() && other.isEmpty() ||\n                _start == other._start && _endExclusive == other._endExclusive)\n    }\n\n    override fun hashCode(): Int {\n        return if (isEmpty()) -1 else 31 * _start.hashCode() + _endExclusive.hashCode()\n    }\n\n    override fun toString(): String = \"$_start..<$_endExclusive\"\n}\n\n/**\n * Creates an open-ended range from this [Double] value to the specified [that] value.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\npublic operator fun Double.rangeUntil(that: Double): OpenEndRange<Double> = OpenEndDoubleRange(this, that)\n\n\n/**\n * A closed range of values of type `Float`.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n */\nprivate class ClosedFloatRange(\n    start: Float,\n    endInclusive: Float\n) : ClosedFloatingPointRange<Float> {\n    private val _start = start\n    private val _endInclusive = endInclusive\n    override val start: Float get() = _start\n    override val endInclusive: Float get() = _endInclusive\n\n    override fun lessThanOrEquals(a: Float, b: Float): Boolean = a <= b\n\n    override fun contains(value: Float): Boolean = value >= _start && value <= _endInclusive\n    override fun isEmpty(): Boolean = !(_start <= _endInclusive)\n\n    override fun equals(other: Any?): Boolean {\n        return other is ClosedFloatRange && (isEmpty() && other.isEmpty() ||\n                _start == other._start && _endInclusive == other._endInclusive)\n    }\n\n    override fun hashCode(): Int {\n        return if (isEmpty()) -1 else 31 * _start.hashCode() + _endInclusive.hashCode()\n    }\n\n    override fun toString(): String = \"$_start..$_endInclusive\"\n}\n\n/**\n * Creates a range from this [Float] value to the specified [that] value.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n * @sample samples.ranges.Ranges.rangeFromFloat\n */\n@SinceKotlin(\"1.1\")\npublic operator fun Float.rangeTo(that: Float): ClosedFloatingPointRange<Float> = ClosedFloatRange(this, that)\n\n\n/**\n * An open-ended range of values of type `Float`.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n */\n@OptIn(ExperimentalStdlibApi::class)\nprivate class OpenEndFloatRange(\n    start: Float,\n    endExclusive: Float\n) : OpenEndRange<Float> {\n    private val _start = start\n    private val _endExclusive = endExclusive\n    override val start: Float get() = _start\n    override val endExclusive: Float get() = _endExclusive\n\n    private fun lessThanOrEquals(a: Float, b: Float): Boolean = a <= b\n\n    override fun contains(value: Float): Boolean = value >= _start && value < _endExclusive\n    override fun isEmpty(): Boolean = !(_start < _endExclusive)\n\n    override fun equals(other: Any?): Boolean {\n        return other is OpenEndFloatRange && (isEmpty() && other.isEmpty() ||\n                _start == other._start && _endExclusive == other._endExclusive)\n    }\n\n    override fun hashCode(): Int {\n        return if (isEmpty()) -1 else 31 * _start.hashCode() + _endExclusive.hashCode()\n    }\n\n    override fun toString(): String = \"$_start..<$_endExclusive\"\n}\n\n/**\n * Creates an open-ended range from this [Float] value to the specified [that] value.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\npublic operator fun Float.rangeUntil(that: Float): OpenEndRange<Float> = OpenEndFloatRange(this, that)\n\n\n/**\n * Returns `true` if this iterable range contains the specified [element].\n *\n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <T, R> R.contains(element: T?): Boolean where T : Any, R : ClosedRange<T>, R : Iterable<T> =\n    element != null && contains(element)\n\n/**\n * Returns `true` if this iterable range contains the specified [element].\n *\n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline operator fun <T, R> R.contains(element: T?): Boolean where T : Any, R : OpenEndRange<T>, R : Iterable<T> =\n    element != null && contains(element)\n\ninternal fun checkStepIsPositive(isPositive: Boolean, step: Number) {\n    if (!isPositive) throw IllegalArgumentException(\"Step must be positive, was: $step.\")\n}\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.ranges\n\n/**\n * Represents a range of values (for example, numbers or characters) where both the lower and upper bounds are included in the range.\n * See the [Kotlin language documentation](https://kotlinlang.org/docs/reference/ranges.html) for more information.\n */\npublic interface ClosedRange<T : Comparable<T>> {\n    /**\n     * The minimum value in the range.\n     */\n    public val start: T\n\n    /**\n     * The maximum value in the range (inclusive).\n     */\n    public val endInclusive: T\n\n    /**\n     * Checks whether the specified [value] belongs to the range.\n     *\n     * A value belongs to the closed range if it is greater than or equal to the [start] bound and less than or equal to the [endInclusive] bound.\n     */\n    public operator fun contains(value: T): Boolean = value >= start && value <= endInclusive\n\n    /**\n     * Checks whether the range is empty.\n     *\n     * The range is empty if its start value is greater than the end value.\n     */\n    public fun isEmpty(): Boolean = start > endInclusive\n}\n\n/**\n * Represents a range of values (for example, numbers or characters) where the upper bound is not included in the range.\n * See the [Kotlin language documentation](https://kotlinlang.org/docs/reference/ranges.html) for more information.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\npublic interface OpenEndRange<T : Comparable<T>> {\n    /**\n     * The minimum value in the range.\n     */\n    public val start: T\n\n    /**\n     * The maximum value in the range (exclusive).\n     *\n     * @throws IllegalStateException can be thrown if the exclusive end bound cannot be represented\n     * with a value of type [T].\n     */\n    public val endExclusive: T\n\n    /**\n     * Checks whether the specified [value] belongs to the range.\n     *\n     * A value belongs to the open-ended range if it is greater than or equal to the [start] bound and strictly less than the [endExclusive] bound.\n     */\n    public operator fun contains(value: T): Boolean = value >= start && value < endExclusive\n\n    /**\n     * Checks whether the range is empty.\n     *\n     * The open-ended range is empty if its start value is greater than or equal to the end value.\n     */\n    public fun isEmpty(): Boolean = start >= endExclusive\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@JsName(\"arrayIterator\")\ninternal fun arrayIterator(array: dynamic, type: String?) = when (type) {\n    null -> {\n        val arr: Array<dynamic> = array\n        object : Iterator<dynamic> {\n            var index = 0\n            override fun hasNext() = index < arr.size\n            override fun next() = if (index < arr.size) arr[index++] else throw NoSuchElementException(\"$index\")\n        }\n    }\n    \"BooleanArray\" -> booleanArrayIterator(array)\n    \"ByteArray\" -> byteArrayIterator(array)\n    \"ShortArray\" -> shortArrayIterator(array)\n    \"CharArray\" -> charArrayIterator(array)\n    \"IntArray\" -> intArrayIterator(array)\n    \"LongArray\" -> longArrayIterator(array)\n    \"FloatArray\" -> floatArrayIterator(array)\n    \"DoubleArray\" -> doubleArrayIterator(array)\n    else -> throw IllegalStateException(\"Unsupported type argument for arrayIterator: $type\")\n}\n\n@JsName(\"booleanArrayIterator\")\ninternal fun booleanArrayIterator(array: BooleanArray) = object : BooleanIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextBoolean() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"byteArrayIterator\")\ninternal fun byteArrayIterator(array: ByteArray) = object : ByteIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextByte() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"shortArrayIterator\")\ninternal fun shortArrayIterator(array: ShortArray) = object : ShortIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextShort() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"charArrayIterator\")\ninternal fun charArrayIterator(array: CharArray) = object : CharIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextChar() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"intArrayIterator\")\ninternal fun intArrayIterator(array: IntArray) = object : IntIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextInt() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"floatArrayIterator\")\ninternal fun floatArrayIterator(array: FloatArray) = object : FloatIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextFloat() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"doubleArrayIterator\")\ninternal fun doubleArrayIterator(array: DoubleArray) = object : DoubleIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextDouble() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"longArrayIterator\")\ninternal fun longArrayIterator(array: LongArray) = object : LongIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextLong() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"PropertyMetadata\")\ninternal class PropertyMetadata(@JsName(\"callableName\") val name: String)\n\n@JsName(\"noWhenBranchMatched\")\ninternal fun noWhenBranchMatched(): Nothing = throw NoWhenBranchMatchedException()\n\n@JsName(\"subSequence\")\ninternal fun subSequence(c: CharSequence, startIndex: Int, endIndex: Int): CharSequence {\n    if (c is String) {\n        return c.substring(startIndex, endIndex)\n    } else {\n        return c.asDynamic().`subSequence_vux9f0$`(startIndex, endIndex)\n    }\n}\n\n@JsName(\"captureStack\")\ninternal fun captureStack(@Suppress(\"UNUSED_PARAMETER\") baseClass: JsClass<in Throwable>, instance: Throwable) {\n    if (js(\"Error\").captureStackTrace) {\n        // Using uncropped stack traces due to KT-37563.\n        // Precise stack traces are implemented in JS IR compiler and stdlib\n        js(\"Error\").captureStackTrace(instance);\n    } else {\n        instance.asDynamic().stack = js(\"new Error()\").stack;\n    }\n}\n\n@JsName(\"newThrowable\")\ninternal fun newThrowable(message: String?, cause: Throwable?): Throwable {\n    val throwable = js(\"new Error()\")\n    throwable.message = if (jsTypeOf(message) == \"undefined\") {\n        if (cause != null) cause.toString() else null\n    } else {\n        message\n    }\n    throwable.cause = cause\n    throwable.name = \"Throwable\"\n    return throwable\n}\n\n@JsName(\"BoxedChar\")\ninternal class BoxedChar(val c: Int) : Comparable<Int> {\n    override fun equals(other: Any?): Boolean {\n        return other is BoxedChar && c == other.c\n    }\n\n    override fun hashCode(): Int {\n        return c\n    }\n\n    override fun toString(): String {\n        return js(\"this.c\").unsafeCast<Char>().toString()\n    }\n\n    override fun compareTo(other: Int): Int {\n        return js(\"this.c - other\").unsafeCast<Int>()\n    }\n\n    @JsName(\"valueOf\")\n    public fun valueOf(): Int {\n        return c\n    }\n}\n\n@kotlin.internal.InlineOnly\ninternal inline fun <T> concat(args: Array<T>): T {\n    val typed = js(\"Array\")(args.size)\n    for (i in args.indices) {\n        val arr = args[i]\n        if (arr !is Array<*>) {\n            typed[i] = js(\"[]\").slice.call(arr)\n        } else {\n            typed[i] = arr\n        }\n    }\n    return js(\"[]\").concat.apply(js(\"[]\"), typed);\n}\n\n/** Concat regular Array's and TypedArray's into an Array.\n */\n@PublishedApi\n@JsName(\"arrayConcat\")\n@Suppress(\"UNUSED_PARAMETER\")\ninternal fun <T> arrayConcat(a: T, b: T): T {\n    return concat(js(\"arguments\"))\n}\n\n/** Concat primitive arrays. Main use: prepare vararg arguments.\n *  For compatibility with 1.1.0 the arguments may be a mixture of Array's and TypedArray's.\n *\n *  If the first argument is TypedArray (Byte-, Short-, Char-, Int-, Float-, and DoubleArray) returns a TypedArray, otherwise an Array.\n *  If the first argument has the $type$ property (Boolean-, Char-, and LongArray) copy its value to result.$type$.\n *  If the first argument is a regular Array without the $type$ property default to arrayConcat.\n */\n@PublishedApi\n@JsName(\"primitiveArrayConcat\")\n@Suppress(\"UNUSED_PARAMETER\")\ninternal fun <T> primitiveArrayConcat(a: T, b: T): T {\n    val args: Array<T> = js(\"arguments\")\n    if (a is Array<*> && a.asDynamic().`$type$` === undefined) {\n        return concat(args)\n    } else {\n        var size = 0\n        for (i in args.indices) {\n            size += args[i].asDynamic().length as Int\n        }\n        val result = js(\"new a.constructor(size)\")\n        kotlin.copyArrayType(a, result)\n        size = 0\n        for (i in args.indices) {\n            val arr = args[i].asDynamic()\n            for (j in 0 until arr.length) {\n                result[size++] = arr[j]\n            }\n        }\n        return result\n    }\n}\n\n@JsName(\"booleanArrayOf\")\ninternal fun booleanArrayOf() = withType(\"BooleanArray\", js(\"[].slice.call(arguments)\"))\n\n@JsName(\"charArrayOf\")\ninternal fun charArrayOf() = withType(\"CharArray\", js(\"new Uint16Array(arguments)\"))\n\n@JsName(\"longArrayOf\")\ninternal fun longArrayOf() = withType(\"LongArray\", js(\"[].slice.call(arguments)\"))\n\n@JsName(\"withType\")\n@kotlin.internal.InlineOnly\ninternal inline fun withType(type: String, array: dynamic): dynamic {\n    array.`$type$` = type\n    return array\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines.intrinsics\n\nimport kotlin.coroutines.*\nimport kotlin.internal.InlineOnly\n\n/**\n * Starts an unintercepted coroutine without a receiver and with result type [T] and executes it until its first suspension.\n * Returns the result of the coroutine or throws its exception if it does not suspend or [COROUTINE_SUSPENDED] if it suspends.\n * In the latter case, the [completion] continuation is invoked when the coroutine completes with a result or an exception.\n *\n * The coroutine is started directly in the invoker's thread without going through the [ContinuationInterceptor] that might\n * be present in the completion's [CoroutineContext]. It is the invoker's responsibility to ensure that a proper invocation\n * context is established.\n *\n * This function is designed to be used from inside of [suspendCoroutineUninterceptedOrReturn] to resume the execution of the suspended\n * coroutine using a reference to the suspending function.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic actual inline fun <T> (suspend () -> T).startCoroutineUninterceptedOrReturn(\n    completion: Continuation<T>\n): Any? = this.asDynamic()(completion, false)\n\n/**\n * Starts an unintercepted coroutine with receiver type [R] and result type [T] and executes it until its first suspension.\n * Returns the result of the coroutine or throws its exception if it does not suspend or [COROUTINE_SUSPENDED] if it suspends.\n * In the latter case, the [completion] continuation is invoked when the coroutine completes with a result or an exception.\n *\n * The coroutine is started directly in the invoker's thread without going through the [ContinuationInterceptor] that might\n * be present in the completion's [CoroutineContext]. It is the invoker's responsibility to ensure that a proper invocation\n * context is established.\n *\n * This function is designed to be used from inside of [suspendCoroutineUninterceptedOrReturn] to resume the execution of the suspended\n * coroutine using a reference to the suspending function.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic actual inline fun <R, T> (suspend R.() -> T).startCoroutineUninterceptedOrReturn(\n    receiver: R,\n    completion: Continuation<T>\n): Any? = this.asDynamic()(receiver, completion, false)\n\n@InlineOnly\ninternal actual inline fun <R, P, T> (suspend R.(P) -> T).startCoroutineUninterceptedOrReturn(\n    receiver: R,\n    param: P,\n    completion: Continuation<T>\n): Any? = this.asDynamic()(receiver, param, completion, false)\n\n/**\n * Creates unintercepted coroutine without receiver and with result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when coroutine completes with result or exception.\n *\n * This function returns unintercepted continuation.\n * Invocation of `resume(Unit)` starts coroutine immediately in the invoker's call stack without going through the\n * [ContinuationInterceptor] that might be present in the completion's [CoroutineContext].\n * It is the invoker's responsibility to ensure that a proper invocation context is established.\n * Note that [completion] of this function may get invoked in an arbitrary context.\n *\n * [Continuation.intercepted] can be used to acquire the intercepted continuation.\n * Invocation of `resume(Unit)` on intercepted continuation guarantees that execution of\n * both the coroutine and [completion] happens in the invocation context established by\n * [ContinuationInterceptor].\n *\n * Repeated invocation of any resume function on the resulting continuation corrupts the\n * state machine of the coroutine and may result in arbitrary behaviour or exception.\n */\n@SinceKotlin(\"1.3\")\npublic actual fun <T> (suspend () -> T).createCoroutineUnintercepted(\n    completion: Continuation<T>\n): Continuation<Unit> =\n    // Kotlin/JS suspend lambdas have an extra parameter `suspended`\n    if (this.asDynamic().length == 2) {\n        // When `suspended` is true the continuation is created, but not executed\n        this.asDynamic()(completion, true)\n    } else {\n        createCoroutineFromSuspendFunction(completion) {\n            this.asDynamic()(completion)\n        }\n    }\n\n/**\n * Creates unintercepted coroutine with receiver type [R] and result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when coroutine completes with result or exception.\n *\n * This function returns unintercepted continuation.\n * Invocation of `resume(Unit)` starts coroutine immediately in the invoker's call stack without going through the\n * [ContinuationInterceptor] that might be present in the completion's [CoroutineContext].\n * It is the invoker's responsibility to ensure that a proper invocation context is established.\n * Note that [completion] of this function may get invoked in an arbitrary context.\n *\n * [Continuation.intercepted] can be used to acquire the intercepted continuation.\n * Invocation of `resume(Unit)` on intercepted continuation guarantees that execution of\n * both the coroutine and [completion] happens in the invocation context established by\n * [ContinuationInterceptor].\n *\n * Repeated invocation of any resume function on the resulting continuation corrupts the\n * state machine of the coroutine and may result in arbitrary behaviour or exception.\n */\n@SinceKotlin(\"1.3\")\npublic actual fun <R, T> (suspend R.() -> T).createCoroutineUnintercepted(\n    receiver: R,\n    completion: Continuation<T>\n): Continuation<Unit> =\n    // Kotlin/JS suspend lambdas have an extra parameter `suspended`\n    if (this.asDynamic().length == 3) {\n        // When `suspended` is true the continuation is created, but not executed\n        this.asDynamic()(receiver, completion, true)\n    } else {\n        createCoroutineFromSuspendFunction(completion) {\n            this.asDynamic()(receiver, completion)\n        }\n    }\n\n/**\n * Intercepts this continuation with [ContinuationInterceptor].\n *\n * This function shall be used on the immediate result of [createCoroutineUnintercepted] or [suspendCoroutineUninterceptedOrReturn],\n * in which case it checks for [ContinuationInterceptor] in the continuation's [context][Continuation.context],\n * invokes [ContinuationInterceptor.interceptContinuation], caches and returns the result.\n *\n * If this function is invoked on other [Continuation] instances it returns `this` continuation unchanged.\n */\n@SinceKotlin(\"1.3\")\npublic actual fun <T> Continuation<T>.intercepted(): Continuation<T> =\n    (this as? CoroutineImpl)?.intercepted() ?: this\n\n\nprivate inline fun <T> createCoroutineFromSuspendFunction(\n    completion: Continuation<T>,\n    crossinline block: () -> Any?\n): Continuation<Unit> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return object : CoroutineImpl(completion as Continuation<Any?>) {\n        override fun doResume(): Any? {\n            exception?.let { throw it }\n            return block()\n        }\n    }\n}\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\ninternal fun <T> sortArrayWith(array: Array<out T>, comparison: (T, T) -> Int) {\n    if (getStableSortingIsSupported()) {\n        array.asDynamic().sort(comparison)\n    } else {\n        mergeSort(array.unsafeCast<Array<T>>(), 0, array.lastIndex, Comparator(comparison))\n    }\n}\n\ninternal fun <T> sortArrayWith(array: Array<out T>, comparator: Comparator<in T>) {\n    if (getStableSortingIsSupported()) {\n        val comparison = { a: T, b: T -> comparator.compare(a, b) }\n        array.asDynamic().sort(comparison)\n    } else {\n        mergeSort(array.unsafeCast<Array<T>>(), 0, array.lastIndex, comparator)\n    }\n}\n\ninternal fun <T> sortArrayWith(array: Array<out T>, fromIndex: Int, toIndex: Int, comparator: Comparator<in T>) {\n    if (fromIndex < toIndex - 1) {\n        mergeSort(array.unsafeCast<Array<T>>(), fromIndex, toIndex - 1, comparator)\n    }\n}\n\ninternal fun <T : Comparable<T>> sortArray(array: Array<out T>) {\n    if (getStableSortingIsSupported()) {\n        val comparison = { a: T, b: T -> a.compareTo(b) }\n        array.asDynamic().sort(comparison)\n    } else {\n        mergeSort(array.unsafeCast<Array<T>>(), 0, array.lastIndex, naturalOrder())\n    }\n}\n\nprivate var _stableSortingIsSupported: Boolean? = null\nprivate fun getStableSortingIsSupported(): Boolean {\n    _stableSortingIsSupported?.let { return it }\n    _stableSortingIsSupported = false\n\n    val array = js(\"[]\").unsafeCast<Array<Int>>()\n    // known implementations may use stable sort for arrays of up to 512 elements\n    // so we create slightly more elements to test stability\n    for (index in 0 until 600) array.asDynamic().push(index)\n    val comparison = { a: Int, b: Int -> (a and 3) - (b and 3) }\n    array.asDynamic().sort(comparison)\n    for (index in 1 until array.size) {\n        val a = array[index - 1]\n        val b = array[index]\n        if ((a and 3) == (b and 3) && a >= b) return false\n    }\n    _stableSortingIsSupported = true\n    return true\n}\n\n\nprivate fun <T> mergeSort(array: Array<T>, start: Int, endInclusive: Int, comparator: Comparator<in T>) {\n    val buffer = arrayOfNulls<Any?>(array.size).unsafeCast<Array<T>>()\n    val result = mergeSort(array, buffer, start, endInclusive, comparator)\n    if (result !== array) {\n        for (i in start..endInclusive) array[i] = result[i]\n    }\n}\n\n// Both start and end are inclusive indices.\nprivate fun <T> mergeSort(array: Array<T>, buffer: Array<T>, start: Int, end: Int, comparator: Comparator<in T>): Array<T> {\n    if (start == end) {\n        return array\n    }\n\n    val median = (start + end) / 2\n    val left = mergeSort(array, buffer, start, median, comparator)\n    val right = mergeSort(array, buffer, median + 1, end, comparator)\n\n    val target = if (left === buffer) array else buffer\n\n    // Merge.\n    var leftIndex = start\n    var rightIndex = median + 1\n    for (i in start..end) {\n        when {\n            leftIndex <= median && rightIndex <= end -> {\n                val leftValue = left[leftIndex]\n                val rightValue = right[rightIndex]\n\n                if (comparator.compare(leftValue, rightValue) <= 0) {\n                    target[i] = leftValue\n                    leftIndex++\n                } else {\n                    target[i] = rightValue\n                    rightIndex++\n                }\n            }\n            leftIndex <= median -> {\n                target[i] = left[leftIndex]\n                leftIndex++\n            }\n            else /* rightIndex <= end */ -> {\n                target[i] = right[rightIndex]\n                rightIndex++\n                Unit  // TODO: Fix KT-31506\n            }\n        }\n    }\n\n    return target\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines.js.internal\n\nimport kotlin.coroutines.Continuation\nimport kotlin.coroutines.EmptyCoroutineContext\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal val EmptyContinuation = Continuation<Any?>(EmptyCoroutineContext) { result ->\n    result.getOrThrow()\n}","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.js\n\n/**\n * Exposes the JavaScript [Math object](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math) to Kotlin.\n */\n@PublishedApi\n@JsName(\"Math\")\ninternal external object JsMath {\n    val LN2: Double\n    fun abs(value: Double): Double\n    fun acos(value: Double): Double\n    fun asin(value: Double): Double\n    fun atan(value: Double): Double\n    fun atan2(y: Double, x: Double): Double\n    fun cos(value: Double): Double\n    fun sin(value: Double): Double\n    fun exp(value: Double): Double\n    fun max(vararg values: Int): Int\n    fun max(vararg values: Float): Float\n    fun max(vararg values: Double): Double\n    fun min(vararg values: Int): Int\n    fun min(vararg values: Float): Float\n    fun min(vararg values: Double): Double\n    fun sqrt(value: Double): Double\n    fun tan(value: Double): Double\n    fun log(value: Double): Double\n    fun cbrt(value: Double): Double\n    fun pow(base: Double, exp: Double): Double\n    fun round(value: Number): Double\n    fun floor(value: Number): Double\n    fun ceil(value: Number): Double\n}\n\ninternal const val defineTaylorNBound = \"\"\"\n    var epsilon = 2.220446049250313E-16;\n    var taylor_2_bound = Math.sqrt(epsilon);\n    var taylor_n_bound = Math.sqrt(taylor_2_bound);\n\"\"\"\n\ninternal const val defineUpperTaylor2Bound = \"\"\"\n    $defineTaylorNBound\n    var upper_taylor_2_bound = 1/taylor_2_bound;\n\"\"\"\n\ninternal const val defineUpperTaylorNBound = \"\"\"\n    $defineUpperTaylor2Bound\n    var upper_taylor_n_bound = 1/taylor_n_bound;\n\"\"\"\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\npackage kotlin.math\n\n\nimport kotlin.internal.InlineOnly\nimport kotlin.js.JsMath as nativeMath\n\n\n// region ================ Double Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Double): Double = nativeMath.sin(x)\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Double): Double = nativeMath.cos(x)\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Double): Double = nativeMath.tan(x)\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Double): Double = nativeMath.asin(x)\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Double): Double = nativeMath.acos(x)\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Double): Double = nativeMath.atan(x)\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Double, x: Double): Double = nativeMath.atan2(y, x)\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Double): Double = nativeSinh(x)\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Double): Double = nativeCosh(x)\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Double): Double = nativeTanh(x)\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Double): Double = nativeAsinh(x)\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Double): Double = nativeAcosh(x)\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Double): Double = nativeAtanh(x)\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Double, y: Double): Double = nativeHypot(x, y)\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Double): Double = nativeMath.sqrt(x)\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Double): Double = nativeMath.exp(x)\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Double): Double = nativeExpm1(x)\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun log(x: Double, base: Double): Double {\n    if (base <= 0.0 || base == 1.0) return Double.NaN\n    return nativeMath.log(x) / nativeMath.log(base)\n}\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Double): Double = nativeMath.log(x)\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Double): Double = nativeLog10(x)\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Double): Double = nativeLog2(x)\n\n/**\n * Computes `ln(x + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Double): Double = nativeLog1p(x)\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest double value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Double): Double = nativeMath.ceil(x)\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest double value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Double): Double = nativeMath.floor(x)\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Double): Double = nativeTrunc(x)\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun round(x: Double): Double {\n    if (x % 0.5 != 0.0) {\n        return nativeMath.round(x)\n    }\n    val floor = floor(x)\n    return if (floor % 2 == 0.0) floor else ceil(x)\n}\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Double]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Double): Double = nativeMath.abs(x)\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Double): Double = nativeSign(x)\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Double, b: Double): Double = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Double, b: Double): Double = nativeMath.max(a, b)\n\n\n/**\n * Returns the cube root of [x]. For any `x`, `cbrt(-x) == -cbrt(x)`;\n * that is, the cube root of a negative value is the negative of the cube root\n * of that value's magnitude. Special cases:\n *\n * Special cases:\n *   - If the argument is `NaN`, then the result is `NaN`.\n *   - If the argument is infinite, then the result is an infinity with the same sign as the argument.\n *   - If the argument is zero, then the result is a zero with the same sign as the argument.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\n@InlineOnly\npublic actual inline fun cbrt(x: Double): Double = nativeMath.cbrt(x)\n\n\n// extensions\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(x: Double): Double = nativeMath.pow(this, x)\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(n: Int): Double = nativeMath.pow(this, n.toDouble())\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.absoluteValue: Double get() = nativeMath.abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.sign: Double get() = nativeSign(this)\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.withSign(sign: Int): Double = this.withSign(sign.toDouble())\n\n/**\n * Returns the ulp (unit in the last place) of this value.\n *\n * An ulp is a positive distance between this value and the next nearest [Double] value larger in magnitude.\n *\n * Special Cases:\n *   - `NaN.ulp` is `NaN`\n *   - `x.ulp` is `+Inf` when `x` is `+Inf` or `-Inf`\n *   - `0.0.ulp` is `Double.MIN_VALUE`\n */\n@SinceKotlin(\"1.2\")\npublic actual val Double.ulp: Double get() = when {\n    this < 0 -> (-this).ulp\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == Double.MAX_VALUE -> this - this.nextDown()\n    else -> this.nextUp() - this\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of positive infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextUp(): Double = when {\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == 0.0 -> Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) 1 else -1)\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of negative infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextDown(): Double = when {\n    this.isNaN() || this == Double.NEGATIVE_INFINITY -> this\n    this == 0.0 -> -Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) -1 else 1)\n}\n\n\n/**\n * Returns the [Double] value nearest to this value in direction from this value towards the value [to].\n *\n * Special cases:\n *   - `x.nextTowards(y)` is `NaN` if either `x` or `y` are `NaN`\n *   - `x.nextTowards(x) == x`\n *\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextTowards(to: Double): Double = when {\n    this.isNaN() || to.isNaN() -> Double.NaN\n    to == this -> to\n    to > this -> this.nextUp()\n    else /* to < this */ -> this.nextDown()\n}\n\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToInt(): Int = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Int.MAX_VALUE -> Int.MAX_VALUE\n    this < Int.MIN_VALUE -> Int.MIN_VALUE\n    else -> nativeMath.round(this).toInt()\n}\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToLong(): Long = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Long.MAX_VALUE -> Long.MAX_VALUE\n    this < Long.MIN_VALUE -> Long.MIN_VALUE\n    else -> nativeMath.round(this).toLong()\n}\n\n// endregion\n\n\n\n// region ================ Float Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Float): Float = nativeMath.sin(x.toDouble()).toFloat()\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Float): Float = nativeMath.cos(x.toDouble()).toFloat()\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Float): Float = nativeMath.tan(x.toDouble()).toFloat()\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Float): Float = nativeMath.asin(x.toDouble()).toFloat()\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Float): Float = nativeMath.acos(x.toDouble()).toFloat()\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Float): Float = nativeMath.atan(x.toDouble()).toFloat()\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Float, x: Float): Float = nativeMath.atan2(y.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Float): Float = nativeSinh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Float): Float = nativeCosh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Float): Float = nativeTanh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Float): Float = nativeAsinh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Float): Float = nativeAcosh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Float): Float = nativeAtanh(x.toDouble()).toFloat()\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Float, y: Float): Float = nativeHypot(x.toDouble(), y.toDouble()).toFloat()\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Float): Float = nativeMath.sqrt(x.toDouble()).toFloat()\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Float): Float = nativeMath.exp(x.toDouble()).toFloat()\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Float): Float = nativeExpm1(x.toDouble()).toFloat()\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log(x: Float, base: Float): Float = log(x.toDouble(), base.toDouble()).toFloat()\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Float): Float = nativeMath.log(x.toDouble()).toFloat()\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Float): Float = nativeLog10(x.toDouble()).toFloat()\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Float): Float = nativeLog2(x.toDouble()).toFloat()\n\n/**\n * Computes `ln(a + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Float): Float = nativeLog1p(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest Float value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Float): Float = nativeMath.ceil(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest Float value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Float): Float = nativeMath.floor(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Float): Float = truncate(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun round(x: Float): Float = round(x.toDouble()).toFloat()\n\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Float]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Float): Float = nativeMath.abs(x.toDouble()).toFloat()\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Float): Float = nativeSign(x.toDouble()).toFloat()\n\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Float, b: Float): Float = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Float, b: Float): Float = nativeMath.max(a, b)\n\n\n/**\n * Returns the cube root of [x]. For any `x`, `cbrt(-x) == -cbrt(x)`;\n * that is, the cube root of a negative value is the negative of the cube root\n * of that value's magnitude. Special cases:\n *\n * Special cases:\n *   - If the argument is `NaN`, then the result is `NaN`.\n *   - If the argument is infinite, then the result is an infinity with the same sign as the argument.\n *   - If the argument is zero, then the result is a zero with the same sign as the argument.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\n@InlineOnly\npublic actual inline fun cbrt(x: Float): Float = nativeMath.cbrt(x.toDouble()).toFloat()\n\n\n// extensions\n\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(x: Float): Float = nativeMath.pow(this.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(n: Int): Float = nativeMath.pow(this.toDouble(), n.toDouble()).toFloat()\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.absoluteValue: Float get() = nativeMath.abs(this.toDouble()).toFloat()\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.sign: Float get() = nativeSign(this.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Float): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Int): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToInt(): Int = toDouble().roundToInt()\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToLong(): Long = toDouble().roundToLong()\n\n\n// endregion\n\n// region ================ Integer Math ========================================\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Int]\n */\n// TODO: remove manual 'or' when KT-19290 is fixed\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Int): Int = if (n < 0) (-n or 0) else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Int, b: Int): Int = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Int, b: Int): Int = nativeMath.max(a, b)\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Int.MIN_VALUE.absoluteValue` is `Int.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Int.absoluteValue: Int get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Int.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Long]\n */\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Long): Long = if (n < 0) -n else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun min(a: Long, b: Long): Long = if (a <= b) a else b\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun max(a: Long, b: Long): Long = if (a >= b) a else b\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Long.MIN_VALUE.absoluteValue` is `Long.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Long.absoluteValue: Long get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Long.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n// endregion\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.random\n\nimport kotlin.math.pow\n\ninternal actual fun defaultPlatformRandom(): Random =\n    Random(js(\"(Math.random() * Math.pow(2, 32)) | 0\").unsafeCast<Int>())\n\n\nprivate val INV_2_26: Double = 2.0.pow(-26)\nprivate val INV_2_53: Double = 2.0.pow(-53)\ninternal actual fun doubleFromParts(hi26: Int, low27: Int): Double =\n    hi26 * INV_2_26 + low27 * INV_2_53","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.reflect.js.internal\n\nimport kotlin.js.JsClass\n\n@JsName(\"PrimitiveClasses\")\ninternal object PrimitiveClasses {\n    @JsName(\"anyClass\")\n    val anyClass = PrimitiveKClassImpl(js(\"Object\").unsafeCast<JsClass<Any>>(), \"Any\", { it is Any })\n\n    @JsName(\"numberClass\")\n    val numberClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Number>>(), \"Number\", { it is Number })\n\n    @JsName(\"nothingClass\")\n    val nothingClass = NothingKClassImpl\n\n    @JsName(\"booleanClass\")\n    val booleanClass = PrimitiveKClassImpl(js(\"Boolean\").unsafeCast<JsClass<Boolean>>(), \"Boolean\", { it is Boolean })\n\n    @JsName(\"byteClass\")\n    val byteClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Byte>>(), \"Byte\", { it is Byte })\n\n    @JsName(\"shortClass\")\n    val shortClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Short>>(), \"Short\", { it is Short })\n\n    @JsName(\"intClass\")\n    val intClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Int>>(), \"Int\", { it is Int })\n\n    @JsName(\"floatClass\")\n    val floatClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Float>>(), \"Float\", { it is Float })\n\n    @JsName(\"doubleClass\")\n    val doubleClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Double>>(), \"Double\", { it is Double })\n\n    @JsName(\"arrayClass\")\n    val arrayClass = PrimitiveKClassImpl(js(\"Array\").unsafeCast<JsClass<Array<*>>>(), \"Array\", { it is Array<*> })\n\n    @JsName(\"stringClass\")\n    val stringClass = PrimitiveKClassImpl(js(\"String\").unsafeCast<JsClass<String>>(), \"String\", { it is String })\n\n    @JsName(\"throwableClass\")\n    val throwableClass = PrimitiveKClassImpl(js(\"Error\").unsafeCast<JsClass<Throwable>>(), \"Throwable\", { it is Throwable })\n\n    @JsName(\"booleanArrayClass\")\n    val booleanArrayClass = PrimitiveKClassImpl(js(\"Array\").unsafeCast<JsClass<BooleanArray>>(), \"BooleanArray\", { it is BooleanArray })\n\n    @JsName(\"charArrayClass\")\n    val charArrayClass = PrimitiveKClassImpl(js(\"Uint16Array\").unsafeCast<JsClass<CharArray>>(), \"CharArray\", { it is CharArray })\n\n    @JsName(\"byteArrayClass\")\n    val byteArrayClass = PrimitiveKClassImpl(js(\"Int8Array\").unsafeCast<JsClass<ByteArray>>(), \"ByteArray\", { it is ByteArray })\n\n    @JsName(\"shortArrayClass\")\n    val shortArrayClass = PrimitiveKClassImpl(js(\"Int16Array\").unsafeCast<JsClass<ShortArray>>(), \"ShortArray\", { it is ShortArray })\n\n    @JsName(\"intArrayClass\")\n    val intArrayClass = PrimitiveKClassImpl(js(\"Int32Array\").unsafeCast<JsClass<IntArray>>(), \"IntArray\", { it is IntArray })\n\n    @JsName(\"longArrayClass\")\n    val longArrayClass = PrimitiveKClassImpl(js(\"Array\").unsafeCast<JsClass<LongArray>>(), \"LongArray\", { it is LongArray })\n\n    @JsName(\"floatArrayClass\")\n    val floatArrayClass = PrimitiveKClassImpl(js(\"Float32Array\").unsafeCast<JsClass<FloatArray>>(), \"FloatArray\", { it is FloatArray })\n\n    @JsName(\"doubleArrayClass\")\n    val doubleArrayClass = PrimitiveKClassImpl(js(\"Float64Array\").unsafeCast<JsClass<DoubleArray>>(), \"DoubleArray\", { it is DoubleArray })\n\n    @JsName(\"functionClass\")\n    fun functionClass(arity: Int): KClassImpl<Any> {\n        return functionClasses.get(arity) ?: run {\n            val result = PrimitiveKClassImpl(js(\"Function\").unsafeCast<JsClass<Any>>(), \"Function$arity\",\n                                             { jsTypeOf(it) === \"function\" && it.asDynamic().length === arity })\n            functionClasses.asDynamic()[arity] = result\n            result\n        }\n    }\n}\n\nprivate val functionClasses = arrayOfNulls<KClassImpl<Any>>(0)","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/** Returns the negative [size] if [throwOnMalformed] is false, throws [CharacterCodingException] otherwise. */\nprivate fun malformed(size: Int, index: Int, throwOnMalformed: Boolean): Int {\n    if (throwOnMalformed) throw CharacterCodingException(\"Malformed sequence starting at ${index - 1}\")\n    return -size\n}\n\n/**\n * Returns code point corresponding to UTF-16 surrogate pair,\n * where the first of the pair is the [high] and the second is in the [string] at the [index].\n * Returns zero if the pair is malformed and [throwOnMalformed] is false.\n *\n * @throws CharacterCodingException if the pair is malformed and [throwOnMalformed] is true.\n */\nprivate fun codePointFromSurrogate(string: String, high: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int {\n    if (high !in 0xD800..0xDBFF || index >= endIndex) {\n        return malformed(0, index, throwOnMalformed)\n    }\n    val low = string[index].code\n    if (low !in 0xDC00..0xDFFF) {\n        return malformed(0, index, throwOnMalformed)\n    }\n    return 0x10000 + ((high and 0x3FF) shl 10) or (low and 0x3FF)\n}\n\n/**\n * Returns code point corresponding to UTF-8 sequence of two bytes,\n * where the first byte of the sequence is the [byte1] and the second byte is in the [bytes] array at the [index].\n * Returns zero if the sequence is malformed and [throwOnMalformed] is false.\n *\n * @throws CharacterCodingException if the sequence of two bytes is malformed and [throwOnMalformed] is true.\n */\nprivate fun codePointFrom2(bytes: ByteArray, byte1: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int {\n    if (byte1 and 0x1E == 0 || index >= endIndex) {\n        return malformed(0, index, throwOnMalformed)\n    }\n    val byte2 = bytes[index].toInt()\n    if (byte2 and 0xC0 != 0x80) {\n        return malformed(0, index, throwOnMalformed)\n    }\n    return (byte1 shl 6) xor byte2 xor 0xF80\n}\n\n/**\n * Returns code point corresponding to UTF-8 sequence of three bytes,\n * where the first byte of the sequence is the [byte1] and the others are in the [bytes] array starting from the [index].\n * Returns a non-positive value indicating number of bytes from [bytes] included in malformed sequence\n * if the sequence is malformed and [throwOnMalformed] is false.\n *\n * @throws CharacterCodingException if the sequence of three bytes is malformed and [throwOnMalformed] is true.\n */\nprivate fun codePointFrom3(bytes: ByteArray, byte1: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int {\n    if (index >= endIndex) {\n        return malformed(0, index, throwOnMalformed)\n    }\n\n    val byte2 = bytes[index].toInt()\n    if (byte1 and 0xF == 0) {\n        if (byte2 and 0xE0 != 0xA0) {\n            // Non-shortest form\n            return malformed(0, index, throwOnMalformed)\n        }\n    } else if (byte1 and 0xF == 0xD) {\n        if (byte2 and 0xE0 != 0x80) {\n            // Surrogate code point\n            return malformed(0, index, throwOnMalformed)\n        }\n    } else if (byte2 and 0xC0 != 0x80) {\n        return malformed(0, index, throwOnMalformed)\n    }\n\n    if (index + 1 == endIndex) {\n        return malformed(1, index, throwOnMalformed)\n    }\n    val byte3 = bytes[index + 1].toInt()\n    if (byte3 and 0xC0 != 0x80) {\n        return malformed(1, index, throwOnMalformed)\n    }\n\n    return (byte1 shl 12) xor (byte2 shl 6) xor byte3 xor -0x1E080\n}\n\n/**\n * Returns code point corresponding to UTF-8 sequence of four bytes,\n * where the first byte of the sequence is the [byte1] and the others are in the [bytes] array starting from the [index].\n * Returns a non-positive value indicating number of bytes from [bytes] included in malformed sequence\n * if the sequence is malformed and [throwOnMalformed] is false.\n *\n * @throws CharacterCodingException if the sequence of four bytes is malformed and [throwOnMalformed] is true.\n */\nprivate fun codePointFrom4(bytes: ByteArray, byte1: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int {\n    if (index >= endIndex) {\n        malformed(0, index, throwOnMalformed)\n    }\n\n    val byte2 = bytes[index].toInt()\n    if (byte1 and 0xF == 0x0) {\n        if (byte2 and 0xF0 <= 0x80) {\n            // Non-shortest form\n            return malformed(0, index, throwOnMalformed)\n        }\n    } else if (byte1 and 0xF == 0x4) {\n        if (byte2 and 0xF0 != 0x80) {\n            // Out of Unicode code points domain (larger than U+10FFFF)\n            return malformed(0, index, throwOnMalformed)\n        }\n    } else if (byte1 and 0xF > 0x4) {\n        return malformed(0, index, throwOnMalformed)\n    } else if (byte2 and 0xC0 != 0x80) {\n        return malformed(0, index, throwOnMalformed)\n    }\n\n    if (index + 1 == endIndex) {\n        return malformed(1, index, throwOnMalformed)\n    }\n    val byte3 = bytes[index + 1].toInt()\n    if (byte3 and 0xC0 != 0x80) {\n        return malformed(1, index, throwOnMalformed)\n    }\n\n    if (index + 2 == endIndex) {\n        return malformed(2, index, throwOnMalformed)\n    }\n    val byte4 = bytes[index + 2].toInt()\n    if (byte4 and 0xC0 != 0x80) {\n        return malformed(2, index, throwOnMalformed)\n    }\n    return (byte1 shl 18) xor (byte2 shl 12) xor (byte3 shl 6) xor byte4 xor 0x381F80\n}\n\n/**\n * Maximum number of bytes needed to encode a single char.\n *\n * Code points in `0..0x7F` are encoded in a single byte.\n * Code points in `0x80..0x7FF` are encoded in two bytes.\n * Code points in `0x800..0xD7FF` or in `0xE000..0xFFFF` are encoded in three bytes.\n * Surrogate code points in `0xD800..0xDFFF` are not Unicode scalar values, therefore aren't encoded.\n * Code points in `0x10000..0x10FFFF` are represented by a pair of surrogate `Char`s and are encoded in four bytes.\n */\nprivate const val MAX_BYTES_PER_CHAR = 3\n\n/**\n * The byte sequence a malformed UTF-16 char sequence is replaced by.\n */\nprivate val REPLACEMENT_BYTE_SEQUENCE: ByteArray = byteArrayOf(0xEF.toByte(), 0xBF.toByte(), 0xBD.toByte())\n\n/**\n * Encodes the [string] using UTF-8 and returns the resulting [ByteArray].\n *\n * @param string the string to encode.\n * @param startIndex the start offset (inclusive) of the substring to encode.\n * @param endIndex the end offset (exclusive) of the substring to encode.\n * @param throwOnMalformed whether to throw on malformed char sequence or replace by the [REPLACEMENT_BYTE_SEQUENCE].\n *\n * @throws CharacterCodingException if the char sequence is malformed and [throwOnMalformed] is true.\n */\ninternal fun encodeUtf8(string: String, startIndex: Int, endIndex: Int, throwOnMalformed: Boolean): ByteArray {\n    require(startIndex >= 0 && endIndex <= string.length && startIndex <= endIndex)\n\n    val bytes = ByteArray((endIndex - startIndex) * MAX_BYTES_PER_CHAR)\n    var byteIndex = 0\n    var charIndex = startIndex\n\n    while (charIndex < endIndex) {\n        val code = string[charIndex++].code\n        when {\n            code < 0x80 ->\n                bytes[byteIndex++] = code.toByte()\n            code < 0x800 -> {\n                bytes[byteIndex++] = ((code shr 6) or 0xC0).toByte()\n                bytes[byteIndex++] = ((code and 0x3F) or 0x80).toByte()\n            }\n            code < 0xD800 || code >= 0xE000 -> {\n                bytes[byteIndex++] = ((code shr 12) or 0xE0).toByte()\n                bytes[byteIndex++] = (((code shr 6) and 0x3F) or 0x80).toByte()\n                bytes[byteIndex++] = ((code and 0x3F) or 0x80).toByte()\n            }\n            else -> { // Surrogate char value\n                val codePoint = codePointFromSurrogate(string, code, charIndex, endIndex, throwOnMalformed)\n                if (codePoint <= 0) {\n                    bytes[byteIndex++] = REPLACEMENT_BYTE_SEQUENCE[0]\n                    bytes[byteIndex++] = REPLACEMENT_BYTE_SEQUENCE[1]\n                    bytes[byteIndex++] = REPLACEMENT_BYTE_SEQUENCE[2]\n                } else {\n                    bytes[byteIndex++] = ((codePoint shr 18) or 0xF0).toByte()\n                    bytes[byteIndex++] = (((codePoint shr 12) and 0x3F) or 0x80).toByte()\n                    bytes[byteIndex++] = (((codePoint shr 6) and 0x3F) or 0x80).toByte()\n                    bytes[byteIndex++] = ((codePoint and 0x3F) or 0x80).toByte()\n                    charIndex++\n                }\n            }\n        }\n    }\n\n    return if (bytes.size == byteIndex) bytes else bytes.copyOf(byteIndex)\n}\n\n/**\n * The character a malformed UTF-8 byte sequence is replaced by.\n */\nprivate const val REPLACEMENT_CHAR = '\\uFFFD'\n\n/**\n * Decodes the UTF-8 [bytes] array and returns the resulting [String].\n *\n * @param bytes the byte array to decode.\n * @param startIndex the start offset (inclusive) of the array to be decoded.\n * @param endIndex the end offset (exclusive) of the array to be encoded.\n * @param throwOnMalformed whether to throw on malformed byte sequence or replace by the [REPLACEMENT_CHAR].\n *\n * @throws CharacterCodingException if the array is malformed UTF-8 byte sequence and [throwOnMalformed] is true.\n */\ninternal fun decodeUtf8(bytes: ByteArray, startIndex: Int, endIndex: Int, throwOnMalformed: Boolean): String {\n    require(startIndex >= 0 && endIndex <= bytes.size && startIndex <= endIndex)\n\n    var byteIndex = startIndex\n    val stringBuilder = StringBuilder()\n\n    while (byteIndex < endIndex) {\n        val byte = bytes[byteIndex++].toInt()\n        when {\n            byte >= 0 ->\n                stringBuilder.append(byte.toChar())\n            byte shr 5 == -2 -> {\n                val code = codePointFrom2(bytes, byte, byteIndex, endIndex, throwOnMalformed)\n                if (code <= 0) {\n                    stringBuilder.append(REPLACEMENT_CHAR)\n                    byteIndex += -code\n                } else {\n                    stringBuilder.append(code.toChar())\n                    byteIndex += 1\n                }\n            }\n            byte shr 4 == -2 -> {\n                val code = codePointFrom3(bytes, byte, byteIndex, endIndex, throwOnMalformed)\n                if (code <= 0) {\n                    stringBuilder.append(REPLACEMENT_CHAR)\n                    byteIndex += -code\n                } else {\n                    stringBuilder.append(code.toChar())\n                    byteIndex += 2\n                }\n            }\n            byte shr 3 == -2 -> {\n                val code = codePointFrom4(bytes, byte, byteIndex, endIndex, throwOnMalformed)\n                if (code <= 0) {\n                    stringBuilder.append(REPLACEMENT_CHAR)\n                    byteIndex += -code\n                } else {\n                    val high = (code - 0x10000) shr 10 or 0xD800\n                    val low = (code and 0x3FF) or 0xDC00\n                    stringBuilder.append(high.toChar())\n                    stringBuilder.append(low.toChar())\n                    byteIndex += 3\n                }\n            }\n            else -> {\n                malformed(0, byteIndex, throwOnMalformed)\n                stringBuilder.append(REPLACEMENT_CHAR)\n            }\n        }\n    }\n\n    return stringBuilder.toString()\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(102);\n"],"names":["root","factory","exports","module","define","amd","this","leafPrototypes","getProto","StyleSheet","options","_this","_insertTag","tag","before","tags","length","insertionPoint","nextSibling","prepend","container","firstChild","insertBefore","push","isSpeedy","undefined","speedy","ctr","nonce","key","_proto","prototype","hydrate","nodes","forEach","insert","rule","document","createElement","setAttribute","appendChild","createTextNode","createStyleElement","sheet","i","styleSheets","ownerNode","sheetForTag","insertRule","cssRules","e","flush","parentNode","removeChild","abs","Math","String","fromCharCode","Object","assign","trim","value","pattern","replacement","replace","indexof","search","indexOf","index","charCodeAt","begin","end","slice","array","line","column","position","character","characters","node","parent","type","props","children","return","prev","next","peek","caret","token","alloc","dealloc","delimit","delimiter","whitespace","escaping","count","commenter","identifier","COMMENT","callback","output","stringify","element","join","compile","parse","rules","rulesets","pseudo","points","declarations","offset","atrule","property","previous","variable","scanning","ampersand","reference","comment","declaration","ruleset","post","size","j","k","x","y","z","identifierWithPointTracking","fixedElements","WeakMap","compat","isImplicitRule","get","set","parsed","toRules","getRules","parentRules","removeLabel","hash","defaultStylisPlugins","map","exec","ssrStyles","querySelectorAll","Array","call","getAttribute","head","_insert","stylisPlugins","inserted","nodesToHydrate","attrib","split","currentSheet","collection","finalizingPlugins","serializer","concat","selector","serialized","shouldCache","styles","cache","name","registered","insertWithoutScoping","merge","css","className","registeredStyles","rawClassName","classnames","args","cls","arg","toAdd","isArray","_createEmotion","_len","arguments","_key","cx","_len4","_key4","injectGlobal","_len3","_key3","keyframes","_len2","_key2","animation","ids","getRegisteredStyles","bind","fn","create","str","h","len","toString","animationIterationCount","borderImageOutset","borderImageSlice","borderImageWidth","boxFlex","boxFlexGroup","boxOrdinalGroup","columnCount","columns","flex","flexGrow","flexPositive","flexShrink","flexNegative","flexOrder","gridRow","gridRowEnd","gridRowSpan","gridRowStart","gridColumn","gridColumnEnd","gridColumnSpan","gridColumnStart","msGridRow","msGridRowSpan","msGridColumn","msGridColumnSpan","fontWeight","lineHeight","opacity","order","orphans","tabSize","widows","zIndex","zoom","WebkitLineClamp","fillOpacity","floodOpacity","stopOpacity","strokeDasharray","strokeDashoffset","strokeMiterlimit","strokeOpacity","strokeWidth","hyphenateRegex","animationRegex","isCustomProperty","isProcessableValue","processStyleName","styleName","toLowerCase","processStyleValue","match","p1","p2","cursor","handleInterpolation","mergedProps","interpolation","__emotion_styles","anim","obj","string","interpolated","_i","createStringFromObject","previousCursor","result","cached","labelPattern","serializeStyles","stringMode","strings","raw","lastIndex","identifierName","target","source","hasOwnProperty","apply","reactPropsRegex","prop","test","useInsertionEffect","EmotionCacheContext","useLayoutEffect","createContext","HTMLElement","Provider","withEmotionCache","func","forwardRef","ref","useContext","ThemeContext","testOmitPropsOnStringTag","testOmitPropsOnComponent","getDefaultShouldForwardProp","composeShouldForwardProps","isReal","shouldForwardProp","optionsShouldForwardProp","__emotion_forwardProp","propName","_ref","isStringTag","newStyled","createStyled","targetClassName","__emotion_real","baseTag","__emotion_base","label","defaultShouldForwardProp","shouldUseAs","Styled","FinalTag","as","classInterpolations","theme","finalShouldForwardProp","newProps","Fragment","displayName","defaultProps","defineProperty","withComponent","nextTag","nextOptions","tagName","classNames","registerStyles","insertStyles","current","l","Symbol","for","n","p","q","r","t","u","v","w","iterator","B","isMounted","enqueueForceUpdate","enqueueReplaceState","enqueueSetState","C","D","E","a","b","context","refs","updater","F","G","isReactComponent","setState","Error","forceUpdate","H","constructor","isPureReactComponent","I","J","K","L","__self","__source","M","d","c","g","f","m","$$typeof","_owner","O","P","Q","escape","R","N","A","done","keys","S","T","_status","_result","then","default","U","V","transition","W","ReactCurrentDispatcher","ReactCurrentBatchConfig","ReactCurrentOwner","Children","toArray","only","Component","Profiler","PureComponent","StrictMode","Suspense","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","cloneElement","_currentValue","_currentValue2","_threadCount","Consumer","_defaultValue","_globalName","_context","createFactory","createRef","render","isValidElement","lazy","_payload","_init","memo","compare","startTransition","unstable_act","useCallback","useDebugValue","useDeferredValue","useEffect","useId","useImperativeHandle","useMemo","useReducer","useRef","useState","useSyncExternalStore","useTransition","version","println","URL","it","data","getElementById","div","innerHTML","getElementsByTagName","WebSocket","onopen","onmessage","onclick","send","message","marginTop","marginBottom","fontSize","onChange","event","FC","padding","backgroundColor","color","input","_","Kotlin","$module$kotlin_extensions","defineInlineFunction","Kind","INTERFACE","CLASS","$module$_emotion_css","$module$kotlin_csstype","$module$_emotion_styled","$$importsForInline$$","wrapFunction","kotlin","collections","Iterator","IllegalStateException_init_pdl1vj$","$module$react","Unit","IllegalArgumentException_init_pdl1vj$","react","Kind_OBJECT","OBJECT","ReactHTML","ReactHTML_instance","configurable","$metadata$","kind","simpleName","interfaces","package$react","package$dom","dom","package$html","html","$module$kotlin_react_core","CHILDREN","Kind_INTERFACE","Kind_CLASS","single","single_us0mfu$","ChildrenBuilder","ChildrenBuilder_0","ChildrenBuilderImpl","FC$lambda","closure$block","createElementOrNull","closure$props","$receiver","FC$lambda$lambda","create_0","block","tmp$","builder","tmp$_0","child","unaryPlus_lapc4x$","child_m8hz59$","unaryPlus_kzna72$","unaryPlus_pdl1vz$","child_sv8fgx$","invoke_r7bapy$","invoke_gax9jq$","invoke_1uzlnf$","closure$value","invoke_snd3xh$","createChildrenBuilder","FC_4y0n3r$","create_gax9jq$","createElementOrNull_khlwf$","$type$","isArrayish","ArrayBuffer","isView","toByte","equals","obj1","obj2","hashCode","objType","getObjectHashCode","numberHashCode","Number","getStringHashCode","o","buf","bufFloat64","bufInt32","lowIndex","highIndex","OBJECT_HASH_CODE_PROPERTY_NAME","random","enumerable","throwMarkerError","imul","isInheritanceFromInterface","ctor","iface","metadata","superPrototype","getPrototypeOf","superConstructor","identityHashCode","Long","low_","low","high_","high","IntCache_","fromInt","cachedObj","fromNumber","isNaN","ZERO","TWO_PWR_63_DBL_","MIN_VALUE","MAX_VALUE","negate","TWO_PWR_32_DBL_","fromBits","lowBits","highBits","fromString","radix","opt_radix","charAt","substring","radixToPower","pow","min","parseInt","power","multiply","add","TWO_PWR_16_DBL_","TWO_PWR_24_DBL_","TWO_PWR_31_DBL_","TWO_PWR_48_DBL_","TWO_PWR_64_DBL_","ONE","NEG_ONE","TWO_PWR_24_","toInt","toNumber","getLowBitsUnsigned","isZero","isNegative","equalsLong","radixLong","rem","subtract","remDiv","digits","getHighBits","getLowBits","getNumBitsAbs","val","bit","isOdd","other","notEqualsLong","lessThan","lessThanOrEqual","greaterThan","greaterThanOrEqual","thisNeg","otherNeg","not","a48","a32","a16","a00","b48","b32","b16","c48","c32","c16","c00","b00","approx","shiftRight","shiftLeft","res","max","floor","log2","ceil","log","LN2","delta","approxRes","approxRem","modulo","and","or","xor","numBits","shiftRightUnsigned","compareTo_11rb$","inc","dec","valueOf","unaryPlus","unaryMinus","inv","rangeTo","ranges","LongRange","fun","suspendCall","coroutineResult","coroutineReceiver","compareTo","typeA","doubleCompareTo","primitiveCompareTo","ia","imulEmulated","Float64Array","Float32Array","Int32Array","ensureNotNull","throwNPE","startsWith","searchString","lastIndexOf","endsWith","subjectString","sign","trunc","NaN","taylor_2_bound","sqrt","taylor_n_bound","upper_taylor_2_bound","upper_taylor_n_bound","sinh","exp","y1","isFinite","cosh","tanh","Infinity","asinh","acosh","atanh","log1p","x2","x3","expm1","hypot","log10","LOG10E","LOG2E","clz32","asUint","__proto__","Int8Array","fill","TypeError","relativeStart","relativeEnd","finalValue","normalizeOffset","typedArraySlice","subarray","arrays","Int16Array","Uint16Array","TypedArray","Function","self","totalOrderComparator","sort","compareFunction","isType","object","klass","proto","klassMetadata","ordinal","initValue","fillArrayVal","currentException","completion","intercepted","cause","ignoreCase","uppercaseChar","cur","step","last","start","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","mode","__esModule","ns","def","getOwnPropertyNames","definition","toStringTag"],"sourceRoot":""}